---
title: JVM虚拟机
date: 2022-08-08 15:19:52
tags: [Java,JVM]
---

# 1: 内存与垃圾回收篇

## JVM的整体结构

><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220903135907749.png" alt="image-20220903135907749" style="zoom:200%;" />

![image-20220820205156098](https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220820205156098.png)

### JVM架构模型

- 基于栈的指令集架构: 跨平台性、指令集小、指令多;执行性能比寄存器差
- 基于寄存器的指令集架构: 

### JVM的生命周期

- 启动 : Java虚拟机的启动是通过引导类加载器(bootstrap class loader)创建个初始类(initial class)来完成的
- 执行: 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟
  机的进程。
- 退出: 

## 运行时数据区

> 灰色的为单独线程私有的，红色的为多个线程共享的。即:
> 每个线程: 独立包括程序计数器、栈、本地栈。
> 线程间共享: 堆、堆外内存（永久代或元空间、代码缓存）
>
> ![image-20220906095355477](https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220906095355477.png)

### 本地方法栈

> Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法(C/C++实现的方法)的调用。

- 当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。

### **程序计数器**

- PC寄存器用来存储指向下一条指令的地址，
- 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。
- 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。
- 任何时间一个线程都只有一个方法在执行，也就是所谓的**当前方法**。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址;或者，如果是在执行native方法，则是未指定值（undefned) 。

### 虚拟机栈

>Java虚拟机栈（Java virtual Machine stack)，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(stack Frame） ，对应着一次次的Java方法调用。是线程私有的
>
>可以使用参数-Xss选项来设置线程的最大栈空间

**内部结构**

![image-20220916220020359](https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220916220020359.png)

- 局部变量表(Local Variables)
  - 定义为一个数字数组，主要用于**存储方法参数**和定义在方法体内的**局部变量**
  - 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据交全问题
  - 局部变量表所需的容量大小是在编译期确定下来的
  - 局部变量表中的变量也是**重要的垃圾回收根节点(GCRoots)**，只要被局部变量表中接或间接引用的对象都不会被回收。
- 操作数栈(Operand Stack)
  - 主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储]间。
  - 在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop).
- 动态链接(Dynamic Linking)---旨向运行时常量池的方法引用)
  - 每一个栈帧内部都包含一个指向**运行时常量池**中**该栈帧所属方法的引用**。为了支持当前方法的代码能够实现动态链接( Dynamic Linking) 。

- 方法返回地址(Return Address)
  - 存放调用该方法的pc寄存器的值。
  - 在方法退出后会返回到**该方法被调用的位置**。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。

### 堆

> ![image-20220921154304304](https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220921154304304.png)
>
> 1. -Xms 起始内存, -Xmx 最大内存
> 2. 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。
> 3. Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。大小可调节
> 4. 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(ThreadLocal Allocation Buffer,TLAB)。

**年轻代与老年代**

- 各分区比例

  ![image-20220923162007757](https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220923162007757.png)

**Minor GC, Major GC, Full GC**

JVM在进行GC时，并非每次都对上面三个内存区域(新生代、老年代、方法区)一起回收的，大部分时候回收的都是指新生代。

- 部分收集: 不是完整收集整个Java堆的垃圾收集。其中又分为:

  - 新生代收集(Minor Gc / Young GC): 只是新生代的垃圾收集
  - 老年代收集(Major Gc / Old GC): 只是老年代的垃圾收集。**很多时候Major Gc会和Full Gc混淆使用，需要具体分辨是老年代回收还是整堆回收。**

  - 混合收集(Mixed GC): 收集整个新生代以及部分老年代的垃圾收集。目前,只有G1 GC会有这种行为

- 整堆收集（Full GC): 收集整个java堆和方法区的垃圾收集。

**内存分配策略**

- 优先分配到Eden
- 大对象直接分配到老年代
- 动态对象年龄判断: 如果survivor区中相同年龄的所有对象大小的总和大于survivor空间的一半，可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。
- 空间分配担保   Xx:HandlePromotionFailure
- 标量替换: 存储在栈

**TLAB**

- 对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域。
- 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。

### 方法区

> 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误: java.lang.outofMemoryError:

- 它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。

**运行时常量池**

- 常量池表（Constant Pool Table）是class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

**垃圾回收**

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
- 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。
- 该类对应的java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 垃圾回收

### 垃圾回收算法

**标记阶段**

- 引用计数法
  - 引用计数算法(Reference Counting)比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。
  - 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。

- 可达性分析算法
  - 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效**地解决在引用计数算法中循环引用的问题**，防止内存泄漏的发生。
  - .....
  - 由于finalize ()方法的存在，**虚拟机中的对象一般处于三种可能的状态**。
    - 可触及的:从根节点开始，可以到达这个对象。
    - 可复活的:对象的所有引用都被释放，但是对象有可能在finalize ( )中复活。
    - 不可触及的:对象的finalize ( )被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。

**清除阶段**

![image-20221015131311740](https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221015131311740.png)

- 标记-清除算法(Mark - Sweep)

  > 当堆中的有效内存空间(available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world)I，然后进行两项工作，第一项则是标记，第二项则是清除。

  - 标记:Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。
  - 清除:Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。

- 复制算法(Copying)

  > 将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。
  >
  > 适合: 垃圾较多

- 标记-压缩算法(Mark - Compact)

  >标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩(Mark-Sweep-Compact)算法。

  - 第一阶段和标记-清除算法一样,从根节点开始标记所有被引用对象
  - 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。
  - 清理边界外所有的空间。

**分代收集算法**

**增量收集算法**

- 垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。
- 增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。
- 但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。

**分区算法**

- 分代算法将按照对象的生命周期长短划分成两个部分分区算法将整个堆空间划分成连续的不同小区间。
- 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。 

### 垃圾回收器

> 不同的垃圾回收器概述
>
> ![image-20221023142302706](https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023142302706.png)
>
> 不同的垃圾回收器组合关系
>
> ![image-20221023142431767](https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023142431767.png)



**Serial回收器: 串行回收**   使用:-XX:+UseserialGC

- serial 收集器**采用复制算法**、串行回收和"Stop-The-World"机制方式执行内存回收。

- 除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial Old收集器同样也采用了串行回收和"Stop The World"机制，只不过内存回收算法使用的是**标记-压缩算法**。

- 这个收集器是一个单线程的收集器，它只会使用一个CPU或一条收集线程去完成垃圾收集工作，在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束( Stop The world)

  ![image-20221023143724508](https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023143724508.png)

**ParNew回收器: 并行回收** 使用:-XX:+UseSerialGC

- ParNew收集器是Serial收集器的多线程版本。1.9过时

  ![image-20221023144243494](https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023144243494.png)

**Parallel回收器: 吞吐量优先** (Java8默认)

- 和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个**可控制的吞吐量**（Throughput），它也被称为吞吐量优先的垃圾收集器。

- 自适应调节策略也是Parallel scavenge与ParNew一个重要区别。

- 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。

- Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。

- Parallel old收集器采用了标记-压缩算法，但同样也是基于并行回收和"Stop-the-world"机制。

  ![image-20221023145102489](https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023145102489.png)

- 参数配置:
  - -XX:ParallelGCThreads : 设置年轻代并行收集器的线程数
  - -XX:MaxGCPauseMillis设置垃圾收集器最大停顿时间(即STw的时间)。单位是毫秒。(慎用)
  - -XX:GCTimeRatio 垃圾收集时间占总时间的比例(= 1 / (N ＋ 1))用于衡量吞吐量的大小。
  - -XX:+UseAdaptivesizePolicy设置Parallel scavenge收集器具有自适应调节策略

**CMS回收器: 低延迟 ** Java14 G1代替

- 在JDK 1.5时期，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器

- CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。

- CMS的垃圾收集算法采用标记-清除算法，并且也会"Stop-The-World"

  ![image-20221023150902769](https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023150902769.png)

  **CMS整个过程分为4个主要阶段:**

- 初始标记（Initial-Mark）阶段: 这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。

- 并发标记（Concurrent-Mark）阶段: 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。

- 重新标记（Remark）阶段: 为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。

- 并发清除(Concurrent-Sweep）阶段: 此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的

  **弊端:**

1. 会产生内存碎片
2. CMS收集器对CPU资源非常敏感。
3. CMS收集器无法处理浮动垃圾

**G1回收器(Garbage First)** JDK7启用  JDK9后默认

- 因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域(Region)（物理上不连续的）。使用不同的Region来表示Eden、幸存者o区，幸存者1区，老年代等。
- G1 cc有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1跟踪各个 Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。
- 由于这种方式的侧重点在于回收垃圾最大量的区间（Region)，所以我们给c1一个名字:垃圾优先（Garbage First） 。

​	**G1回收器的特点(优势)**

- 并行与并发
  - 并行性: G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STw
  - 并发性: G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况
- 分代收集
  - 将堆空间分为若干个区域(Region）,这些区域中包含了逻辑上的年轻代和老年代。
  - 和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代;
- 空间整和
  - CMS: “标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理
  - 内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩(Mark-Compact)算法，两种算法都可以**避免内存碎片**。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。

- 可预测的停顿时间模型 ( 即: 软实时 soft real-time)

  这是G1相对于CMS 的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒,

  - 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。
  - G1跟踪各个 Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1 收集器在有限的时间内可以获取尽可能高的收集效率。
  - 相比于CMS GC，G1未必能做到cMs在最好情况下的延时停顿，但是最差情况要好很多。

​	**G1垃圾回收环节**

- 年轻代GC(Young GC)

- 老年代并发标记过程(Concurrent Marking)

- 混合回收(Mixed GC)

- （如果需要，单线程、独占式、高强度的Full Gc还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。)

  ![image-20221024172622661](https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221024172622661.png)

  

### GC日志分析

- 导出日志: -Xlogs/gc.log

# 2: 字节码与类加载篇

## Class文件结构

| 类型           | 名称                | 说明                    | 长度    | 数量                  |
| -------------- | ------------------- | ----------------------- | ------- | --------------------- |
| u4             | magic               | 魔术, 识别Class文件格式 | 4个字节 | 1                     |
| u2             | minor_version       | 副版本号(小版本)        | 2个字节 | 1                     |
| u2             | majot_version       | 主版本号(大版本)        | 2个字节 | 1                     |
| u2             | constant_pool_count | 常量池计数器            | 2个字节 | 1                     |
| cp_info        | constant_pool       | 常量池表                | n个字节 | constant_pool_count-1 |
| u2             | access_flags        | 访问标识                | 2个字节 | 1                     |
| u2             | this_class          | 类索引                  | 2个字节 | 1                     |
| u2             | super_class         | 父类索引                | 2个字节 | 1                     |
| u2             | interfaces_count    | 接口计数器              | 2个字节 | 1                     |
| u2             | interfaces          | 接口索引集合            | 2个字节 | interfaces_count      |
| u2             | field_count         | 字段计数器              | 2个字节 | 1                     |
| field_info     | fields              | 字段表                  | n个字节 | fields_count          |
| u2             | methods_count       | 方法计数器              | 2个字节 | 1                     |
| method_info    | methods             | 方法表                  | n个字节 | methods_count         |
| u2             | attributes_count    | 属性计数器              | 2个字节 | 1                     |
| attribute_info | attributes          | 属性表                  | n个字节 | attributes_count      |

## 字节码指令集与解析

- 加载与存储指令
- 算术指令
- 类型转换指令
- 对象的创建与访问指令
- 方法调用与返回指令
  - invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java语言中**最常见的方法分派方式**。
  - invokeinterface指令用于**调用接口方法**，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。
  - invokespecial指令用于调用一些需要特殊处理的实例方法，包括**实例初始化方法（构造器**）、**私有方法和父类方法**。这些方法都是**静态类型绑定**的，不会在调用时进行动态派发。
  - invokestatic指令用于调用命名类中的**类方法（static方法）**。这是静态绑定的。
  - invokedynamic:调用动态绑定的方法，这个是JDK 1.7后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行核方法。前面4条调用指令的分派逻辑都固化在java 虚拟机内部，而
    invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。
- 操作数栈管理指令
- 控制转移指令
- 异常处理指令
- 同步控制指令

## 类的加载过程详解

> ![image-20220904152928052](https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220904152928052.png)

### 类加载过程

**Loading(加载)**

Java类在JVM内存中加载一个快照，JVM将从字节码文件中解析出的**常量池、类字段、类方法**等信息存储到内存中，并在内存中构建出Java类的原型——类模板对象。

1．通过一个类的全限定名获取定义此类的二进制字节流
2．将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3．在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

**Linking(链接)**

- 验证: 主要包括四种验证，文件格式验证，语义验证，字节码验证，符号引用验证。

  ![image-20221101144858320](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20221101144858320.png)

- 准备: 

  - 为类变量分配内存并且设置该类变量的默认初始值，即零值
  - 这里不包含用final修饰的static，因为**final在编译的时候就会分配了**，准备阶段会显式初始化;
  - 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。

- 解析: 解析动作主要针对类或接口、字段、类方法  、接口方法、方法类型等。

**Initialization(初始化)**

- 初始化阶段就是执行类构造器方法<clinit>()的过程。
- 此方法不需定义，是javac编译器自动收集类中的所有**类变量的赋值动作**和**静态代码块中的语句**合并而来。
- 主动使用&被动使用 

**Using(使用)** 

**Unloading(卸载)**

### 类加载器的分类

> 官方JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义加载器(User-Defined ClassLoader)。

- 启动类加载器（引导类加载器Bootstrap ClassLoader）
  - 这个类加载使用C/C++语言实现的，嵌套在JVM内部。
  - 用来加载Java的核心库, java. , javax. sun. 下的类
  - 并不继承自java.lang.ClassLoader, 没有父加载器
- 扩展类加载器 ( Extension ClassLoader )
  - Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。
  - 派生于ClassLoader
  - 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。
- 应用程序类加载器（系统类加载器，AppclassLoader)
  - 它负责加载环境变量clsspath或系统属性java.class.path指定路径下的类库
  - 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载 
- 用户自定义加载类
  - 隔离加载类
  - 修改类加载的方式
  - 扩展加载源
  - 防止源码泄漏

### 双亲委派机制

> Java虚拟机对class文件采用的是按需加载的方式，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。

**工作原理**

1. 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行
2. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归请求最终将到达顶层的启动类加载器
3. 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载

![image-20220906093247195](https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220906093247195.png)

**优势**

- 避免类的重复加载
- 防止核心API被随意篡改

# 3: 性能监控与调优篇

## JVM监控及诊断工具

**命令行工具**

- jps: 查看正在运行的Java进程
- jstat: 查看JVM统计信息
- jinfo: 实时查看和修改JVM配置参数
- jmap: 导出内存映像文件
- jhat: JDK自带堆分析工具
- jstack: 追踪JVM中线程快照
- jcmd: 多功能命令行工具
- jstatd: 远程主机信息收集

**GUI篇**

- jConsole
- Visual VM
- ecplise MAT
- JProfiler
- Arthas
- Java Mission Control
- Btrace
- Flame Graphs

**内存泄漏的8种情况**

1. 静态集合类
2. 单例模式
3. 内部类持有外部类
4. 各种连接，如数据库连接、网络连接和IO连接等
5. 变量不合理的作用域
6. 改变哈希值
7. 缓存泄漏
8. 监听器和回调

## JVM运行时参数



分析GC日志

OOM常见场景及解决方案

性能优化案例

375/381P

