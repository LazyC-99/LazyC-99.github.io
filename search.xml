<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ActiveMQ使用</title>
    <url>/2021/07/05/ActiveMQ/</url>
    <content><![CDATA[<h4 id="ActiveMQ介绍"><a href="#ActiveMQ介绍" class="headerlink" title="ActiveMQ介绍"></a>ActiveMQ介绍</h4><p>​     MQ是消息中间件，是一种在分布式系统中应用程序借以传递消息的媒介，常用的有ActiveMQ，RabbitMQ(erlang)，kafka。ActiveMQ是Apache下的开源项目，完全支持JMS1.1和J2EE1.4规范的JMS Provider实现。</p>
<a id="more"></a>

<p>特点：<br>1、支持多种语言编写客户端<br>2、对spring的支持，很容易和spring整合<br>3、支持多种传输协议：TCP,SSL,NIO,UDP等<br>4、支持AJAX<br>消息形式：<br>1、点对点（queue）<br>2、一对多（topic）</p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210707211328.png"></p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210707211339.png"></p>
<h4 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h4><h5 id="创建连接工厂"><a href="#创建连接工厂" class="headerlink" title="创建连接工厂"></a>创建连接工厂</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂</span></span><br><span class="line">        ActiveMQConnectionFactory activeMQConnectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;tcp://127.0.0.1:61616&quot;</span>);</span><br><span class="line">        <span class="comment">//2.通过连接工厂，获得连接并启动访问</span></span><br><span class="line">        Connection connection = activeMQConnectionFactory.createConnection();</span><br><span class="line">        connection.start();</span><br><span class="line">        <span class="comment">//3.创建会话Session(参数：事务|签收)</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>,Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//4.创建目的地(具体是队列queen还是主题topic)</span></span><br><span class="line">        Queue queue = session.createQueue(<span class="string">&quot;queue01&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.创建消息生产者</span></span><br><span class="line">MessageProducer messageProducer = session.createProducer(queue);</span><br><span class="line"><span class="comment">//6.生产消息发送到MQ队列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">    TextMessage textMessage =session.createTextMessage(<span class="string">&quot;msg--&quot;</span>+i);</span><br><span class="line">    messageProducer.send(textMessage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">messageProducer.close();</span><br><span class="line">session.close();</span><br><span class="line">connection.close();</span><br><span class="line">System.out.printf(<span class="string">&quot;******发送完成&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.创建消息消费者</span></span><br><span class="line">MessageConsumer messageConsumer = session.createConsumer(queue);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    TextMessage textMessage = (TextMessage) messageConsumer.receive();<span class="comment">//.receive(timeout)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span>!= textMessage)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;****消费者接收到消息：&quot;</span>+textMessage.getText());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="两种消费者方式"><a href="#两种消费者方式" class="headerlink" title="两种消费者方式"></a>两种消费者方式</h6><ul>
<li><p>同步阻塞方式（receive()）</p>
<p>订阅者或接收者调用MessageConsumer的receive()方法接收消息，receive方法在能够接收到消息之前(超时之前)将一直阻塞。</p>
</li>
<li><p>异步非阻塞方式（监听器onMessage()）</p>
<p>订阅者或接受者通过调用MessageConsumer的setMessgeLisener(MessageListener listener) 注册一个消息监听器，当消息到达之后，系统自动调用监听器MessageListener的onMessage(Message message)方法。</p>
</li>
</ul>
<h4 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h4><p>yml配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">activemq:</span></span><br><span class="line">      <span class="attr">broker-url:</span> <span class="string">tcp://127.0.0.1:61616</span></span><br><span class="line">      <span class="attr">user:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">jms:</span></span><br><span class="line">      <span class="attr">pub-sub-domain:</span> <span class="literal">false</span> 		<span class="comment">#false = Queue	true = topic</span></span><br></pre></td></tr></table></figure>

<p>配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJms</span>  <span class="comment">//启动消息队列（启动类）</span></span><br><span class="line"><span class="comment">//@EnableJmsScheduling    //开启定投</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myqueue&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String myQueue;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQQueue(myQueue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue_Produce</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Queue queue;<span class="comment">//destination</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息发送</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jmsMessagingTemplate.convertAndSend(queue,<span class="string">&quot;message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//间隔定投</span></span><br><span class="line">    <span class="meta">@Scheduked(fixedDelay = 3000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> produceMsgScheduled&#123;</span><br><span class="line">        jmsMessagingTemplate.convertAndSend(queue,<span class="string">&quot;message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue_Consumer</span></span>&#123;</span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;$&#123;myqueue&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者接收到消息...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTY0NDExRzdhQj9wPTQ0">https://www.bilibili.com/video/BV164411G7aB?p=44<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的安装使用</title>
    <url>/2020/11/11/Docker%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p>
<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>
<a id="more"></a>

<h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><ol>
<li><p>Docker要求CentOS系统内核版本高于3.10,查看CentOS内核版本:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uname -r</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install docker</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl start docker</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将docer设为开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> docker</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置镜像</p>
<ul>
<li>登录阿里云 —-容器镜像服务——-镜像工具——-镜像加速器</li>
</ul>
</li>
</ol>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">docker search 关键字</td>
<td align="center">检索</td>
</tr>
<tr>
<td align="center">docker pull 镜像名:tag</td>
<td align="center">拉取</td>
</tr>
<tr>
<td align="center">docker images</td>
<td align="center">查询已下载的镜像</td>
</tr>
<tr>
<td align="center">docker rmi  image-id</td>
<td align="center">删除镜像</td>
</tr>
</tbody></table>
<h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">docker run –name container-name -d image-name||eg:docker run –name mytomcat -d tomcat:latest</td>
<td align="center">–name:自定义容器名||-d:后台运行||image-name:指定镜像模板</td>
</tr>
<tr>
<td align="center">docker ps</td>
<td align="center">查看运行中的容器||-a可以查看所有容器</td>
</tr>
<tr>
<td align="center">docer stop container -name/container-id</td>
<td align="center">停止容器</td>
</tr>
<tr>
<td align="center">docer start container -name/container-id</td>
<td align="center">启动容器</td>
</tr>
<tr>
<td align="center">docker rm container-id</td>
<td align="center">删除容器</td>
</tr>
<tr>
<td align="center">-p 6379:6379</td>
<td align="center">主机端口映射到容器端口</td>
</tr>
<tr>
<td align="center">docker logs container-name/container-id</td>
<td align="center">查看容器日志</td>
</tr>
<tr>
<td align="center">docker exec -it 容器ID /bin/bash</td>
<td align="center">进入容器</td>
</tr>
<tr>
<td align="center">exit/Ctrl+P+Q</td>
<td align="center">退出容器</td>
</tr>
</tbody></table>
<h4 id="启动MySQL"><a href="#启动MySQL" class="headerlink" title="启动MySQL"></a>启动MySQL</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -p 3306:3306 --name mysql \</span></span><br><span class="line"> -v /mydata/mysql/conf:/etc/mysql \</span><br><span class="line"> -v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line"> -v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7</span><br><span class="line"> </span><br><span class="line"><span class="meta"> $</span><span class="bash"> docker run -p 3306:3306 --name mysql \</span></span><br><span class="line"> -v /mydata/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line"> -v /mydata/mysql/log:/var/log \</span><br><span class="line"> -v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line"> --privileged=true \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=root -d mysql:8.0 \</span><br><span class="line"> --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode-ci</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据挂载:docker rm 将容器删除那么数据就丢失了,将容器中的目录挂载到宿主机，以保证数据的安全</span></span><br></pre></td></tr></table></figure>

<p>说明:</p>
<p> -p 3306:3306    将容器的3306端口映射到主机的3306端口</p>
<p> -e MYSQL_ROOT_PASSWORD=密码        初始化root用户密码</p>
<p> -d 后台启动</p>
<p> –privileged=true：容器内的root拥有真正root权限，否则容器内root只是外部普通用户权限</p>
<p> -v /mydata/mysql/conf:/etc/mysql    将配置文件挂载到主机</p>
<p> -v /mydata/mysql/log:/var/log/mysql    将日志文件挂载到主机</p>
<p> -v /mydata/mysql/data:/var/lib/mysql    将配置文件挂载到主机</p>
<p>​    </p>
<h4 id="启动Redis"><a href="#启动Redis" class="headerlink" title="启动Redis"></a>启动Redis</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p /mydata/redis/conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch /mydata/redis/conf/redis.conf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run --name redis -p 6379:6379 \</span></span><br><span class="line">-v /mydata/redis/data:/data \</span><br><span class="line">-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d redis redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">为避免重启丢失数据</span></span><br><span class="line"><span class="meta">#</span><span class="bash">/mydata/redis/conf/redis.conf 添加 appendonly yes(启用AOF持久化) 新版本默认</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<h4 id="启动ElasticSearch"><a href="#启动ElasticSearch" class="headerlink" title="启动ElasticSearch"></a>启动ElasticSearch</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run --name kibana -e ELASTICSEA	RCH_HOSTS=http://172.24.0.1:9200 -p 5601:5601 -d kibana:7.6.2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run --name kibana -p 5601:5601 -v E:/mydata/kibana/config/:/usr/share/kibana/config -d kibana:7.6.2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run --name elasticsearch -p 9200:9200 -p 9300:9300 -e <span class="string">&quot;discovery.type=single-node&quot;</span> -e ES_JAVA_OPTS=<span class="string">&quot;-Xms64m -Xmx512m&quot;</span> -v E:/mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v E:/mydata/elasticsearch/data:/usr/share/elasticsearch/data -v E:/mydata/elasticsearch/plugings:/usr/share/elasticsearch/plugins -d elasticsearch:7.6.2</span></span><br></pre></td></tr></table></figure>

<h4 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">先创建空的把conf目录移出挂载</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -p 80:80 --name nginx -d nginx:latest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container cp nginx:/etc/nginx .</span></span><br><span class="line"><span class="meta">#</span><span class="bash">正式</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -p 80:80 --name nginx -v E:/mydata/nginx/html:/usr/share/nginx/html -v E:/mydata/nginx/logs:/var/<span class="built_in">log</span>/nginx -v E:/mydata/nginx/conf.d:/etc/nginx/conf.d -d nginx:latest</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建与部署</title>
    <url>/2020/11/08/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="Hexo博客搭建与部署"><a href="#Hexo博客搭建与部署" class="headerlink" title="Hexo博客搭建与部署"></a>Hexo博客搭建与部署</h2><h3 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <span class="exturl" data-url="aHR0cDovL2RhcmluZ2ZpcmViYWxsLm5ldC9wcm9qZWN0cy9tYXJrZG93bi8=">Markdown<i class="fa fa-external-link-alt"></i></span>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<a id="more"></a>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h4><ul>
<li><span class="exturl" data-url="aHR0cDovL25vZGVqcy5vcmcv">Node.js<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cDovL2dpdC1zY20uY29tLw==">Git<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h4 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure>

<p>安装好之后使用$ hexo -v可查看安装成功与否,具体查看<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuLw==">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install <span class="comment">#d安装依赖</span></span></span><br></pre></td></tr></table></figure>

<p>安装完成后博客文件放在source/_posts文件夹中</p>
<h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><p>hexo项目结构安装好后，_config.yml可配置相关内容,可以选择自己喜欢的主题，可到官网或者github下载<span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy8=">NexT主题官网文档<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h4><p>Hexo 提供了快速方便的一键部署功能</p>
<p>1.首先在github创建一个和你用户名相同的仓库，后面加上.github.io，也就是xxxx.github.io</p>
<p>2.安装 hexo-deployer-git</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-deployer-git --save</span></span><br></pre></td></tr></table></figure>

<p>3.修改配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/xxx/xxx.github.io.git #仓库地址</span><br><span class="line">  branch: master #分支名</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure>

<p>4.部署</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo clean</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo generate</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo deploy		  <span class="comment">#部署</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo server         <span class="comment">#运行本地服务</span></span></span><br></pre></td></tr></table></figure>

<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>hexo部署到github上面的只是生成的静态文件,当换一台电脑时就无法更新博客了,所以在仓库中创建一个hexo分支来保存hexo的环境文件</p>
<p>1.xxx.github.io.git创建一个分支hexo,将此分支设置为默认分支</p>
<p>2.创建一个空文件夹将xxx.github.io.git通过git克隆到本地,然后将.git文件移动到hexo init 的文件下,此时相当于将hexo 文件夹与github上的hexo分支关联起来</p>
<p>3.执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add -A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;environment&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin hexo</span></span><br></pre></td></tr></table></figure>

<p>将远程hexo分支中的静态文件替换为当前目录下的环境文件(因为.gitignore文件中忽略了静态文件,所以上传上去的只是环境文件,不会包含静态文件)</p>
<p>4.每次更新文章过后使用hexo命名更新文章,使用git命令更新环境文件,在换电脑之后只需要从git克隆下就能继续更新博客了</p>
<h4 id="部署到gitee"><a href="#部署到gitee" class="headerlink" title="部署到gitee"></a>部署到gitee</h4><p>部署到git之后会发现访问会很慢,有时候甚至直接无法访问,所以再到gitee再部署一个,因为再github已经部署过一次了,所以再gitee可以直接把github导过来</p>
<p>1.gitee再新建仓库的时候一个从github导入仓库的选项,可以直接从github将部署好的文件直接导过来</p>
<p>2.导入过来之后将仓库名改为与用户名相同</p>
<p>3.与github不同,gitee需要自己手动开启Pages服务,在仓库的服务选项选择Gitee Pages,选择部署分支mater,点击部署,成功后上面会显示已开启 Gitee Pages 服务，网站地址:<span class="exturl" data-url="aHR0cHM6Ly94eHguZ2l0LmlvLw==">https://xxx.git.io<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201108153519.png"></p>
<p>4.更新文章之后,想在gitee也同步更新,可以点击仓库名旁边的箭头,可直接从github同步到gitee</p>
<h3 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h3><p>Markdown文档中是能够存放图片路径显示图片的,上传到网络上之后可以使用图床实现,因为github访问困难,所以图床文件放在gitee</p>
<p>1.下载PicGo,安装gitee插件</p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201108153403.png"></p>
<p>2.在gitee创建库并设置Gitee插件,然后就能直接上传图片到gitee里面,使用的时候直接用图片的网络地址</p>
<p>3.gitee插件配置示例</p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210707.png"></p>
]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC并发编程</title>
    <url>/2022/05/08/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h1><ol>
<li><p>继承Thread类    重写run()方法    启动: <code>new MyThread().start()</code></p>
</li>
<li><p>实现Runnable接口    重写run()方法     启动: <code>new Thread(new MyThread()).start()</code></p>
</li>
<li><p>实现Callable接口     重写call()方法    启动: <code>new Thread( new FutureTask( new MyThread() ) )</code></p>
</li>
<li><p>使用线程池 new ThreadPoolExecutor() ( 主要使用 )</p>
<p> <strong>7大核心参数</strong></p>
<ul>
<li>corePoolSize:核心池大小</li>
<li>maximumPoolSize:最大线程数</li>
<li>keepAliveTime:线程没有任务时最多保持的时间</li>
<li>keepAliveTime:超时时间单位</li>
<li>BlockingQueue<Runnable>: 阻塞队列</li>
<li>ThreadFactory: 线程工厂,创建线程</li>
<li>RejectedExecutionHandler: 拒绝策略 4种</li>
</ul>
<p> <strong>具体使用</strong></p>
<ul>
<li><p>一池N线程: Executors.newFixedThreadPool()</p>
</li>
<li><p>一池一线程: Executors.newSingleThreadExecutor()</p>
</li>
<li><p>根据需求扩容: Executors.newCachedThreadPool()</p>
</li>
</ul>
<p> <strong>拒绝策略(超过最大线程和阻塞队列)：</strong></p>
<ul>
<li><p>(默认)ThreadPoolExecutor.AbortPolicy(): 直接抛出RejectedExecutionException异常阻止系统正常运行</p>
</li>
<li><p>ThreadPoolExecutor.CallerRunsPolicy(): “调用者运行“一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量.</p>
</li>
<li><p>ThreadPoolExecutor.DiscardOldestPolicy(): 抛弃队列中等待最久的任务，然后把当前任务加人队列中尝试再次提交当前任务。</p>
</li>
<li><p>ThreadPoolExecutor.DiscardPolicy(): 该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。</p>
</li>
</ul>
<p> <strong>自定义线程池:</strong> </p>
<p> ​    阿里巴巴开发手册强制线程池不允许使用Executors去创建</p>
<ul>
<li><p>FixedThreadPool 和 SingleThreadPool:</p>
<p>允许请求队列长度为Integer.MAX_VALUE,可能堆积大量的请求</p>
</li>
<li><p>CachedThreadPool和 ScheduledThreadPool</p>
<p>允许创建线程数量为Integer.MAX_VALUE,可能堆积大量的线程</p>
</li>
</ul>
</li>
</ol>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><ul>
<li><p>FutureTask缺点</p>
<ul>
<li>get()方法在Future计算完成之前会一直阻塞</li>
<li>轮询方式isDone(), 消耗cpu资源</li>
</ul>
</li>
<li><p>CompletableFuture优化</p>
<ul>
<li><p>CompletableFuture提供了一种观察者模式类似的机制，可以让任务执待完成后通知监听的一方。</p>
</li>
<li><p>CompletableFuture.runAsync(<Runnable>): 无返回值</p>
</li>
<li><p>CompletableFuture.supplyAsync(<Runnable>): 有返回值</p>
</li>
<li><p>whenComplete(): 完成后的感知</p>
</li>
<li><p>exceptionally():</p>
</li>
<li><p>handle(): 完成后的处理</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>thenCombie(): 组合两个future,获取两个future的返回结果，有返回值</p>
</li>
<li><p>thenAcceptBoth(): 组合两个future，获取两个future任务的返回结果，然后处理任务，没有返回值。</p>
</li>
<li><p>runAfterBoth(): 组合两个future，不获取future的结果，两个future处理完任务后，处理该任务。</p>
</li>
</ul>
<ul>
<li><p>applyIToEither:两个任务有一个执行完成，获取返回值，处理任务并有新的返回值。</p>
</li>
<li><p>acceptEither:两个任务有一个执行完成，获取返回值，处理任务，没有新的返回值。</p>
</li>
<li><p>runAfterEither:两个任务有一个执行完成，不获取future的结果，处理任务，也没有返回值。</p>
</li>
</ul>
<ul>
<li>allof(): 组合多任务</li>
</ul>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>Thread类中:</p>
<ul>
<li>start()∶启动当前线程;调用当前线程的run()</li>
</ul>
<ul>
<li>run()∶通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</li>
</ul>
<ul>
<li><p>yield()∶释放当前cpu的执行权,礼让线程，暂停线程 直接进入就绪状态 不是阻塞状态</p>
</li>
<li><p>join():在线程中调用线程b的join(),此时线程a就进入阻塞状态，直到线程a完全执行完以后，线程a结束阻塞状态。</p>
</li>
<li><p>sleep(long millitime):让当前线程睡眠指定的millitime毫秒, 当前线程是阻塞状态。</p>
</li>
<li><p>stop(): 已过时。当执行此方法时，强制结束当前线程。</p>
</li>
</ul>
<ul>
<li>setPriority(int p): 设置线程优先级</li>
<li>setDaemon(true): 把一个用户线程编程守护线程</li>
<li>getName()∶获取当前线程的名字</li>
<li>currentThread()∶静态方法，返回执行当前代码的线程</li>
<li>isAlive()∶判断当前线程是否存活</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li>新建: 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li>
<li>就绪: 处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源</li>
<li>运行: 当就绪的线程被调度并获得CPU资源时,便进入运行状态，run()方法定义了线程的操作和功能</li>
<li>阻塞: 在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU并临时中止自己的执行，进入阻塞状态</li>
<li>死亡: 线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205081748754.png" alt="image-20220508174831651"></p>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><ul>
<li>wait() || await(): 执行此方法,当前线程就会进入阻塞状态,并释放锁</li>
<li>notify() || singal(): 执行此方法,就会唤醒被wait()的一个线程.如果有多个,就唤醒优先级较高的那个</li>
<li>notifyAll() || singalAll(): 执行此方法,就会唤醒所有被wait()的线程</li>
</ul>
<p>说明:</p>
<ol>
<li>wait(),notify(),notifyAll()三个方法必须使用在同步代码块或同步方法中</li>
<li>wait(),notify(),notifyAll()三个方法的调用者必须是同步代码块或同步方法中的监视器</li>
</ol>
<p>虚假唤醒:</p>
<p>多个线程通信时, wait() 应该放在while循环里, 不然可能出现虚假唤醒(因为wait()在哪里睡哪里醒)</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>当执行monitor enterl时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。</p>
<p>在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。</p>
<p>当执行monitor exit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</p>
<table>
<thead>
<tr>
<th>ObjectMonitor.hpp关键属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>_owner</td>
<td>指向持有ObjectMonitor对象的线程</td>
</tr>
<tr>
<td>_WaitSet</td>
<td>存放处于wait状态的线程队列</td>
</tr>
<tr>
<td>_EntryList</td>
<td>存放处于等待锁block状态的线程队列</td>
</tr>
<tr>
<td>_recursions</td>
<td>锁的重入次数</td>
</tr>
<tr>
<td>_count</td>
<td>用来记录该线程获取锁的次数</td>
</tr>
</tbody></table>
<ul>
<li><p>公平锁和非公平锁</p>
<ul>
<li><p>非公平锁: 抢占式, 效率高, 能更充分的利用CPU的时间片，尽量减少CP0空闲状态时间。</p>
</li>
<li><p>公平锁: 非抢占式, 效率低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);<span class="comment">//默认false  读写锁:new ReentrantReadWriteLock</span></span><br><span class="line"><span class="keyword">try</span> &#123;		<span class="comment">//lock需要手动启动和结束</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    ....<span class="comment">//同步代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>可重入锁(递归锁)</p>
<p>指在<strong>同一个线程</strong>在外层方法获取锁的时候，再进入该线程的内层方法会<strong>自动获取锁</strong>(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。避免死锁</p>
<p>加锁和解锁次数要一致, 否则会导致第二个线程无法获取到锁, 一直在等待</p>
</li>
<li><p>死锁及排查</p>
<ol>
<li><code>jps -l </code>类似linux `ps -ef``</li>
<li><code>jstack [id]</code> jvm自带堆栈跟踪工具</li>
</ol>
</li>
<li><p>读锁(独占锁) / 写锁(共享锁)</p>
</li>
<li><p>自旋锁SpinLock</p>
</li>
</ul>
<h2 id="线程中断LockSupport"><a href="#线程中断LockSupport" class="headerlink" title="线程中断LockSupport"></a>线程中断LockSupport</h2><p><strong>中断机制</strong></p>
<ul>
<li>一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止，Thread.stop,Thread.suspend, Thread.resume都已经被废弃了。</li>
<li>在Java中没有办法立即停止一条线程，然而停止线程却尤为重要，如取消一个耗时操作因此，Java提供了一种用于停止线程的协商机制—中断，也即<strong>中断标识协商机制</strong>。</li>
<li>若要中断一个线程，你需要手动调用该线程的interrupt方法，该方法也仅仅是将线程对象的中断标识设成true;</li>
</ul>
<p><strong>中断三大方法</strong></p>
<ul>
<li>void interrupt() : 实例方法interrupt()仅仅是设置线程的中断状态为true，发起一个协商而不会立刻停止线程</li>
<li>static boolean interrupted() : 判断线程是否被中断并清除当前中断状态。</li>
<li>bloolean isInterrupted() : 判断当前线程是否被中断（通过检查中断标志位)</li>
</ul>
<p><strong>LockSupport</strong></p>
<ul>
<li>park(): permit许可证默认没有不能放行，所以一开始调park()方法当前线程就会阻塞，直到别的线程给当前线程的发放permit，park方法才会被唤醒。</li>
<li>unpark(): 调用unpark(thread)方法后，就会将thread线程的许可证permit发放，会自动唤醒park线程，即之前阻塞中的LockSupport park()方法会立即返回.</li>
</ul>
<h1 id="JMM与volatile"><a href="#JMM与volatile" class="headerlink" title="JMM与volatile"></a>JMM与volatile</h1><blockquote>
<p>JMM的关键技术点都是围绕多线程的<strong>原子性</strong>、<strong>可见性</strong>和<strong>有序性</strong>展开的</p>
<ol>
<li>通过JMM来实现线程和主内存之间的抽象关系。</li>
<li>屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。</li>
</ol>
</blockquote>
<ul>
<li>可见性</li>
<li>原子性</li>
<li>有序性 </li>
</ul>
<p><strong>happens-before</strong></p>
<ol>
<li>次序规则: 一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作;</li>
<li>锁定规则: 一个unLock操作先行发生于后面((这里的“后面”是指时间上的先后))对同一个锁的lock操作;</li>
<li>volatile变量规则: 对一个volatile变量的写操作先行发生于后面对这个变量的读操作，<strong>前面的写对后面的读是可见的</strong>，这里的“后面”同样是指时间上的先后。</li>
<li>传递规则: 如果操作A先行发生于操作B，而操作B又先行发生于操作c，则可以得出操作A先行发生于操作C;</li>
<li>线程启动规则(Thread Start Rule): Thread对象的start()方法先行发生于此线程的每一个动作</li>
<li>线程中断规则(Thread lnterruption Rule): 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生;</li>
<li>线程终止规则(Thread Termination Rule): 线程中的所有操作都先行发生于对此线程的终止检 测，我们可以通过isAlive()等手段检测线程是否已经终止执行。</li>
<li>对象终结规则(Finalizer Rule): 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始  </li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote>
<p>volatile关键字的作用主要有如下两个：</p>
<ol>
<li>线程的可见性：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</li>
<li> 顺序一致性：禁止指令重排序</li>
</ol>
</blockquote>
<ul>
<li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中。</li>
<li>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量</li>
</ul>
<h2 id="内存屏障–-保证可见性"><a href="#内存屏障–-保证可见性" class="headerlink" title="内存屏障–(保证可见性)"></a><strong>内存屏障–(保证可见性)</strong></h2><blockquote>
<p> 内存屏障（也称内存栅栏，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性(禁重排)，但volatile无法保证原子性。</p>
<ul>
<li>内存屏障之前的所有写操作都要回写到主内存</li>
<li>内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。</li>
<li>因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。</li>
<li>对一个volatile变量的写,先行发生于任意后续对这个volatile变量的读，也叫写后读。</li>
</ul>
</blockquote>
<p>粗分2种:</p>
<ul>
<li>读屏障(Load Barrier): 在读指令之前插入读屏障，让工作内存或CPU高速缓存当中的缓存数据失效，重新回到主内存中获取最新数据</li>
<li>写屏障(Store Barrier): 在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中</li>
</ul>
<p>细分4种(cpp方法)</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad</td>
<td>Load1; LoadLoad; Load2</td>
<td>保证load1的读取操作在load2及后续读取操作之前执行</td>
</tr>
<tr>
<td>StoreStore</td>
<td>Store1; StoreStore; Store2</td>
<td>在store2及其后的写操作执行前，保证store1的写操作已刷新到主内存</td>
</tr>
<tr>
<td>LoadStore</td>
<td>Load1; LoadStore; Store2</td>
<td>在stroe2及其后的写操作执行前，保证load1的读操作已读取结束</td>
</tr>
<tr>
<td>StoreLoad</td>
<td>Store1; StoreLoad; Load2</td>
<td>保证store1的写操作已刷新到主内存之后，load2及其后的读操作才能执行</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>在每个volatile 读操作的后面插入一个LoadLoad屏障</td>
<td>禁止处理器把上面的volatile读与下面的普通读重排序。</td>
</tr>
<tr>
<td>在每个volatile 读操作的后面插入一个LoadStore屏障</td>
<td>禁止处理器把上面的volatilei读与下面的普通写重排序。</td>
</tr>
</tbody></table>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221126115150351.png" alt="image-20221126115150351"></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>在每个volatile 写操作的前面插入一个 StoreStore屏障</td>
<td>可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中</td>
</tr>
<tr>
<td>在每个volatile 写操作的后面插入一个 StoreLoad 屏障</td>
<td>作用是避免volatile写与后面可能有的volatile读/写操作重排序</td>
</tr>
</tbody></table>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221126115451821.png" alt="image-20221126115451821"></p>
<h2 id="读写过程–-没有原子性"><a href="#读写过程–-没有原子性" class="headerlink" title="读写过程–(没有原子性)"></a>读写过程–(没有原子性)</h2><p>Java内存模型中定义的8种每个线程自己的工作内存与主物理内存之间的原子操作:</p>
<p>read(读取)→load(加载)→use(使用)→assign(购值)→store(存储)→write(写入)→lock(锁定)→unlock(解锁)</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221126154850903.png" alt="image-20221126154850903"></p>
<p>不具备原子性: 如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，</p>
<p>在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性: </p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
<p><strong>结论: volatile不适合参与到依赖到当前值计算的运算 如: i++</strong></p>
<h2 id="指令禁重排–-保证一致性"><a href="#指令禁重排–-保证一致性" class="headerlink" title="指令禁重排–(保证一致性)"></a>指令禁重排–(保证一致性)</h2><blockquote>
<p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序不存在数据依赖关系，可以重排序;</p>
<p>存在数据依赖关系，禁止重排序—–<strong>通过内存屏障实现</strong></p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221125153711494.png" alt="image-20221125153711494"></p>
</blockquote>
<h2 id="volatile使用场景"><a href="#volatile使用场景" class="headerlink" title="volatile使用场景"></a>volatile使用场景</h2><ul>
<li>单一赋值可以，but含复合运算赋值不可以(i++之类)</li>
<li>状态标志，判断业务是否结束</li>
<li>开销较低的读，写锁策略</li>
<li>DCL双端锁的发布</li>
</ul>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><blockquote>
<p>CAS的全称为Compare-And-Swap，它是一条CPU并发原语。</p>
<p>它包含三个操作数——内存位置、预期原值及更新值。</p>
<p>使用Atomicxxx(原子操作类)实现</p>
</blockquote>
<ul>
<li><p>执行CAS操作的时候，将内存位置的值与预期原值比较;</p>
<ul>
<li>如果相匹配，那么处理器会自动将该位置值更新为新值，</li>
<li>如果不匹配，处理器不做任何操作，多个线程同时执行CAS操作只有一个会成功。</li>
<li>当它重来重试的这种行为成为—-<strong>自旋</strong>! !</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221127093626568.png" alt="image-20221127093626568"></p>
</li>
<li><p>CAS是JDK提供的<strong>非阻塞原子性</strong>操作，它通过硬件保证了比较-更新的原子性。</p>
</li>
<li><p>CAS是一条CPU的原子指令(cmpxchg指令），不会造成所谓的数据不一致问题</p>
</li>
<li><p>执行cmpxchg指令的时候，会判断当前系统是否为多核系统，如果是就给<strong>总线加锁</strong>，只有一个线程会对总线加锁成功，加锁成功之后会执行cas操作</p>
</li>
<li><p>CAS的原子性实际上是CPU实现独占的，比起synchronized重量级锁，排他时间要短很多</p>
</li>
</ul>
<h2 id="UnSafe类"><a href="#UnSafe类" class="headerlink" title="UnSafe类"></a>UnSafe类</h2><ul>
<li>UnSage类是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问</li>
<li>Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。</li>
<li>Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存</li>
<li>Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务</li>
<li>变量value用volatile修饰，保证了多线程之间的内存可见性。</li>
</ul>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><blockquote>
<p>AtomicReference<Thread>实现</p>
</blockquote>
<ul>
<li>CAS是实现自旋锁的基础，自旋翻译就是循环，一般是用一个无限循环实现。</li>
<li>这样一来，一个无限循环中，执行一个CAS操作，<ul>
<li>当操作成功返回true 时，循环结束;</li>
<li>当返回false时，接着执行循环，继续尝试CAS操作，直到返回true。</li>
</ul>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>循环时间长，开销很大</li>
<li>ABA问题 —-AtomicStampedReference(V initialRef, int initialStamp)解决</li>
</ul>
<h2 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h2><ul>
<li><p>基本类型</p>
<ul>
<li>AtomicInteger</li>
<li>AtomicBoolean</li>
<li>AtomicLong</li>
</ul>
</li>
<li><p>数组类型</p>
<ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
</li>
<li><p>引用类型</p>
<ul>
<li>AtomicReference</li>
<li>AtomicStampedReference</li>
<li>AtomicMarkableReference</li>
</ul>
</li>
<li><p>对象的属性修改原子类</p>
<ul>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdater</li>
<li>AtomicReferenceFieldUpdater</li>
</ul>
</li>
<li><p>原子操作增强类—减少乐观锁重试次数</p>
<ul>
<li>DoubleAccumulator</li>
<li>DoubleAdder</li>
<li>LongAccumulator</li>
<li>LongAdder—-striped64实现</li>
</ul>
</li>
</ul>
<h2 id="Striped64"><a href="#Striped64" class="headerlink" title="Striped64"></a>Striped64</h2><blockquote>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221127175158949.png" alt="image-20221127175158949"></p>
</blockquote>
<ul>
<li>LongAdder的基本思路就是分散热点，将value值分散到一个Cell数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。</li>
<li>sum()会将所有Cell数组中的value和base累加作为返回值，核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去从而降级更新热点。</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221127175106184.png" alt="image-20221127175106184"></p>
<p><strong>具体实现</strong></p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221128095958945.png" alt="image-20221128095958945"></p>
<ol>
<li>如果Cells表为空，尝试用CAS更新base字段，成功则退出;</li>
<li>如果Cells表为空，CAS更新base字段失败，出现竞争，uncontended为true，调用longAccumulate;</li>
<li>如果Cells表非空，但当前线程映射的槽为空，uncontended为true，调用longAccumulate;</li>
<li>如果Cells表非空，且前线程映射的槽非空，CAS更新Cell的值，成功则返回，否则，说明槽位不够用, uncontended设为false，调用<strong>longAccumulate</strong>,</li>
</ol>
<p><strong>longAccumulate()</strong></p>
<blockquote>
<p>striped64中一些变量或者方法的定义:</p>
<ul>
<li>base: 类似于AtomicLong中全局的value值。在没有竞争情况下数据直接累加到base上，或者cells扩容时，也需要将数据写入到base上</li>
<li>collide: 表示扩容意向，false一定不会扩容，true可能会扩容。</li>
<li>cellsBusy: 初始化cells或者扩容cells需要获取锁，0:表示无锁状态 1:表示其他线程已经持有了锁<br>心</li>
<li>casCellsBusy(): 通过CAS操作修改cellsBusy的值，CAS成功代表获取锁，返回true</li>
<li>NCPU: 当前计算机CPU数量，Cell数组扩容时会使用到</li>
<li>getProbe(): 获取当前线程的hash值</li>
<li>advanceProbe(): 重置当前线程的hash值</li>
</ul>
</blockquote>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221128131235040.png" alt="image-20221128131235040"></p>
<ul>
<li><p>CASE1: Cell[ ] 数组已经初始化</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221128133205437.png" alt="image-20221128133205437"></p>
<p>​    <img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221128133709562.png" alt="image-20221128133709562">    </p>
</li>
<li><p>CASE2: Cell[ ] 数组未初始化(首次新建)</p>
</li>
<li><p>CASE3: Cell[ ] 数组正在初始化中</p>
</li>
</ul>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><blockquote>
<p>ThreadLocal提供线程局部变量。这些变量与正常的变量不同，因为每一个线程在访ThreadLocal实例的时候（通过其getaset方法）都有自己的、独立初始化的变量副本。</p>
<p>ThreadLocal实例通常是类中的私有静态字段，使用它的目的是希望将状态（例如，用户ID或事务ID）与线程关联起来。</p>
</blockquote>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221128174850836.png" alt="image-20221128174850836"></p>
<p>当为threadLocal变量赋值，实际上就是以当前threadLocal实例为key，值为value 的Entry往threadLocalMap中存放</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221128174757027.png" alt="image-20221128174757027"></p>
<p><span style="color:red">JVM内部维护了一个线程版的Map&lt;ThreadLocal,Value&gt;</span>(通过ThreadLocal对象的set方法，结果把ThreadLocal对象自己当做key,放进了ThreadLoalMap中),<span style="color:red">每个线程要用到这个T的时候，用当前的线程去Map里面获取</span>，通过这样让每个线程都拥有了自己独立的变量，人手一份，竞争条件被彻底消除，在并发模式下是绝对安全的变量。</p>
<p><strong>弱引用</strong></p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221129120358011.png" alt="image-20221129120358011"></p>
<p>ThreadLocal是一个壳子，真正的存储结构是ThreadLocal里有ThreadLocalMap这么个内部类，每个Thread对象维护着一个ThreadLocalMlap的引用，ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><ul>
<li>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的ralue，如果当前线程再迟迟不结束的话(比如正好用在线程池)，这些key为null的Entry的value就会一直存在一条强引用链</li>
<li>虽然弱引用，保证了key指向的ThreadLocal对象能被及时回收，但是v指向的value对象是需要ThreadLocalMap调用get、setlt发现ke y’s u时t才会去回收整个entry、value，因此弱引用不能100%保证内存不泄露。我们要在不使用某个ThreadLocal对象后，手动调用remove()方法来删除它</li>
<li>set、 get方法会去检查所有键为null的Entry对象设置、获取方法会去检查所有键为空的条目对象,并调用expungestaleEntry清除value</li>
</ul>
<h1 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h1><blockquote>
<p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分:对象头(Header)、实例数据（ Instance Data）和对齐填充（Padding) 。</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221129135628729.png" alt="image-20221129135628729"></p>
</blockquote>
<h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221129140750165.png" alt="image-20221129140750165"></p>
<p><strong>对象标记 Mark Word</strong></p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221129142524944.png" alt="image"></p>
<p><strong>类元信息 (类型指针)</strong></p>
<h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>保证8个字节的倍数</p>
<h1 id="Synchronized与锁升级"><a href="#Synchronized与锁升级" class="headerlink" title="Synchronized与锁升级"></a>Synchronized与锁升级</h1><blockquote>
<p><strong>Monitor与java对象以及线程关联</strong></p>
<ol>
<li>如果一个java对象被某个线程锁住，则该java对象的Mark Word字段中LockWord指向monitor的起始地址</li>
<li>Monitor的Owner字段会存放拥有相关联对象锁的线程id</li>
</ol>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221129150316241.png" alt="imagine"></p>
</blockquote>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/2575225-20220426174452302-1618302519.png" alt="img"></p>
<ul>
<li>偏向锁: MarkWord存储的是偏向的线程ID;</li>
<li>轻量锁: MarkWord存储的是指向线程栈中Lock Record的指针;</li>
<li>重量锁: MarkWord存储的是指向堆中的monitor对象的指针;</li>
</ul>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗、和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争,会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞,提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程,使用自旋会消耗CPU</td>
<td>追求响应时间<br/>同步块执行速度非常快追求吞吐量</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋,不会消耗CPU</td>
<td>线程阻塞,响应时间缓慢</td>
<td>同步块执行速度较长</td>
</tr>
</tbody></table>
<h2 id="偏向锁-单线程竞争"><a href="#偏向锁-单线程竞争" class="headerlink" title="偏向锁: 单线程竞争"></a>偏向锁: 单线程竞争</h2><blockquote>
<p>偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。</p>
<p>也即偏向锁在资源没有竞争情况下消除了同步语句，懒的连CAS操作都不做了，直接提高程序性能</p>
</blockquote>
<ul>
<li>当线程A第一次竞争到锁时，通过操作修改Mark Word中的偏向线程ID、偏向模式。如果不存在其他线程竞争，那么持有偏向锁的线程将永远不需要进行同步。</li>
<li>当一段同步代码一直被同一个线程多次访问，由于只有一个线程那么该线程在后续访问时便会自动获得锁</li>
</ul>
<p><strong>使用</strong></p>
<p>偏向锁1.6后默认开启, 4秒延迟, 关闭后直接进入轻量级锁</p>
<p><strong>偏向锁的撤销</strong></p>
<ul>
<li>偏向锁使用一种等到竞争出现才释放锁的机制，只有当其他线程竞争锁时，持有偏向锁的原来线程才会被撤销。</li>
<li>撤销需要等待全局安全点(该时间点上没有字节码正在执行)，同时检查持有偏向锁的线程是否还在执行</li>
</ul>
<p><strong>升级</strong></p>
<ul>
<li>第一个线程正在执行synchronized方法(处于同步块)，它还没有执行完，其它线程来抢夺，该偏向锁会被取消掉并出现锁升级。此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁.</li>
<li>第一个线程执行完成synchronized方法(退出同步块)，则将对象头设置成无锁状态并撤销偏向锁，重新偏向。</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221130145126162.png" alt="image-20221130145126162"></p>
<h2 id="轻量级锁-多线程竞争"><a href="#轻量级锁-多线程竞争" class="headerlink" title="轻量级锁: 多线程竞争"></a>轻量级锁: 多线程竞争</h2><blockquote>
<p>任意时刻最多只有一个线程竞争，即不存在锁竞争太过激烈的情况，也就没有线程阻塞。</p>
</blockquote>
<p><strong>轻量级锁的加锁</strong></p>
<ul>
<li>JVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，官方称为Displaced Mark Word。</li>
<li>若一个线程获得锁时发现是轻量级锁，会把锁的MarkWord复制到自己的Displaced Mark Word里面。然后线程尝试用CAS将锁的MarkWord替换为指向锁记录的指针。<ul>
<li>如果成功，当前线程获得锁，</li>
<li>如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。</li>
</ul>
</li>
<li>自旋CAS:不断尝试去获取锁，能不升级就不往上捅，尽量不要阻塞</li>
</ul>
<p><strong>轻量级锁的释放</strong></p>
<ul>
<li>在释放锁时，当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。<ul>
<li>如果没有发生竞争，那么这个复制的操作会成功。</li>
<li>如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻寒的线程。</li>
</ul>
</li>
</ul>
<p><strong>锁升级</strong></p>
<p>自旋达到一定次数和程度: </p>
<ul>
<li>java6之前默认自旋10次或者自旋线程数超过cpu核数一半  -XX: PreBlockSpin= 10修改</li>
<li>java6之后自适应</li>
</ul>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><blockquote>
<p>Java中synchronized的重量级锁，是基于进入和退出Monitor对象实现的。在编译时会将同步块的开始位置插入monitor enter指令，在结束位置插入monitor exit指令。</p>
<p>当线程执行到monitor enter指令时，会尝试获取对象所对应的Monitor所有权，如果获取到了，即获取到了锁，会在Monitor的owner中存放当前线程的id，这样它将处于锁定状态，除非退出同步块，否则其他线程无法获取到这个Monitor。</p>
</blockquote>
<p>锁升级为轻量级或重量级锁后，Mark Word中保存的分别是线程栈帧里的锁记录指针和重量级锁指针，已经没有位置再保存哈希码,GC年龄</p>
<p><strong>当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了, 而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时, 它的偏向状态会被立即撤销, 并且锁会膨胀为重量级锁。</strong></p>
<ul>
<li>在无锁状态下，Mark Word中可以存储对象的identity hash code值。当对象的hashCode()方法第一次被调用时，JVM会生成对应的identity hash code值并将该值存储到Mark Word中。</li>
<li>对于偏向锁，在线程获取偏向锁时，会用Thread lD和epoch值覆盖identity hash code所在的位置。**( 已经计算过hash code升级到轻量级, 过程中需要计算, 升级到重量级再计算)** </li>
<li>升级为轻量级锁时，JVM会在当前线程的栈帧中创建一个锁记录(Lock Record)空间，用于存储锁对象的Mark Word拷贝，该拷贝中可以包含identity hash code，所以轻量级锁可以和identity hash code共存，哈希码和GC年龄自然保存在此，释放锁后会将这些信息写回到对象头。</li>
<li>升级为重量级锁后，Mark Word保存的重量级锁指针，代表重量级锁的ObjectMonitor类里有字段记录非加锁状态下的Mark.Nord，锁释放后也会将信息写回到对象头。</li>
</ul>
<h2 id="JIT编译器对锁的优化"><a href="#JIT编译器对锁的优化" class="headerlink" title="JIT编译器对锁的优化"></a>JIT编译器对锁的优化</h2><blockquote>
<p>Just In Time Compiler，一般翻译为即时编译器</p>
</blockquote>
<p>锁消除</p>
<p>锁粗化</p>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><blockquote>
<p> AbstractQueuedSynchronizer( 抽象的队列同步器 )简称为AQS</p>
<p>是用来实现锁或者其它同步器组件的公共基础部分的抽象实现，是重量级基础框架及整个JUC体系的基石，主要用于解决锁分配给”谁”的问题</p>
<p>整体就是一个抽象的FIFO队列来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态</p>
</blockquote>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221201134323004.png" alt="image-20221201134323004"></p>
<ul>
<li><strong>AQS中的队列是CLH变体的虚拟双向队列(FIFO)</strong>         state变量+CLH      CLH: Craig、Landin and Hagersten队列，是个单向链表，</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221201135403934.png" alt="image-20221201135403934"></p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221201155452019.png" alt="image-20221201155452019"></p>
<h2 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h2><ul>
<li><p>公平锁:公平锁讲究先来先到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入等待队列中;</p>
</li>
<li><p>非公平锁:不管是否有等待队列，如果可以获取锁，则立刻占有锁对象。也就是说队列的第一个排队线程苏醒后，不一定就是排头的这个线程获得锁，它还是需要参加竞争锁（存在线程竞争的情况下)，后来的线程可能不讲武德插队夺锁了。</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221201154347404.png" alt="image-20221201154347404"></p>
</li>
</ul>
<p>整个 ReentrantLock 的加锁过程,可以分为三个阶段:</p>
<ol>
<li>尝试加锁;</li>
<li>加锁失败,线程入队列;</li>
<li>线程入队列后,进入阻塞状态。</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWFyNHkxeDcyNz9wPTE1MyZhbXA7dmRfc291cmNlPTY0YjJhZmIzZGZhNzhiMDk0MzUwZmVkODQyZmIxMDI1">AQS流程图详解<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<h2 id="JUC辅助类"><a href="#JUC辅助类" class="headerlink" title="JUC辅助类"></a>JUC辅助类</h2><ul>
<li><p>CountDownLatch (减少计数) : 不减少到零不执行</p>
</li>
<li><p>CyclicBarrier (循环栅栏): 不增加到指定不停止</p>
</li>
<li><p>Semaphore (信号灯)  : 设置许可位, 获取许可位才能运行, 释放后可被其他线程抢占</p>
</li>
<li><p>BlockingQueue 阻塞队列：　</p>
<ul>
<li>当队列是空的，从队列中获取元素的操作将会被阻塞</li>
<li>当队列是满的，从队列中添加元素的操作将会被阻塞</li>
</ul>
</li>
</ul>
<h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><blockquote>
<p>ReentrantReadWriteLock</p>
<p>读写锁定义为:一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。</p>
</blockquote>
<h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><ol>
<li>如果同一个线程持有了写锁，在没有释放写锁的情况下，它还可以继续获得读锁。这就是写锁的降级，降级成为了读锁。</li>
<li>规则惯例，先获取写锁，然后获取读锁，再释放写锁的次序。</li>
<li>如果释放了写锁，那么就完全转换为读锁。</li>
</ol>
<p>锁降级遵循: 获取写锁→再获取读锁→再释放写锁的次序，写锁能够降级成为读锁。</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221202170935506.png" alt="image-20221202170935506"></p>
<h2 id="锁饥饿"><a href="#锁饥饿" class="headerlink" title="锁饥饿"></a>锁饥饿</h2><blockquote>
<p>ReentrantReadWriteLock实现了读写分离，但是一旦读操作比较多的时候，想要获取写锁就变得比较困难了，因为当前有可能会一直存在读锁，而无法获得写锁</p>
</blockquote>
<p>解决:　</p>
<ul>
<li>使用“公平”策略可以一定程度上缓解这个问题, 但是“公平”策略是以牺牲系统吞吐量为代价的</li>
<li>StampedLock类的乐观读锁<ul>
<li>StampedLock采取乐观获取锁后，其他线程尝试获取写锁时不会被阻塞，在获取乐观读锁后，还需要对结果进行校验。</li>
</ul>
</li>
</ul>
<p><strong>StampedLock</strong></p>
<ul>
<li>所有获取锁的方法，都返回一个邮戳(Stamp), stamp为零表示获取失败，其余都表示成功;</li>
<li>所有释放锁的方法，都需要一个邮戳〈Stamp）,这个Stamp必须是和成功获取锁时得到的Stamp一致;</li>
<li>StampedLock是不可重入的，危险 (如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁)</li>
<li>StampedLock有三种访问模式<ul>
<li>Reading（读模式悲观）:功能和ReentrantReadWriteLock的读锁类似</li>
<li>Writing (写模式）:功能和ReentrantRedWriteLock的写锁类似</li>
<li>Optimistic readina （乐观读模式):无锁机制，类似于数据库中的乐观锁，支持读写并发，很乐观认乎读取时没人修改，假如被修改再实现升级为悲观读模式</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库</title>
    <url>/2021/07/08/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h3 id="Mysql架构"><a href="#Mysql架构" class="headerlink" title="Mysql架构"></a>Mysql架构</h3><h4 id="数据存储目录"><a href="#数据存储目录" class="headerlink" title="数据存储目录"></a>数据存储目录</h4><p>/var/lib/mysql目录下</p>
<ul>
<li>InnoDB:     8.0会产生1个xxx.idb     5.7会产生2个文件xxx.frm(表结构) xxx.idb    (独立表空间模式存储在ibdata1中)</li>
<li>MyISAM:    3个文件     1.5.7中:xxx.frm,8.0中xxx.sdi     2.xxx.MYD(数据信息)     4.xxx.MYI(索引信息)</li>
</ul>
<a id="more"></a>

<h4 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h4><p>MySQL是典型的c/s架构，即 Client/Server架构，服务器端程序使用的mysqld。</p>
<p><img src="https://s2.loli.net/2022/04/10/w3Rz4dstWVSqkvm.png"></p>
<ul>
<li>连接层: 系统（客户端）访问MySQL服务器前，做的第一件事就是建立TCP连接。<br>经过三次握手建立连接成功后，MySQL服务器对TCP传输过来的账号密码做身份认证、权限获取。</li>
<li>服务层: 第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</li>
<li>引擎层</li>
</ul>
<h5 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h5><p><img src="https://s2.loli.net/2022/04/10/Ep3GgOoaUed8zJX.png">Oracle提出了共享池的概念,通过共享池来判断是软解析,还是硬解析</p>
<h5 id="数据库缓冲池"><a href="#数据库缓冲池" class="headerlink" title="数据库缓冲池"></a>数据库缓冲池</h5><p>InnoDB存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面。而磁盘I/o需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请<em>占用内存来作为数据缓冲池</em>，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 <em>Buffer Pool</em>之后才可以访问。</p>
<p><img src="https://s2.loli.net/2022/04/11/umTojzQqXcJ1OWA.png"></p>
<h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><h5 id="InnoDB-具备外键支持功能的事务存储引擎"><a href="#InnoDB-具备外键支持功能的事务存储引擎" class="headerlink" title="InnoDB:具备外键支持功能的事务存储引擎"></a><strong>InnoDB:具备外键支持功能的事务存储引擎</strong></h5><ul>
<li>InnoDB是MysQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</li>
<li>更新、删除操作，应优先选择lnnoDB存储引擎。</li>
<li>对比MylSAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保存数据和索引。</li>
<li>MyISAM只缓存索引，不缓存真实数据;InnoDB不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响。</li>
</ul>
<h5 id="MyISAM-非事务处理存储引擎"><a href="#MyISAM-非事务处理存储引擎" class="headerlink" title="MyISAM:非事务处理存储引擎"></a><strong>MyISAM:非事务处理存储引擎</strong></h5><ul>
<li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MylSAM不支持事务、行级锁、外键，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</li>
<li>优势是访问的速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li>
</ul>
<h5 id="Archive-用于数据存档"><a href="#Archive-用于数据存档" class="headerlink" title="Archive:用于数据存档"></a>Archive:用于数据存档</h5><ul>
<li>archive是归档的意思，仅仅支持插入和查询两种功能（行被插入后不能再修改)。</li>
<li>拥有很好的压缩机制，使用zlib压缩库，在记录请求的时候实时的进行压缩，经常被用来作为仓库使用。</li>
<li>根据英文的测试结论来看，同样数据量下，<code>Archive表比MyISAM表要小大约75%</code>，比支持事务处理的InnoDB表小大约83%。</li>
</ul>
<h5 id="Blackhole-丢弃写操作-读操作会返回空内容"><a href="#Blackhole-丢弃写操作-读操作会返回空内容" class="headerlink" title="Blackhole:丢弃写操作,读操作会返回空内容"></a>Blackhole:丢弃写操作,读操作会返回空内容</h5><ul>
<li>Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。</li>
<li>但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。|</li>
</ul>
<h5 id="CVS-存储数据时-逗号分隔各个数据"><a href="#CVS-存储数据时-逗号分隔各个数据" class="headerlink" title="CVS:存储数据时,逗号分隔各个数据"></a>CVS:存储数据时,逗号分隔各个数据</h5><ul>
<li>CSV引擎可以将普通的CSV文件作为My SQL的表来处理，但不支持索引</li>
<li>CSV引擎可以作为一种数据交换的机制，非常有用。</li>
<li>对于数据的快速导入、导出是有明显优势的。</li>
</ul>
<h5 id="Memory-数据置于内存的表"><a href="#Memory-数据置于内存的表" class="headerlink" title="Memory:数据置于内存的表"></a>Memory:数据置于内存的表</h5><ul>
<li>Memory采用的逻辑介质是内存，响应速度很快，但是当mysqld守护进程崩溃的时候数据会丢失。另外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用(长度不固定的)。</li>
</ul>
<h5 id="Federated-访问远程表"><a href="#Federated-访问远程表" class="headerlink" title="Federated:访问远程表"></a>Federated:访问远程表</h5><ul>
<li>Federated引擎是访问其他MysQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</li>
</ul>
<h5 id="Merge-管理各个MyISAM表构成的表集合"><a href="#Merge-管理各个MyISAM表构成的表集合" class="headerlink" title="Merge:管理各个MyISAM表构成的表集合"></a>Merge:管理各个MyISAM表构成的表集合</h5><h5 id="NDB-MySQL集群专用存储引擎"><a href="#NDB-MySQL集群专用存储引擎" class="headerlink" title="NDB:MySQL集群专用存储引擎"></a>NDB:MySQL集群专用存储引擎</h5><ul>
<li>也叫做NDB Cluster存储引擎，主要用于MysQL Cluster分布式集群环境，类似于Oracle的RAC集群。</li>
</ul>
<h3 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="InnoDB数据存储结构"></a>InnoDB数据存储结构</h3><h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><ol>
<li>lnnoDB将数据划分为若干个面, lnnoDB中页的大小默认为16KB。</li>
<li>以页作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，**在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页(Page)**，数据库V/O操作的最小单位是页。一个页中可以存储多个记录</li>
</ol>
<h4 id="页的上层结构"><a href="#页的上层结构" class="headerlink" title="页的上层结构"></a>页的上层结构</h4><p>在数据库中，还存在着区(Extent)、段(Segment)和表空间（Tablespace)的概念。行、页、区、段、表空间的关系如下图所示:</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202204171515764.png"></p>
<ul>
<li><p>碎片区: 碎片区中的页不属于同一段，碎片区直属于<strong>表空间</strong></p>
</li>
<li><p>区(Extent)是比页大一级的存储结构，**<em>存放连续的页，在InnoDB存储引擎中**</em>，一个区会分配64个连续的页。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB= 1MB。</p>
</li>
<li><p>段（Segment)由一个或多个区组成，**<em>区分叶子节点和非叶子节点的区的集合**</em>，区在文件系统是一个连续分配的空间(在InnoDB中是连续的64个页)，不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p>
</li>
<li><p>表空间（Tablespace)是一个逻辑容器(<a href="####%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%9B%AE%E5%BD%95">idb文件</a>)，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。</p>
</li>
<li><p>系统表空间: 与独立表空间类似，MySQL进程只有一个系统表空间，会额外记录系统信息</p>
</li>
</ul>
<p><strong>为某个段分配存储空间的策略是这样的:</strong></p>
<ol>
<li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li>
<li>当某个段已经占用了32个碎片区页面之后，就会申请以完整的区为单位来分配存储空间。</li>
</ol>
<h4 id="页的内部结构"><a href="#页的内部结构" class="headerlink" title="页的内部结构"></a>页的内部结构</h4><ol>
<li><p>页如果按类型划分的话，常见的有<code>数据页（保存B+树节点)</code>、系统页、Undo 页和事务数据页等。数据页是我们最常使用的页。</p>
</li>
<li><p>数据页的16KB大小的存储空间被划分为七个部分，分别是文件头(File Header)、页头(Page Header)、最大最小记录(Infimum+supremum)、用户记录(User Records)、空闲空间(Free Space)、页目录(PageDirectory)和文件尾(File Tailer) 。</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202204171544472.png"></p>
</li>
</ol>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202204171545764.png"></p>
<h4 id="InnoDB行格式-记录格式"><a href="#InnoDB行格式-记录格式" class="headerlink" title="InnoDB行格式(记录格式)"></a>InnoDB行格式(记录格式)</h4><h5 id="COMPACT行格式"><a href="#COMPACT行格式" class="headerlink" title="COMPACT行格式"></a>COMPACT行格式</h5><p>在MySQL 5.1版本中，默认设置为Compact行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202204172046388.png" alt="image-20220417204627307"></p>
<h5 id="Dynamic和Compressed行格式"><a href="#Dynamic和Compressed行格式" class="headerlink" title="Dynamic和Compressed行格式"></a>Dynamic和Compressed行格式</h5><p> 行溢出</p>
<h5 id="Redundant行格式"><a href="#Redundant行格式" class="headerlink" title="Redundant行格式"></a>Redundant行格式</h5><p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202204201714032.png" alt="image-20220420171406913"></p>
<h3 id="重点-索引及调优"><a href="#重点-索引及调优" class="headerlink" title="(重点)索引及调优"></a>(重点)索引及调优</h3><h4 id="索引的创建原则"><a href="#索引的创建原则" class="headerlink" title="索引的创建原则"></a>索引的创建原则</h4><p><strong>适合创建索引的情况:</strong></p>
<ol>
<li>频繁作为WHERE查询条件的字段</li>
<li>经常GROUP BY 和 ORDER BY 的列</li>
<li>UPDATE , DELETE  的 WHERE 条件列</li>
<li>DISTINCT字段需要创建索引</li>
<li>区分度高(散列性高)的列</li>
</ol>
<p><strong>不适合创建索引的情况:</strong></p>
<ol>
<li>WHERE使用不到的列</li>
<li>有大量重复数据的列</li>
<li>避免对经常更新的列</li>
<li>不建议用无序的列</li>
<li>不要定义冗余重复的索引</li>
<li>建议单张表不要超过6个索引</li>
</ol>
<h4 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="性能分析工具"></a>性能分析工具</h4><h5 id="查看系统性能参数"><a href="#查看系统性能参数" class="headerlink" title="查看系统性能参数:"></a><strong>查看系统性能参数:</strong></h5><table>
<thead>
<tr>
<th>SHOW [GLOBAL|SESSION] STATUS LIKE ‘参数’</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Connection</td>
<td>连接MySQL服务器的次数</td>
</tr>
<tr>
<td>Uptime</td>
<td>MySQL服务器上线时间</td>
</tr>
<tr>
<td>Slow_queries</td>
<td>慢查询的次数</td>
</tr>
<tr>
<td>Innodb_rows_read|inserted|updated|deleted</td>
<td>执行xx操作的行数</td>
</tr>
<tr>
<td>Com_select|insert|update|delete</td>
<td>xx操作的次数</td>
</tr>
<tr>
<td>Last_query_cost</td>
<td>SQL成本查询</td>
</tr>
</tbody></table>
<h5 id="Profile"><a href="#Profile" class="headerlink" title="Profile:"></a><strong>Profile:</strong></h5><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>select @@profiling</td>
<td>查看是否开启</td>
</tr>
<tr>
<td>set profiling =1</td>
<td>开启</td>
</tr>
<tr>
<td>show profiles/profile [for query id]</td>
<td>查看SQL执行时间</td>
</tr>
</tbody></table>
<h5 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN:"></a><strong>EXPLAIN:</strong></h5><p><code>mysql&gt; show variables like &#39;%slow_query_log&#39;</code>开启慢查询日志</p>
<p>**type: **system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range&gt; index &gt; ALL</p>
<p>SQL性能优化的目标: 至少要达到range级别，要求是ref级别，最好是consts级别。(阿里巴巴开发手册要求)</p>
<h5 id="Trace分析优化器执行计划"><a href="#Trace分析优化器执行计划" class="headerlink" title="Trace分析优化器执行计划:"></a>Trace分析优化器执行计划:</h5><p>默认关闭    开启:<code>SET optimizer_trace= &quot;enabled=on &quot; , end_markers_in_json=on ; </code>  </p>
<p>设置最大能使用内存<code>set optimizer_trace_max_mem_size=100000;</code></p>
<p>查看<code>select * from information_schema . optimizer_trace\G</code></p>
<h5 id="MySQL监控分析视图-sys-schema"><a href="#MySQL监控分析视图-sys-schema" class="headerlink" title="MySQL监控分析视图-sys schema"></a>MySQL监控分析视图-sys schema</h5><h4 id="索引优化与查询优化"><a href="#索引优化与查询优化" class="headerlink" title="索引优化与查询优化"></a>索引优化与查询优化</h4><ul>
<li>索引失效、没有充分利用到索引—―索引建立</li>
<li>关联查询太多JOIN(设计缺陷或不得已的需求)——sQL优化</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）――调整my.cnf</li>
<li>数据过多——分库分表</li>
</ul>
<p>SQL查询优化的技术有很多，但是大方向上完全可以分成<strong>物理查询优化</strong>和<strong>逻辑查询优化</strong>两大块。</p>
<ul>
<li>物理查询优化是通过索引和才连接方式等技术来进行优化，这里重点需要掌握索引的使用。</li>
<li>逻辑查询优化就是通过SQL等价变换提升查询效率，直白一点就是说，换一种查询写法执行效率可能更高。</li>
</ul>
<h5 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h5><h5 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h5><h5 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h5><ol>
<li><p>SQL中，可以在WHERE子句和ORDER BY子句中使用索引，目的是在WHERE子句中避免全表扫描</p>
</li>
<li><p>尽量使用Index完成ORDER BY排序。如果WHERE和ORDER BY后面是相同的列就使用单索引列;如果不同就使用联合索引。</p>
</li>
<li><p>无法使用Index时，需要对FileSort方式进行调优。</p>
<p>**FileSort排序:**双路排序和单路排序</p>
<ol>
<li>提高sort_buffer_size</li>
<li>提高max_length_for_sort_data : 返回列的总长度大于此参数, 使用双路算法, 否则单路</li>
<li>Order by 时 select *是大忌,最好只查询需要的字段</li>
</ol>
</li>
</ol>
<h5 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h5><h5 id="索引条件下推ICP"><a href="#索引条件下推ICP" class="headerlink" title="索引条件下推ICP"></a>索引条件下推ICP</h5><p>默认开启</p>
<p>回表之前使用失效索引对数据进行过滤</p>
<h5 id="其他优化情况"><a href="#其他优化情况" class="headerlink" title="其他优化情况"></a>其他优化情况</h5><ol>
<li><p>EXISTS 和 IN:小表驱动大表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> cc <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B) 	<span class="comment">#A&gt;B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> cc <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B <span class="keyword">WHERE</span> B.cc=A.cc)	<span class="comment">#B&gt;A</span></span><br></pre></td></tr></table></figure>

<p>当A小于B时，用EXISTS。因为EXISTS的实现，相当于外表循环，实现的逻辑类似于:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> A</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> B</span><br><span class="line">    	<span class="keyword">if</span> j.cc == i.cc then...</span><br></pre></td></tr></table></figure>

<p>当B小于A时用IN，因为实现的逻辑类似于:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> B</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> A</span><br><span class="line">    	<span class="keyword">if</span> j.cc == i.cc then...</span><br></pre></td></tr></table></figure>
</li>
<li><p>COUNT(*)与COUNT(具体字段)效率:</p>
<p>InnoDB中尽量使用二级所用。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，二级索引只会加载部分字段。空间占用更小。对于COUNT(*)和COUNT(1)来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。</p>
</li>
<li><p>LIMIT 1对优化影响:</p>
<ul>
<li>针对的是会扫描全表的SQL语句，加上LIMIT 1的时候，当找到一条结果的时候就不会继续扫描了，会加快查询速度。</li>
<li>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描，就不需要加上LIMIT1了。</li>
</ul>
</li>
<li><p>多使用COMMIT</p>
<p>只要有可能，在程序中尽量多使用COMMIT，这样程序的性能得到提高，需求也会因为COMMIT所释放的资源而减少。</p>
<p>COMMIT所释放的资源:</p>
<ul>
<li>回滚段上用于恢复数据的信息</li>
<li>被程序语句获得的锁</li>
<li> redo / undo log buffer中的空间</li>
<li>管理上述3种资源中的内部花费</li>
</ul>
</li>
</ol>
<h4 id="数据库的设计规范"><a href="#数据库的设计规范" class="headerlink" title="数据库的设计规范"></a>数据库的设计规范</h4><h5 id="泛式"><a href="#泛式" class="headerlink" title="泛式"></a>泛式</h5><ul>
<li>超键:能唯─标识元组的属性集叫做超键。</li>
<li>候选键:如果超键不包括多余的属性，那么这个超键就是候选键。·主键:用户可以从候选键中选择一个作为主键。</li>
<li>外键∶如果数据表R1中的某属性集不是R1的主键，而是另一个数据表R2的主键，那么这个属性集就是数据表R1的外键。</li>
<li>主属性:包含在任一候选键中的属性称为主属性。</li>
<li>非主属性:与主属性相对，指的是不包含在任何一个候选键中的属性。</li>
</ul>
<h6 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h6><p>第一范式主要是确保数据表中每个字段的值必须具有<strong>原子性</strong>，也就是说数据表中每个字段的值为不可再次拆分的最小数据单元。</p>
<h6 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h6><p>第一范式的基础上，还要满足<strong>数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完论依赖主键，不能只依赖主键的一部分。</strong>如果知道主键的所有属性的值，就可以检索到任何元组(行)的任何属性的任何值。(要求中的主键，其实可以拓展替换为候选键)。</p>
<h6 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h6><p>在第二范式的基础上，确保数据表中的每一个非主键字段都<strong>和主键字段直接相关</strong>，也就是说，要求数据表中的所有非主键字段不能依赖于其他非主键字段。通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。</p>
<h5 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化"></a>反范式化</h5><p>增加冗余信息提高查询效率:</p>
<ol>
<li>这个冗余字段不需要经常进行修改</li>
<li>这个冗余字段查询的时候不可或缺。(eg:历史快照)</li>
</ol>
<h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><h5 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h5><ul>
<li>活动的(active)</li>
<li>部分提交的(partially committed)</li>
<li>失败的(failed)</li>
<li>终止的(aborted)</li>
<li>提交的(committed)</li>
</ul>
<h5 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h5><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>START TRASNSACTION | BEGIN</td>
<td>开启一个事务</td>
</tr>
<tr>
<td>ROLLBACK| ROLLBACK TO [SAVEPOINT]</td>
<td>回滚事务</td>
</tr>
<tr>
<td>COMMIT</td>
<td>提交事务</td>
</tr>
<tr>
<td>SAVEPOINT 保存点名称</td>
<td>创建保存点</td>
</tr>
<tr>
<td>RELEASE SAVEPOINT xxx</td>
<td>删除保存点</td>
</tr>
</tbody></table>
<h5 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h5><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><blockquote>
<p>对于同时运行的多个事务，当访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题</p>
<ul>
<li><p>脏读：T1修改了T2修改但未提交的数据，若 T2回滚，T1读取的内容是无效的</p>
</li>
<li><p>脏读：T1读取了T2修改但未提交的数据，若T2回滚，T1读取的内容是无效的</p>
</li>
<li><p>不可重复读：T1读取了之后T2更新了数据，T1再读取数据不同</p>
</li>
<li><p>幻读：T1读取了之后T2插入了数据，T1再读取数据不同</p>
</li>
</ul>
</blockquote>
<h5 id="MySQL的隔离级别"><a href="#MySQL的隔离级别" class="headerlink" title="MySQL的隔离级别"></a>MySQL的隔离级别</h5><p>默认：REPEATABLE READ(可重复读)</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202204281752260.png" alt="img"></p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202204281753769.png" alt="image-20220428175322713"></p>
<table>
<thead>
<tr>
<th>作用</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>查看当前隔离级别</td>
<td><code>select @@transaction_isolation</code></td>
</tr>
<tr>
<td>设置当前连接隔离级别</td>
<td><code>set transcation isolation level read committed</code></td>
</tr>
<tr>
<td>设置全局隔离级别</td>
<td><code>set global transcation isolation level read committed</code></td>
</tr>
</tbody></table>
<h4 id="事物日志"><a href="#事物日志" class="headerlink" title="事物日志"></a>事物日志</h4><ul>
<li><p>事务的隔离性由锁机制实现</p>
</li>
<li><p>而事务的原子性、一致性和持久性由事务的redo日志和undo日志来保证。</p>
<ul>
<li>REDO LOG称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性</li>
<li>UNDO LOG称为回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li>
</ul>
</li>
<li><p>redo log:是存储引擎层(innodb)生成的日志，记录的是”<strong>物理级别</strong>“上的<strong>页修改操作</strong>，比如页号xxx、偏移量yyy写入了zzz数据。主要为了保证数据的可靠性;</p>
</li>
<li><p>oundo log:是存储引擎层(innodb)生成的日志，记录的是<strong>逻辑操作</strong>日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于事务的回滚(undo log记录的是每个修改操作的逆操作)和<strong>一致性非锁定读</strong>(undo log回滚行记录到某种特定的版本—MVCC，即多版本并发控制)。</p>
</li>
</ul>
<h5 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h5><ul>
<li> 在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的<strong>顺序写入磁盘的</strong>，也就是使用顺序Io，效率比随机IO快。</li>
<li>redo log跟bin log的区别，redo log是存储引擎层产生的，而bin log是数据库层产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</li>
</ul>
<h6 id="redo的组成"><a href="#redo的组成" class="headerlink" title="redo的组成"></a>redo的组成</h6><ul>
<li><p>重做日志的缓冲(redo log buffer), 保存在内存中, 是易丢失的</p>
<p>在服务器启动时就向操作系统申请了一大片称之为redo log buffer的连续内存空间,这片内存空间被划分成若干个连续的redo log block 。一个redo log block占用512字节大小。</p>
</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202204290941476.png" alt="image-20220429094110371"></p>
<ul>
<li>重做日志文件( redo log file)，保存在硬盘中，是持久的。</li>
</ul>
<h6 id="redo的刷盘策略"><a href="#redo的刷盘策略" class="headerlink" title="redo的刷盘策略"></a>redo的刷盘策略</h6><p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202204290945110.png" alt="image-20220429094535061"></p>
<p>redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到文件系统缓存</p>
<p>针对这种情况，InnoDB给出<code>innodb_flush_log_at_trx_commit</code>参数，该参数控制commit提交事务时，如何将redo log buffer中的日志刷新到redo log file中。它支持三种策略:</p>
<ul>
<li>设置为0∶表示每次事务提交时不进行刷盘操作。(系统默认master thread每隔1s进行一次重做日志的同步)</li>
<li>设置为1∶表示每次事务提交时都将进行同步，刷盘操作（默认值)</li>
<li>设置为2∶表示每次事务提交时都只把redo log buffer内容写入page cache，不进行同步。由OS自己决定什么时候同步到磁盘文件。</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202204291009490.png" alt="image-20220429100900436"></p>
<h5 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h5><ul>
<li>回滚数据</li>
<li>MVCC</li>
</ul>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><ul>
<li>MVCC: 读-写操作彼此不冲突, 性能更高</li>
<li>加锁: 读-写操作彼此需要排队, 影响性能</li>
</ul>
<p>一般情况下采用MVCC来解决读-写操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用加锁的方式执行。</p>
<h5 id="从对数据操作的类型（读-写）分"><a href="#从对数据操作的类型（读-写）分" class="headerlink" title="从对数据操作的类型（读\写）分:"></a>从对数据操作的类型（读\写）分:</h5><ul>
<li>读锁（S共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</li>
<li>写锁（X排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</li>
</ul>
<h5 id="从对数据操作的粒度分"><a href="#从对数据操作的粒度分" class="headerlink" title="从对数据操作的粒度分:"></a><strong>从对数据操作的粒度分:</strong></h5><ul>
<li>表锁: 表级S-X锁, 意向锁, 自增锁, 元数据锁</li>
<li>行锁: 记录锁, 间隙锁, 临键锁, 插入意向锁</li>
<li>页锁: </li>
</ul>
<h5 id="从态度划分"><a href="#从态度划分" class="headerlink" title="从态度划分:"></a>从态度划分:</h5><ul>
<li>悲观锁:  </li>
<li>乐观锁: 不 采用锁机制, 采用程序来实现<ol>
<li>版本号机制</li>
<li>时间戳机制</li>
</ol>
</li>
</ul>
<h5 id="从加锁方式划分"><a href="#从加锁方式划分" class="headerlink" title="从加锁方式划分:"></a>从加锁方式划分:</h5><ul>
<li>隐式锁: INSERT操作下通过隐式锁保护这条记录在提交前不被别的事务访问, 冲突时转化为显式锁</li>
<li>显式锁:  <code>select * from performance_schema.data_lock_waits</code>能够查询到</li>
</ul>
<h4 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制(MVCC)"></a>多版本并发控制(MVCC)</h4><p><strong><font color="red">MVCC的实现依赖于: 隐藏字段(事务id), Undo Log(多版本), Read View(并发控制)</font></strong></p>
<p>MVCC主要是为了更好的方式去处理读-写冲突，有读写冲突时，不加锁，非阻塞并发读，这个读指的就是快照读,而非当前读。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p>
<h5 id="快照读-当前读"><a href="#快照读-当前读" class="headerlink" title="快照读-当前读"></a>快照读-当前读</h5><ul>
<li>快照读: 不加锁的简单的SELECT都属于快照读，即不加锁的非阻塞读;</li>
<li>当前读: 读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的SELECT，或者对数据进行增删改都会进行当前读。</li>
</ul>
<h5 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h5><p>ReadView就是事务A在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组,用来记录并维护系统当前活跃事务的ID(启动了但还没提交)。</p>
<h5 id="RedView结构"><a href="#RedView结构" class="headerlink" title="RedView结构"></a>RedView结构</h5><ol>
<li><code>creator_trx_id</code> 创建这个Read View的事务ID。</li>
<li><code>trx_ids</code> 表示在生成ReadView时当前系统中<strong>活跃</strong>的读写事务的事务id列表。</li>
<li><code>up_limit_id</code> 活跃的事务中最小的事务ID。</li>
<li><code>low_limit_id</code> 表示生成ReadView时系统中应该分配给下一个事务的id值(trx8+1)。</li>
</ol>
<p>​    举例:</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205061059382.png" alt="image-20220506105946271"></p>
<h5 id="ReadView规则"><a href="#ReadView规则" class="headerlink" title="ReadView规则"></a>ReadView规则</h5><ul>
<li>如果被访问版本的trx_id属性值与ReadView中的<code>creator_trx_id</code>值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值小于ReadView中的<code>up_limit_id</code>值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值大于或等于ReadView中的<code>low_limit_id</code>值，表明生成该版本的事务在当前事务生成Readview后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值在ReadView的<code>up_limit_id</code>和<code>low_limit_id</code>之间，那就需要判断一下trx_id属性值是不是在<code>trx_ids</code>列表中。<ul>
<li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li>
<li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
</li>
</ul>
<h5 id="MVCC操作流程"><a href="#MVCC操作流程" class="headerlink" title="MVCC操作流程"></a>MVCC操作流程</h5><ol>
<li>首先获取事务自己的版本号，也就是事务ID;</li>
<li>获取ReadView;</li>
<li>查询得到的数据，然后与ReadView中的事务版本号进行比较;</li>
<li>如果不符合ReadView规则，就需要从 Undo Log中获取历史快照;</li>
<li>最后返回符合规则的数据。</li>
</ol>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul>
<li><p>慢查询日志: 记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</p>
</li>
<li><p>通用查询日志: 记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</p>
</li>
<li><p>错误日志: 记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。</p>
</li>
<li><p>二进制日志: 记录所有更改数据的语句，可以用于主从服务器之间的数据同岁，以及服务器遇到故障时数据的无损失恢复。</p>
</li>
<li><p>中继日志: 用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</p>
</li>
<li><p>数据定义语句日志: 记录数据定义语句执行的元数据操作。</p>
<p>除二进制日志外，其他日志都是文本文件。默认情况下，所有日志创建于MySQL数据目录中。</p>
</li>
</ul>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ol>
<li>配置</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment">#[必须]主服务器唯一ID</span></span><br><span class="line"><span class="meta">server-id</span> = <span class="string">1</span></span><br><span class="line"><span class="comment">#[必须]启用二进制日志, 指定路径</span></span><br><span class="line"><span class="meta">log-bin</span> = <span class="string">/log/mysqlbin</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>建立账户并授权</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在主机中执行主从复制的命令 5.7</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">&#x27;slave1&#x27;</span>@ <span class="string">&#x27;从机数据库IP&#x27;</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">&#x27;abc123&#x27;</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;slave1&#x27;</span>@ <span class="string">&#x27;%&#x27;</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">&#x27;abc123&#x27;</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">&#x27;slave1&#x27;</span>@ <span class="string">&#x27;%&#x27;</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;slave1&#x27;</span>@ <span class="string">&#x27;%&#x27;</span> <span class="keyword">identified</span> <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;abc123&#x27;</span> </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>从机配置 log_file=<code>show master status</code></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=<span class="string">&#x27;主机的IP&#x27;</span>, master_user=<span class="string">&#x27;主机用户名&#x27;</span>,master_password=<span class="string">&#x27;用户密码&#x27;</span>,master_log_file=<span class="string">&#x27;binlog.&#x27;</span>, master_log_pos=<span class="string">&#x27;具体值&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>start slave</code>    <code>show status slave/g</code></li>
</ol>
<h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h3><ul>
<li>物理备份︰备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用xtrabackup工具来进行物理备份。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#备份</span><br><span class="line">flush tables with read lock;</span><br><span class="line">cp -r #复制文件</span><br><span class="line">unlock tables;</span><br><span class="line">#恢复 给与mysql备份文件访问权限</span><br><span class="line">chown -R mysql.mysql database1</span><br></pre></td></tr></table></figure>



<ul>
<li>逻辑备份:对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL中常用的逻辑备份工具为mysqldump。逻辑备份就是备份sql语句，在恢复的时候执行备份的saql语句实现数据库数据的重现。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#备份</span><br><span class="line">mysqldump -u 用户名称 -h 主机名称 备份数据库名[databse1]&gt;databse1.sql</span><br><span class="line">#恢复</span><br><span class="line">mysql -u root -p datavase1&lt;database1.sql</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>MySQL</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty网络通讯</title>
    <url>/2022/08/02/Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<h2 id="Netty网络通讯"><a href="#Netty网络通讯" class="headerlink" title="Netty网络通讯"></a>Netty网络通讯</h2><h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><ul>
<li><p>BIO(传统阻塞IO): 服务器实现模式为一个连接一个线程</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220802163623607.png" alt="image-20220802163623607"></p>
</li>
<li><p>NIO(同步非阻塞IO): 面向缓冲区(块)编程，服务器实现模式为一个线程处理多个请求(连接),请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理</p>
</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220802163844851.png" alt="image-20220802163844851"></p>
<ol>
<li>每个channel都会对应一个Bufer</li>
<li>Selector 对对应一个线程，一个线程对应多个channel(连接)</li>
<li>该图反应了有三个channel注册到该selector </li>
<li>程序切换到哪个channel是有事件决定的,Event是一个重要的概念</li>
<li>Selector会根据不同的事件，在各个通道上切换</li>
<li>Buffer就是一个内存块,底层是有一个数组</li>
<li>数据的读取写入是通过Buffer，BIO中要么是输入流，或者是输出流，不能双向，NIO的Buffer是可以读也可以写，需要flip()方法切换</li>
<li>channel是双向的，可以返回底层操作系统的情况，比如Linux，底层的操作系统通道就是双向的.</li>
</ol>
<h3 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区(Buffer)"></a>缓冲区(Buffer)</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Capacity</td>
<td>容量:即可以容纳的最大数据量;在缓吊区创建时被设并且不能改变</td>
</tr>
<tr>
<td>Limit</td>
<td>表示缓冲区的当前终点，不能对缓冲区超过极限的位置迸行读写操作。且极限是可修改的</td>
</tr>
<tr>
<td>Position</td>
<td>位置,下一个要被读或写的元素的索引,每次读亨缓冲区数据时都会改变改值,为下茨读写作准备</td>
</tr>
<tr>
<td>Mark</td>
<td>标记</td>
</tr>
</tbody></table>
<p>NIO还提供了MappedByteBuffer，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由NIO来完成</p>
<h3 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h3><ol>
<li><p>NIO的通道类似于流，但有些区别如下:</p>
<ul>
<li><p>通道可以同时进行读写，而流只能读或者只能写·通道可以实现异步读写数据</p>
</li>
<li><p>通道可以从缓冲读数据，也可以写数据到缓冲</p>
</li>
</ul>
</li>
<li><p>Channel在NIO中是一个接口</p>
</li>
<li><p>常用Channel类有: FileChannel, DatagramChannel, ServerSocketChannel, SocketChannnel</p>
</li>
<li><p>FileChannel用于文件数据读写, DatagramChannel 用于UDP的数据读写, ServerSocketChannel, SocketChannnel用于TCP的数据读写</p>
</li>
</ol>
<ul>
<li><p>文件读写</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220805163842676.png" alt="image-20220805163842676"></p>
</li>
<li><p>文件复制</p>
</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220805163939115.png" alt="image-20220805163939115"></p>
<ol start="5">
<li>NIO还支持通过多个Buffer(即 Buffer数组)完成读写操作，即Scattering 和 Gathering<ul>
<li>Scattering : 将数据写入到buffer时，可以采用buffer数组，依次写入</li>
<li>Gathering : 从buffer读取数据时，可以采用buffer数组，依次读</li>
</ul>
</li>
</ol>
<h3 id="选择器-Selector"><a href="#选择器-Selector" class="headerlink" title="选择器(Selector)"></a>选择器(Selector)</h3><ol>
<li>Selector能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。实现一个单线程管理多个通道，也就是管理多个连接和请求。</li>
<li>只有在 连接/通道 真正有读写事件发生时，才会进行读写，大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程, 避免了多线程之间的上下文切换导致的开销</li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>IO</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机</title>
    <url>/2022/08/08/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="1-内存与垃圾回收篇"><a href="#1-内存与垃圾回收篇" class="headerlink" title="1: 内存与垃圾回收篇"></a>1: 内存与垃圾回收篇</h1><h2 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h2><blockquote>
<img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220903135907749.png" alt="image-20220903135907749" style="zoom:200%;" />
</blockquote>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220820205156098.png" alt="image-20220820205156098"></p>
<h3 id="JVM架构模型"><a href="#JVM架构模型" class="headerlink" title="JVM架构模型"></a>JVM架构模型</h3><ul>
<li>基于栈的指令集架构: 跨平台性、指令集小、指令多;执行性能比寄存器差</li>
<li>基于寄存器的指令集架构: </li>
</ul>
<h3 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h3><ul>
<li>启动 : Java虚拟机的启动是通过引导类加载器(bootstrap class loader)创建个初始类(initial class)来完成的</li>
<li>执行: 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟<br>机的进程。</li>
<li>退出: </li>
</ul>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><blockquote>
<p>灰色的为单独线程私有的，红色的为多个线程共享的。即:<br>每个线程: 独立包括程序计数器、栈、本地栈。<br>线程间共享: 堆、堆外内存（永久代或元空间、代码缓存）</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220906095355477.png" alt="image-20220906095355477"></p>
</blockquote>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote>
<p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法(C/C++实现的方法)的调用。</p>
</blockquote>
<ul>
<li>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</li>
</ul>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h3><ul>
<li>PC寄存器用来存储指向下一条指令的地址，</li>
<li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li>
<li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址;或者，如果是在执行native方法，则是未指定值（undefned) 。</li>
</ul>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><blockquote>
<p>Java虚拟机栈（Java virtual Machine stack)，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(stack Frame） ，对应着一次次的Java方法调用。是线程私有的</p>
<p>可以使用参数-Xss选项来设置线程的最大栈空间</p>
</blockquote>
<p><strong>内部结构</strong></p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220916220020359.png" alt="image-20220916220020359"></p>
<ul>
<li><p>局部变量表(Local Variables)</p>
<ul>
<li>定义为一个数字数组，主要用于<strong>存储方法参数</strong>和定义在方法体内的<strong>局部变量</strong></li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据交全问题</li>
<li>局部变量表所需的容量大小是在编译期确定下来的</li>
<li>局部变量表中的变量也是**重要的垃圾回收根节点(GCRoots)**，只要被局部变量表中接或间接引用的对象都不会被回收。</li>
</ul>
</li>
<li><p>操作数栈(Operand Stack)</p>
<ul>
<li>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储]间。</li>
<li>在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop).</li>
</ul>
</li>
<li><p>动态链接(Dynamic Linking)—旨向运行时常量池的方法引用)</p>
<ul>
<li>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中<strong>该栈帧所属方法的引用</strong>。为了支持当前方法的代码能够实现动态链接( Dynamic Linking) 。</li>
</ul>
</li>
<li><p>方法返回地址(Return Address)</p>
<ul>
<li>存放调用该方法的pc寄存器的值。</li>
<li>在方法退出后会返回到<strong>该方法被调用的位置</strong>。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li>
</ul>
</li>
</ul>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><blockquote>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220921154304304.png" alt="image-20220921154304304"></p>
<ol>
<li>-Xms 起始内存, -Xmx 最大内存</li>
<li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</li>
<li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。大小可调节</li>
<li>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(ThreadLocal Allocation Buffer,TLAB)。</li>
</ol>
</blockquote>
<p><strong>年轻代与老年代</strong></p>
<ul>
<li><p>各分区比例</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220923162007757.png" alt="image-20220923162007757"></p>
</li>
</ul>
<p><strong>Minor GC, Major GC, Full GC</strong></p>
<p>JVM在进行GC时，并非每次都对上面三个内存区域(新生代、老年代、方法区)一起回收的，大部分时候回收的都是指新生代。</p>
<ul>
<li><p>部分收集: 不是完整收集整个Java堆的垃圾收集。其中又分为:</p>
<ul>
<li><p>新生代收集(Minor Gc / Young GC): 只是新生代的垃圾收集</p>
</li>
<li><p>老年代收集(Major Gc / Old GC): 只是老年代的垃圾收集。<strong>很多时候Major Gc会和Full Gc混淆使用，需要具体分辨是老年代回收还是整堆回收。</strong></p>
</li>
<li><p>混合收集(Mixed GC): 收集整个新生代以及部分老年代的垃圾收集。目前,只有G1 GC会有这种行为</p>
</li>
</ul>
</li>
<li><p>整堆收集（Full GC): 收集整个java堆和方法区的垃圾收集。</p>
</li>
</ul>
<p><strong>内存分配策略</strong></p>
<ul>
<li>优先分配到Eden</li>
<li>大对象直接分配到老年代</li>
<li>动态对象年龄判断: 如果survivor区中相同年龄的所有对象大小的总和大于survivor空间的一半，可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li>
<li>空间分配担保   Xx:HandlePromotionFailure</li>
<li>标量替换: 存储在栈</li>
</ul>
<p><strong>TLAB</strong></p>
<ul>
<li>对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域。</li>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote>
<p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误: java.lang.outofMemoryError:</p>
</blockquote>
<ul>
<li>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</li>
</ul>
<p><strong>运行时常量池</strong></p>
<ul>
<li>常量池表（Constant Pool Table）是class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</li>
</ul>
<p><strong>垃圾回收</strong></p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p><strong>标记阶段</strong></p>
<ul>
<li><p>引用计数法</p>
<ul>
<li>引用计数算法(Reference Counting)比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</li>
<li>引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li>
</ul>
</li>
<li><p>可达性分析算法</p>
<ul>
<li>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效<strong>地解决在引用计数算法中循环引用的问题</strong>，防止内存泄漏的发生。</li>
<li>…..</li>
<li>由于finalize ()方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态</strong>。<ul>
<li>可触及的:从根节点开始，可以到达这个对象。</li>
<li>可复活的:对象的所有引用都被释放，但是对象有可能在finalize ( )中复活。</li>
<li>不可触及的:对象的finalize ( )被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>清除阶段</strong></p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221015131311740.png" alt="image-20221015131311740"></p>
<ul>
<li><p>标记-清除算法(Mark - Sweep)</p>
<blockquote>
<p>当堆中的有效内存空间(available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world)I，然后进行两项工作，第一项则是标记，第二项则是清除。</p>
</blockquote>
<ul>
<li>标记:Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</li>
<li>清除:Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</li>
</ul>
</li>
<li><p>复制算法(Copying)</p>
<blockquote>
<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<p>适合: 垃圾较多</p>
</blockquote>
</li>
<li><p>标记-压缩算法(Mark - Compact)</p>
<blockquote>
<p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩(Mark-Sweep-Compact)算法。</p>
</blockquote>
<ul>
<li>第一阶段和标记-清除算法一样,从根节点开始标记所有被引用对象</li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</li>
<li>清理边界外所有的空间。</li>
</ul>
</li>
</ul>
<p><strong>分代收集算法</strong></p>
<p><strong>增量收集算法</strong></p>
<ul>
<li>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</li>
<li>增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</li>
<li>但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</li>
</ul>
<p><strong>分区算法</strong></p>
<ul>
<li>分代算法将按照对象的生命周期长短划分成两个部分分区算法将整个堆空间划分成连续的不同小区间。</li>
<li>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。 </li>
</ul>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><blockquote>
<p>不同的垃圾回收器概述</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023142302706.png" alt="image-20221023142302706"></p>
<p>不同的垃圾回收器组合关系</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023142431767.png" alt="image-20221023142431767"></p>
</blockquote>
<p><strong>Serial回收器: 串行回收</strong>   使用:-XX:+UseserialGC</p>
<ul>
<li><p>serial 收集器<strong>采用复制算法</strong>、串行回收和”Stop-The-World”机制方式执行内存回收。</p>
</li>
<li><p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial Old收集器同样也采用了串行回收和”Stop The World”机制，只不过内存回收算法使用的是<strong>标记-压缩算法</strong>。</p>
</li>
<li><p>这个收集器是一个单线程的收集器，它只会使用一个CPU或一条收集线程去完成垃圾收集工作，在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束( Stop The world)</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023143724508.png" alt="image-20221023143724508"></p>
</li>
</ul>
<p><strong>ParNew回收器: 并行回收</strong> 使用:-XX:+UseSerialGC</p>
<ul>
<li><p>ParNew收集器是Serial收集器的多线程版本。1.9过时</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023144243494.png" alt="image-20221023144243494"></p>
</li>
</ul>
<p><strong>Parallel回收器: 吞吐量优先</strong> (Java8默认)</p>
<ul>
<li><p>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个<strong>可控制的吞吐量</strong>（Throughput），它也被称为吞吐量优先的垃圾收集器。</p>
</li>
<li><p>自适应调节策略也是Parallel scavenge与ParNew一个重要区别。</p>
</li>
<li><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
</li>
<li><p>Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。</p>
</li>
<li><p>Parallel old收集器采用了标记-压缩算法，但同样也是基于并行回收和”Stop-the-world”机制。</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023145102489.png" alt="image-20221023145102489"></p>
</li>
<li><p>参数配置:</p>
<ul>
<li>-XX:ParallelGCThreads : 设置年轻代并行收集器的线程数</li>
<li>-XX:MaxGCPauseMillis设置垃圾收集器最大停顿时间(即STw的时间)。单位是毫秒。(慎用)</li>
<li>-XX:GCTimeRatio 垃圾收集时间占总时间的比例(= 1 / (N ＋ 1))用于衡量吞吐量的大小。</li>
<li>-XX:+UseAdaptivesizePolicy设置Parallel scavenge收集器具有自适应调节策略</li>
</ul>
</li>
</ul>
<p>**CMS回收器: 低延迟 ** Java14 G1代替</p>
<ul>
<li><p>在JDK 1.5时期，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器</p>
</li>
<li><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。</p>
</li>
<li><p>CMS的垃圾收集算法采用标记-清除算法，并且也会”Stop-The-World”</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023150902769.png" alt="image-20221023150902769"></p>
<p><strong>CMS整个过程分为4个主要阶段:</strong></p>
</li>
<li><p>初始标记（Initial-Mark）阶段: 这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p>
</li>
<li><p>并发标记（Concurrent-Mark）阶段: 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>
</li>
<li><p>重新标记（Remark）阶段: 为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p>
</li>
<li><p>并发清除(Concurrent-Sweep）阶段: 此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</p>
<p><strong>弊端:</strong></p>
</li>
</ul>
<ol>
<li>会产生内存碎片</li>
<li>CMS收集器对CPU资源非常敏感。</li>
<li>CMS收集器无法处理浮动垃圾</li>
</ol>
<p><strong>G1回收器(Garbage First)</strong> JDK7启用  JDK9后默认</p>
<ul>
<li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域(Region)（物理上不连续的）。使用不同的Region来表示Eden、幸存者o区，幸存者1区，老年代等。</li>
<li>G1 cc有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1跟踪各个 Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region)，所以我们给c1一个名字:垃圾优先（Garbage First） 。</li>
</ul>
<p>​    <strong>G1回收器的特点(优势)</strong></p>
<ul>
<li><p>并行与并发</p>
<ul>
<li>并行性: G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STw</li>
<li>并发性: G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
</li>
<li><p>分代收集</p>
<ul>
<li>将堆空间分为若干个区域(Region）,这些区域中包含了逻辑上的年轻代和老年代。</li>
<li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代;</li>
</ul>
</li>
<li><p>空间整和</p>
<ul>
<li>CMS: “标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</li>
<li>内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩(Mark-Compact)算法，两种算法都可以<strong>避免内存碎片</strong>。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>
</ul>
</li>
<li><p>可预测的停顿时间模型 ( 即: 软实时 soft real-time)</p>
<p>这是G1相对于CMS 的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒,</p>
<ul>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1跟踪各个 Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li>
<li>相比于CMS GC，G1未必能做到cMs在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
</li>
</ul>
<p>​    <strong>G1垃圾回收环节</strong></p>
<ul>
<li><p>年轻代GC(Young GC)</p>
</li>
<li><p>老年代并发标记过程(Concurrent Marking)</p>
</li>
<li><p>混合回收(Mixed GC)</p>
</li>
<li><p>（如果需要，单线程、独占式、高强度的Full Gc还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。)</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221024172622661.png" alt="image-20221024172622661"></p>
</li>
</ul>
<h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><ul>
<li>导出日志: -Xlogs/gc.log</li>
</ul>
<h1 id="2-字节码与类加载篇"><a href="#2-字节码与类加载篇" class="headerlink" title="2: 字节码与类加载篇"></a>2: 字节码与类加载篇</h1><h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
<th>长度</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u4</td>
<td>magic</td>
<td>魔术, 识别Class文件格式</td>
<td>4个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>副版本号(小版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>majot_version</td>
<td>主版本号(大版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>常量池计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>常量池表</td>
<td>n个字节</td>
<td>constant_pool_count-1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标识</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>父类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>接口计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>接口索引集合</td>
<td>2个字节</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>field_count</td>
<td>字段计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>字段表</td>
<td>n个字节</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>方法计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>方法表</td>
<td>n个字节</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性表</td>
<td>n个字节</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<h2 id="字节码指令集与解析"><a href="#字节码指令集与解析" class="headerlink" title="字节码指令集与解析"></a>字节码指令集与解析</h2><ul>
<li>加载与存储指令</li>
<li>算术指令</li>
<li>类型转换指令</li>
<li>对象的创建与访问指令</li>
<li>方法调用与返回指令<ul>
<li>invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java语言中<strong>最常见的方法分派方式</strong>。</li>
<li>invokeinterface指令用于<strong>调用接口方法</strong>，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。</li>
<li>invokespecial指令用于调用一些需要特殊处理的实例方法，包括<strong>实例初始化方法（构造器</strong>）、<strong>私有方法和父类方法</strong>。这些方法都是<strong>静态类型绑定</strong>的，不会在调用时进行动态派发。</li>
<li>invokestatic指令用于调用命名类中的<strong>类方法（static方法）</strong>。这是静态绑定的。</li>
<li>invokedynamic:调用动态绑定的方法，这个是JDK 1.7后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行核方法。前面4条调用指令的分派逻辑都固化在java 虚拟机内部，而<br>invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
</li>
<li>操作数栈管理指令</li>
<li>控制转移指令</li>
<li>异常处理指令</li>
<li>同步控制指令</li>
</ul>
<h2 id="类的加载过程详解"><a href="#类的加载过程详解" class="headerlink" title="类的加载过程详解"></a>类的加载过程详解</h2><blockquote>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220904152928052.png" alt="image-20220904152928052"></p>
</blockquote>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><strong>Loading(加载)</strong></p>
<p>Java类在JVM内存中加载一个快照，JVM将从字节码文件中解析出的<strong>常量池、类字段、类方法</strong>等信息存储到内存中，并在内存中构建出Java类的原型——类模板对象。</p>
<p>1．通过一个类的全限定名获取定义此类的二进制字节流<br>2．将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>3．在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
<p><strong>Linking(链接)</strong></p>
<ul>
<li><p>验证: 主要包括四种验证，文件格式验证，语义验证，字节码验证，符号引用验证。</p>
<p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20221101144858320.png" alt="image-20221101144858320"></p>
</li>
<li><p>准备: </p>
<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值</li>
<li>这里不包含用final修饰的static，因为<strong>final在编译的时候就会分配了</strong>，准备阶段会显式初始化;</li>
<li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li>
</ul>
</li>
<li><p>解析: 解析动作主要针对类或接口、字段、类方法  、接口方法、方法类型等。</p>
</li>
</ul>
<p><strong>Initialization(初始化)</strong></p>
<ul>
<li>初始化阶段就是执行类构造器方法<clinit>()的过程。</li>
<li>此方法不需定义，是javac编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态代码块中的语句</strong>合并而来。</li>
<li>主动使用&amp;被动使用 </li>
</ul>
<p><strong>Using(使用)</strong> </p>
<p><strong>Unloading(卸载)</strong></p>
<h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><blockquote>
<p>官方JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义加载器(User-Defined ClassLoader)。</p>
</blockquote>
<ul>
<li>启动类加载器（引导类加载器Bootstrap ClassLoader）<ul>
<li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li>
<li>用来加载Java的核心库, java. , javax. sun. 下的类</li>
<li>并不继承自java.lang.ClassLoader, 没有父加载器</li>
</ul>
</li>
<li>扩展类加载器 ( Extension ClassLoader )<ul>
<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li>
<li>派生于ClassLoader</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。</li>
</ul>
</li>
<li>应用程序类加载器（系统类加载器，AppclassLoader)<ul>
<li>它负责加载环境变量clsspath或系统属性java.class.path指定路径下的类库</li>
<li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载 </li>
</ul>
</li>
<li>用户自定义加载类<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄漏</li>
</ul>
</li>
</ul>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><blockquote>
<p>Java虚拟机对class文件采用的是按需加载的方式，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p>
</blockquote>
<p><strong>工作原理</strong></p>
<ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归请求最终将到达顶层的启动类加载器</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载</li>
</ol>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220906093247195.png" alt="image-20220906093247195"></p>
<p><strong>优势</strong></p>
<ul>
<li>避免类的重复加载</li>
<li>防止核心API被随意篡改</li>
</ul>
<h1 id="3-性能监控与调优篇"><a href="#3-性能监控与调优篇" class="headerlink" title="3: 性能监控与调优篇"></a>3: 性能监控与调优篇</h1><h2 id="JVM监控及诊断工具"><a href="#JVM监控及诊断工具" class="headerlink" title="JVM监控及诊断工具"></a>JVM监控及诊断工具</h2><p><strong>命令行工具</strong></p>
<ul>
<li>jps: 查看正在运行的Java进程</li>
<li>jstat: 查看JVM统计信息</li>
<li>jinfo: 实时查看和修改JVM配置参数</li>
<li>jmap: 导出内存映像文件</li>
<li>jhat: JDK自带堆分析工具</li>
<li>jstack: 追踪JVM中线程快照</li>
<li>jcmd: 多功能命令行工具</li>
<li>jstatd: 远程主机信息收集</li>
</ul>
<p><strong>GUI篇</strong></p>
<ul>
<li>jConsole</li>
<li>Visual VM</li>
<li>ecplise MAT</li>
<li>JProfiler</li>
<li>Arthas</li>
<li>Java Mission Control</li>
<li>Btrace</li>
<li>Flame Graphs</li>
</ul>
<p><strong>内存泄漏的8种情况</strong></p>
<ol>
<li>静态集合类</li>
<li>单例模式</li>
<li>内部类持有外部类</li>
<li>各种连接，如数据库连接、网络连接和IO连接等</li>
<li>变量不合理的作用域</li>
<li>改变哈希值</li>
<li>缓存泄漏</li>
<li>监听器和回调</li>
</ol>
<h2 id="JVM运行时参数"><a href="#JVM运行时参数" class="headerlink" title="JVM运行时参数"></a>JVM运行时参数</h2><p>分析GC日志</p>
<p>OOM常见场景及解决方案</p>
<p>性能优化案例</p>
<p>375/381P</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs学习</title>
    <url>/2021/07/26/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>web服务: express, koa, hapi<br>模板引擎: handlebars, ejs, jade<br>前端打包: webpak, fis,<br>任务管理: gulp<br>单元测试: karma, mocha, jasmine<br>包管理器: npm, cnpm, yarn<br>守护进程: pm2</p>
<a id="more"></a>

<h5 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h5><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> npm init </span><br></pre></td></tr></table></figure>

<h6 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 安装但不写入package.json； </span></span><br><span class="line"><span class="variable">$</span> npm install xxx</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 安装并写入package.json的&quot;dependencies&quot;中；</span></span><br><span class="line"><span class="variable">$</span> npm install xxx –S </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 安装并写入package.json的&quot;evDependencies&quot;中;</span></span><br><span class="line"><span class="variable">$</span> npm install xxx –D</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>S（等同于–save）表示项目打包时会将该依赖包一并打包；-D（等同于–save-dev）表示该依赖包仅在开发环境下使用，正式打包不会加到项目中。</p>
<h5 id="express模块"><a href="#express模块" class="headerlink" title="express模块"></a>express模块</h5><h6 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> npx express<span class="literal">-generator</span> -<span class="literal">-view</span>=ejs 项目名字</span><br></pre></td></tr></table></figure>

<h6 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> nmp i</span><br></pre></td></tr></table></figure>

<h6 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> npm <span class="built_in">start</span></span><br></pre></td></tr></table></figure>

<h6 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h6><ul>
<li><p>bin: 启动目录 里面包含了一个启动文件 www 默认监听端口是 3000 (不用)</p>
</li>
<li><p>node_modules: 所有安装的依赖模块 都在这个文件夹里面</p>
</li>
<li><p>public: 所有的前端静态资源 html css image js</p>
</li>
<li><p>routes: 放的是 路由 文件 (默认有两个)路由主要定义 url 和 资源 的映射关系 ( 一一对应关系 )主要用来接收前端发送的请求 响应数据给前端</p>
</li>
<li><p>views: 主要放置 ejs 后端模板文件</p>
</li>
<li><p>app.js: 入口文件(主文件) 总路由 (其他的路由 要由它来分配)</p>
</li>
<li><p>package.json: 包描述文件 最重要的是 依赖的模板列表 dependencies</p>
</li>
</ul>
<h6 id="app-js文件"><a href="#app-js文件" class="headerlink" title="app.js文件"></a>app.js文件</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> indexRouter = <span class="built_in">require</span>(<span class="string">&#x27;./routes/index&#x27;</span>);<span class="comment">//引入路由文件</span></span><br><span class="line"><span class="keyword">var</span> app = express(); <span class="comment">//创建服务器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置服务器模板渲染引擎</span></span><br><span class="line">app.set(<span class="string">&#x27;views&#x27;</span>, path.join(__dirname, <span class="string">&#x27;views&#x27;</span>));</span><br><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;ejs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">app.use(logger(<span class="string">&#x27;dev&#x27;</span>)); <span class="comment">//设置日为开发者模式</span></span><br><span class="line"></span><br><span class="line">app.use(express.json()); <span class="comment">//让express处理 json 数据</span></span><br><span class="line"></span><br><span class="line">app.use(express.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;)); <span class="comment">//用于接收 POSt 请求数据</span></span><br><span class="line"></span><br><span class="line">app.use(cookieParser()); <span class="comment">//处理 cookie 数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态资源设置；__dirnam代表当前文件的路径</span></span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">&#x27;public&#x27;</span>))); </span><br><span class="line"><span class="comment">//路由(API)</span></span><br><span class="line">app.use(<span class="string">&#x27;/&#x27;</span>, indexRouter);</span><br><span class="line">app.use(<span class="string">&#x27;/users&#x27;</span>, usersRouter);</span><br></pre></td></tr></table></figure>

<h5 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h5><h6 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> npm i mysql -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>

<h6 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> myConnection = mysql.createConnection(&#123;</span><br><span class="line">    host:<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    user:<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    database:<span class="string">&#x27;guoxinan&#x27;</span>,</span><br><span class="line">    port:<span class="number">3306</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">sql,option,callback</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//打开连接</span></span><br><span class="line">    myConnection.connect();</span><br><span class="line">    <span class="comment">//sql操作</span></span><br><span class="line">    myConnection.query(sql,option,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;操作数据库失败&quot;</span>,err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        callback(data);</span><br><span class="line">    &#125;);</span><br><span class="line">    myConnection.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">MYSQL：ER_NOT_SUPPORTED_AUTH_MODE:Client does not support authentication protocol</span><br></pre></td></tr></table></figure>

<p>原因:8.0mysql引入了caching_sha2_password模块作为默认身份验证插件，nodejs还没有跟进</p>
<p>解决办法:进入mysql修改密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;自己的密码&#39;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis相关使用</title>
    <url>/2020/11/13/Redis%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h3><p>Redis是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSI C编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的键值对存储数据库，其具备如下特性：</p>
<a id="more"></a>

<ul>
<li>基于内存运行，性能高效</li>
<li>支持分布式，理论上可以无限扩展</li>
<li>key-value存储系统</li>
<li>开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API</li>
</ul>
<h3 id="Nosql"><a href="#Nosql" class="headerlink" title="Nosql"></a>Nosql</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li>NoSQL(NoSQL = Not Only SQL )，意即”不仅仅是SQL”，泛指非关系型的数据库。</li>
<li>NoSQL不依赖业务逻辑方式存储,而以简单的key-value模式存储,因此大大的增加了数据库的扩展能力</li>
<li>不遵循SQL标准</li>
<li>不支持ACID(原子性,一致性,独立性,持久性)</li>
<li>远超SQL的性能</li>
</ul>
<h4 id="NoSQL适用场景"><a href="#NoSQL适用场景" class="headerlink" title="NoSQL适用场景"></a>NoSQL适用场景</h4><ul>
<li>对数据的高并发读写</li>
<li>海量数据的读写</li>
<li>对数据高可扩展性的</li>
</ul>
<h4 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h4><ul>
<li>需要事务支持</li>
<li>基于sql的结构化查询存储,处理复杂的关系,需要及席查询(条件查询)</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">systemctl start redis</td>
<td align="center">启动redis</td>
</tr>
<tr>
<td align="center">systemctl stop redis</td>
<td align="center">停止redis</td>
</tr>
<tr>
<td align="center">systemctl status redis</td>
<td align="center">查看redis运行状态</td>
</tr>
<tr>
<td align="center">ps ef</td>
<td align="center">grep redis</td>
</tr>
<tr>
<td align="center">redis-cli</td>
<td align="center">开启(本机)客户端</td>
</tr>
<tr>
<td align="center">redis-cli -h 127.0.0.1 -p6379</td>
<td align="center">开启客户端</td>
</tr>
</tbody></table>
<h4 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">keys *</td>
<td align="center">查询当前库的所有键</td>
</tr>
<tr>
<td align="center">exists <key></td>
<td align="center">判断某个键是否存在</td>
</tr>
<tr>
<td align="center">type <key></td>
<td align="center">查看键的类型</td>
</tr>
<tr>
<td align="center">del  <key></td>
<td align="center">删除某个键</td>
</tr>
<tr>
<td align="center">expire <key> <seconds></td>
<td align="center">为键值设置过期的时间,单位秒</td>
</tr>
<tr>
<td align="center">ttl <key></td>
<td align="center">查看还有多少秒过期,-1表示永不过期,-2表示已过期</td>
</tr>
<tr>
<td align="center">dbsize</td>
<td align="center">查看当前数据库的key的数量</td>
</tr>
<tr>
<td align="center">Flushdb</td>
<td align="center">清空当前库</td>
</tr>
<tr>
<td align="center">Flushall</td>
<td align="center">清空所有库</td>
</tr>
</tbody></table>
<h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">get <key></td>
<td align="center">查询对应键值</td>
</tr>
<tr>
<td align="center">set <key><value></td>
<td align="center">添加键值对</td>
</tr>
<tr>
<td align="center">append <key><value></td>
<td align="center">将value最佳到指定键值末</td>
</tr>
<tr>
<td align="center">strlen <key></td>
<td align="center">获得值的长度</td>
</tr>
<tr>
<td align="center">setnx <key><value></td>
<td align="center">只有在key不存在时设置key的值</td>
</tr>
<tr>
<td align="center">incr / decr <key></td>
<td align="center">将key中存储的数字值增1/减1(只能对数字值操作,如果为空,新增值为1/-1)</td>
</tr>
<tr>
<td align="center">incrby / decrby <key> &lt;步长&gt;</td>
<td align="center">将key中存储的数字增减,自定义步长</td>
</tr>
<tr>
<td align="center">mset<key1><value1> / mget <key1> <key2></td>
<td align="center">多个添加获取</td>
</tr>
<tr>
<td align="center">getrange <key><start><end></td>
<td align="center">获取值的范围,类似java中的substring</td>
</tr>
<tr>
<td align="center">setrange <key><start><value></td>
<td align="center">用<value>覆写<key>所存储的字符串值,从<start>开始</td>
</tr>
</tbody></table>
<p> 默认16个数据库,类似数组下标从0开始,初始默认使用0号库</p>
<p>使用 select <id> 来切换数据库</p>
<h3 id="五种数据结构"><a href="#五种数据结构" class="headerlink" title="五种数据结构"></a>五种数据结构</h3><p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201204163643.png"></p>
<h4 id="1-String-字符串类型"><a href="#1-String-字符串类型" class="headerlink" title="1.String 字符串类型"></a>1.String 字符串类型</h4><p>是redis中最基本的数据类型，一个key对应一个value。</p>
<p>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</p>
<p>使用：get 、 set 、 del 、 incr、 decr 等</p>
<p>实战场景：</p>
<ol>
<li><p>缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</p>
</li>
<li><p>计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</p>
</li>
<li><p>session：常见方案spring session + redis实现session共享</p>
</li>
</ol>
<h4 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h4><p>是一个Mapmap，指值本身又是一种键值对结构，如 value={ {field1,value1},……fieldN,valueN} }</p>
<p>使用：所有hash的命令都是 h  开头的   hget 、hset 、 hdel 等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user name1 hao</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user email1 hao@163.com</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) &quot;name1&quot;</span><br><span class="line">2) &quot;hao&quot;</span><br><span class="line">3) &quot;email1&quot;</span><br><span class="line">4) &quot;hao@163.com&quot;</span><br><span class="line">127.0.0.1:6379&gt; hget user user</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; hget user name1</span><br><span class="line">&quot;hao&quot;</span><br><span class="line">127.0.0.1:6379&gt; hset user name2 xiaohao</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user email2 xiaohao@163.com</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) &quot;name1&quot;</span><br><span class="line">2) &quot;hao&quot;</span><br><span class="line">3) &quot;email1&quot;</span><br><span class="line">4) &quot;hao@163.com&quot;</span><br><span class="line">5) &quot;name2&quot;</span><br><span class="line">6) &quot;xiaohao&quot;</span><br><span class="line">7) &quot;email2&quot;</span><br><span class="line">8) &quot;xiaohao@163.com&quot;</span><br></pre></td></tr></table></figure>

<p>实战场景：</p>
<ol>
<li>缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。</li>
</ol>
<h4 id="3-链表"><a href="#3-链表" class="headerlink" title="3.链表"></a>3.链表</h4><p>List 说白了就是链表（redis 使用双端链表实现的 List），是有序的，value可以重复，可以通过下标取出对应的value值，左右两边都能进行插入和删除数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mylist 1 2 ll ls mem</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;mem&quot;</span><br><span class="line">2) &quot;ls&quot;</span><br><span class="line">3) &quot;ll&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p>实战场景：</p>
<p>1.timeline：例如微博的时间轴，有人发布微博，用lpush加入时间轴，展示新的列表信息。</p>
<h4 id="4-Set-集合"><a href="#4-Set-集合" class="headerlink" title="4.Set  集合"></a>4.Set  集合</h4><p>集合类型也是用来保存多个字符串的元素，但和列表不同的是集合中 </p>
<ol>
<li>不允许有重复的元素</li>
<li>集合中的元素是无序的，不能通过索引下标获取元素</li>
<li>支持集合间的操作，可以取多个集合取交集、并集、差集</li>
</ol>
<p>使用：命令都是以s开头的 sset 、srem、scard、smembers、sismember</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset hao hao1 xiaohao hao</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) &quot;xiaohao&quot;</span><br><span class="line">2) &quot;hao1&quot;</span><br><span class="line">3) &quot;hao&quot;</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset hao</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>实战场景;</p>
<ol>
<li><p>标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</p>
</li>
<li><p>点赞，或点踩，收藏等，可以放到set中实现</p>
</li>
</ol>
<h4 id="5-zset-有序集合"><a href="#5-zset-有序集合" class="headerlink" title="5.zset 有序集合"></a>5.zset 有序集合</h4><p>有序集合和集合有着必然的联系，保留了集合不能有重复成员的特性，区别是，有序集合中的元素是可以排序的，它给每个元素设置一个分数，作为排序的依据。</p>
<p>使用： 有序集合的命令都是 以 z 开头  zadd 、 zrange、 zscore</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myscoreset 100 hao 90 xiaohao</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myscoreset 0 -1</span><br><span class="line">1) &quot;xiaohao&quot;</span><br><span class="line">2) &quot;hao&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myscoreset hao</span><br><span class="line">&quot;100&quot;</span><br></pre></td></tr></table></figure>

<p>实战场景：</p>
<ol>
<li>排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</li>
</ol>
<h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><h4 id="ip地址的绑定-bind"><a href="#ip地址的绑定-bind" class="headerlink" title="ip地址的绑定(bind)"></a>ip地址的绑定(bind)</h4><ul>
<li>默认情况下bind = 127.0.0.1只能接受本机访问,不写无限制接收任何ip访问(生产环境要写应用服务器的地址)</li>
<li>如果开启了protexted-mode,在没有设定bind ip 且没有设密码的情况下,只允许接收本机访问</li>
</ul>
<h4 id="tcp-backlog"><a href="#tcp-backlog" class="headerlink" title="tcp-backlog"></a>tcp-backlog</h4><ul>
<li>请求到达后至少接受进程处理前的队列</li>
<li>backlog队列总和 = 未完成三次握手队列 + 已经完成三次握手的队列</li>
<li>高并发环境tcp-backlog设置值跟超时时限内的Redis吞吐量决定</li>
</ul>
<h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><ul>
<li>一个空闲的客户端维持多少秒会关闭,0为永不关闭</li>
</ul>
<h4 id="TCP-keepalive"><a href="#TCP-keepalive" class="headerlink" title="TCP keepalive"></a>TCP keepalive</h4><ul>
<li>对访问客户端的一种心跳检测,每n秒检测一次,官方推荐为60秒</li>
</ul>
<h4 id="requirepass"><a href="#requirepass" class="headerlink" title="requirepass"></a>requirepass</h4><ul>
<li>设置永久密码</li>
</ul>
<h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="连接Redis"><a href="#连接Redis" class="headerlink" title="连接Redis"></a>连接Redis</h4> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;xxx.xxx.xx.xx&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">jedis.ping();</span><br><span class="line">jedus.close();</span><br></pre></td></tr></table></figure>

<h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li><p>Redis事务是一个单独的隔离操作: 事务中的所有命令都会序列化, 按顺序的执行,事务在执行的过程中, 不iu被其他客户端发送来的命令请求所打断</p>
</li>
<li><p>Redis事务的主要作用就是串联多个命令防止别人的命令插队</p>
</li>
</ul>
<h4 id="Multi-Exec-discard"><a href="#Multi-Exec-discard" class="headerlink" title="Multi, Exec, discard"></a>Multi, Exec, discard</h4><ul>
<li>从输入Multi命令开始, 输入的命令都会依次进入命令队列中, 但不会执行, 直到输入Exec后, Redis会将之前的命令队列中的命令依次执行.</li>
<li>组队的过程中可以通过discard来放弃组队(回滚).</li>
</ul>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201115155543.png"></p>
<p><img src="https://s2.loli.net/2022/04/07/SjUIoKfFGyzsi1L.png"></p>
<h4 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h4><ul>
<li>组队中某个命令如果出现了报告错误, 执行时整个的队友队列都会被取消</li>
</ul>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201115155931.png" alt="事务的错误处理"></p>
<ul>
<li>如果执行阶段某个命令报出了错误, 则只有报错的命令不会被执行, 而其他的命令都会执行,不会回滚</li>
</ul>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201115160127.png" alt="事务的错误处理"></p>
<h4 id="WATCH-监视"><a href="#WATCH-监视" class="headerlink" title="WATCH (监视)"></a>WATCH (监视)</h4><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个)key ，如果在事务执行之前这个(或这些) key被其他命令所改动，那么事务将被打断，unwatch取消监视</p>
<h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><p>Redis提供了2个不同形式的持久化方式</p>
<h4 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h4><ul>
<li><p>在指定的时间间隔内将内存中的数据集快照(Snapshot)写入磁盘，它恢复时是将快照文件直接读到内存里。</p>
</li>
<li><p>Redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能,如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p>
</li>
<li><p>RDB保存的文件在redis.conf中配置文件名称,默认为dump.rdb,保存路径也可修改</p>
</li>
<li><p>RDB的保存策略 </p>
<p>save    900    1(900秒内保存1次)</p>
</li>
</ul>
<h4 id="AOF-Append-Of-File"><a href="#AOF-Append-Of-File" class="headerlink" title="AOF(Append Of File)"></a>AOF(Append Of File)</h4><ul>
<li>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</li>
<li>AOF默认不开启, 需要在配置文件中配置  apeendonly 为 yes</li>
<li>AOF与RDB同时开启, 以AOF为准</li>
</ul>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><ul>
<li><p>作用:     1.读写分离(主机写从机读)     2.容灾的快速恢复    </p>
</li>
<li><p>复制原理: Slave启动成功连接到master后会发送一个sync命令,master接到后启动后台的存盘进程,将所有数据传送到slave</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/04/s3u9aZlbWU6xIp2.png">cc</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>info replication</td>
<td>查看主机运行状态</td>
</tr>
<tr>
<td>slaveof 127.0.0.1 6379</td>
<td>设置从机</td>
</tr>
<tr>
<td>slaveof no one</td>
<td>讲从机变为主机</td>
</tr>
</tbody></table>
<p>注意:本地测试时配置redis.windows-service.conf(redis.conf) 文件 bind IP地址（不要用127.0.0.1）</p>
<p>redis-cli -h IP地址 -p 端口号 -a 密码  </p>
<h4 id="哨兵模式-分片集群"><a href="#哨兵模式-分片集群" class="headerlink" title="哨兵模式(分片集群)"></a>哨兵模式(分片集群)</h4><ol>
<li><p>redis安装目录下创建<code>sentinel.conf</code>文件</p>
</li>
<li><p>写入<code>sentinel monitor mymaster 127.0.0.1 1</code>    “1”表示至少多少个哨兵同意迁移的数量</p>
</li>
<li><p>启动哨兵 <code>redis-sentinel sentinel.cof</code></p>
</li>
<li><p>主机选择 优先级在redis.conf 中默认: <code>slave-prioriy </code>( replica-prioriy 新 ) 100，值越小优先级越高</p>
</li>
<li><p>Java中使用</p>
<p><img src="https://s2.loli.net/2022/04/04/TyqZxJYLtFd51lU.png"></p>
</li>
</ol>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>Redis集群实现了对Redis 的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。</p>
<p>Redis集群通过分区( partition )来提供一定程度的可用性( av ailability ): 即使集群中有一部分节点失效或者无法进行通讯，集群也可以继续处理命令请求。·</p>
<h5 id="配置-redis-conf"><a href="#配置-redis-conf" class="headerlink" title="配置(redis.conf)"></a>配置(redis.conf)</h5><table>
<thead>
<tr>
<th>配置项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cluster-enabled yes</td>
<td>打开集群模式</td>
</tr>
<tr>
<td>cluster-config-file nodes-6379.conf</td>
<td>设定节点配置文件名</td>
</tr>
<tr>
<td>cluster-node-timeout 15000</td>
<td>设定节点失联时间,超过时间自动主从切换</td>
</tr>
</tbody></table>
<p>创建集群: redis-cli -cluster create —replicas 1 ip1:port ip2:port ip3:port ip4:port ip5:port ip6:portc    (1,2,3主3,4,5从),</p>
<p>一个集群至少要有三个主节点    “1”表示希望为集群中的每个主节点创建—个从节点。分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个P地址上.</p>
<h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>redis-cli -c -p 6379</td>
<td>集群方式连接</td>
</tr>
<tr>
<td>cluster nodes</td>
<td>查看集群中节点信息</td>
</tr>
</tbody></table>
<h5 id="Jedis使用"><a href="#Jedis使用" class="headerlink" title="Jedis使用"></a>Jedis使用</h5><p>即使连接的不是主机，集群会自动切换主机 存储。主机写，从机读。无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p>
<p><img src="https://s2.loli.net/2022/04/05/7N46pY3kZhJBRzC.png"></p>
<h3 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h3><p>Redis keys过期有两种方式: 被动和主动方式</p>
<ul>
<li>主动: 当客户端访问它时, key会被发现并主动过期</li>
<li>被动: Redis每秒做10次随机测试20个Keys进行过期检测, 删除过期Keys, 如多余25%过期, 再次抽20个</li>
</ul>
<h3 id="缓存回收"><a href="#缓存回收" class="headerlink" title="缓存回收"></a>缓存回收</h3><p>Redis中提供了一种内存淘汰策略，当内存不足时，Redis会根据相应的淘汰规则对key数据进行淘汰。Redis一共提供了8种淘汰策略</p>
<ul>
<li><strong>volatile-lru</strong>，针对设置了过期时间的key，使用lru算法进行淘汰。</li>
<li><strong>allkeys-lru</strong>，针对所有key使用lru算法进行淘汰。</li>
<li><strong>volatile-lfu</strong>，针对设置了过期时间的key，使用lfu算法进行淘汰。</li>
<li><strong>allkeys-lfu</strong>，针对所有key使用lfu算法进行淘汰。</li>
<li><strong>volatile-random</strong>，从所有设置了过期时间的key中使用随机淘汰的方式进行淘汰。</li>
<li><strong>allkeys-random</strong>，针对所有的key使用随机淘汰机制进行淘汰。</li>
<li><strong>volatile-ttl</strong>，删除生存时间最近的一个键。</li>
<li><strong>noeviction</strong>，不删除键，值返回错误。(默认)</li>
</ul>
<p>注: LRU—Least Recently Used 近期最少使用算法(最后一次被使用到发生调度的时间长短)            LFU—-Least Frequently Used算法,即最少访问算法(一定时间段内页面被使用的频率)</p>
<h3 id="缓存穿透-击穿-雪崩"><a href="#缓存穿透-击穿-雪崩" class="headerlink" title="缓存穿透,击穿,雪崩"></a>缓存穿透,击穿,雪崩</h3><p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/061e2c04e0ebca3425dd75dd035b6b7b.png" alt="图片"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity权限控制</title>
    <url>/2020/11/09/SpringSecurity%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="spring-security-简介"><a href="#spring-security-简介" class="headerlink" title="spring security 简介"></a>spring security 简介</h2><p>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它是用于保护基于Spring的应用程序的实际标准。</p>
<p>Spring Security是一个框架，致力于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring Security的真正强大之处在于可以轻松扩展以满足自定义要求</p>
<a id="more"></a>

<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192027289.png" alt="20201109124625"></p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192027332.png" alt="20201109163442"></p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>SpringSecurity本质是一个过滤器</p>
<ul>
<li>FilterSecurityInterceptor: 是一个方法级的权限过滤器,基本位于过滤链的最底部</li>
<li>ExceptionTranslationFilter: 是个异常过滤器，用来处理在认证授权过程中抛出的异常</li>
<li>UsernamePasswordAuthenticationFilter: 对/ login的POST请求做拦截，校验表单中用户名，密码。<ul>
<li>attemptAuthentication: 处理用户名密码</li>
<li>successfulAuthenticaiton: 认证成功处理逻辑</li>
<li>unsuccessfulAuthenticaiton: 认证失败处理逻辑</li>
</ul>
</li>
</ul>
<h2 id="重要接口"><a href="#重要接口" class="headerlink" title="重要接口"></a>重要接口</h2><ul>
<li><p>UserDetailsService接口: 查询数据库用户名和密码过程, 创建类实现UserDetailService，编写查询数据过程，返回User对象这个User对象是安全框架提供对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//1.数据库查询admin对象</span></span><br><span class="line">        Admin admin = AdminMapper.select....byName();</span><br><span class="line">        <span class="comment">//2.给admin设置角色权限信息</span></span><br><span class="line">        List&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> ArrayList&lt;GrantedAuthority&gt;();</span><br><span class="line">        authorities.add(<span class="keyword">new</span> SimpleGrantedAuthority(<span class="string">&quot;ROLE_ADMIN&quot;</span>));</span><br><span class="line">        authorities.add(<span class="keyword">new</span> SimpleGrantedAuthority(<span class="string">&quot;UPDATE&quot;</span>));</span><br><span class="line">        <span class="comment">//3.把admin对象和authorities封装到UserDetails中</span></span><br><span class="line">        String password = admin.getPassword();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(username,password,authorities);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注意:SpringSecurity会在角色字符串前面加”ROLE”前缀,从数据库查询得到的用户信息,角色信息,权限信息需要之际手动组装,组装时同样要在角色字符串前面加”ROLE_”</em></p>
</li>
<li><p>PasswordEncoder接口: 数据加密接口，用于返回User对象里面密码加密</p>
</li>
</ul>
<h2 id="Web权限方案"><a href="#Web权限方案" class="headerlink" title="Web权限方案"></a>Web权限方案</h2><h3 id="配置类使用"><a href="#配置类使用" class="headerlink" title="配置类使用"></a>配置类使用</h3><ol>
<li><p>继承WebSecurityConfigurerAdapter 并重写configure方法,并加入到IOC容器</p>
<ul>
<li><p>@EnableWebMvcSecurity注解：在Spring 4.0中已弃用。</p>
</li>
<li><p>WebSecurityConfigurerAdapter类：可以通过重载该类的三个configure()方法来制定Web安全的细节。(过时)</p>
</li>
<li><p>使用 <code>SecurityFilterChain</code> @Bean 来配置 <code>HttpSecurity</code></p>
</li>
<li><p>使用 <code>WebSecurityCustomizer</code> Bean 来配置 <code>WebSecurity</code></p>
</li>
</ul>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppSecurity</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//通过重载该方法，可配置如何通过拦截器保护请求。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//构建User对象==&gt;userDetailsService (用户名密码) </span></span><br><span class="line">        auth.userDetailsService(userDetailServiceImpl).passwordEncoder(getPasswordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//通过重载该方法，可配置Spring Security的Filter链</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/static&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>HttpSecurity http</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">            <span class="comment">//修改Spring Security默认的登陆界面</span></span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginPage(<span class="string">&quot;/to/login/page.html&quot;</span>)</span><br><span class="line">            .loginProcessingUrl(<span class="string">&quot;/do/login.html&quot;</span>)</span><br><span class="line">            .defaultSuccessUrl(<span class="string">&quot;/to/main/page.html	&quot;</span>)</span><br><span class="line">            .permitAll()			<span class="comment">//无条件访问</span></span><br><span class="line">            </span><br><span class="line">            .authorizeRequests()	<span class="comment">//对请求进行授权 </span></span><br><span class="line">            <span class="comment">//访问&quot;/&quot;和&quot;/home&quot;路径的请求都允许</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/home&quot;</span>)</span><br><span class="line">            .permitAll()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//而其他的请求都需要认证</span></span><br><span class="line">            .anyRequest()</span><br><span class="line">            .authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable() <span class="comment">//关闭csrf防护</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//对url设置访问要求</span></span><br><span class="line">            .antMathers(<span class="string">&quot;/test/index&quot;</span>)		</span><br><span class="line">            .hasRole()				<span class="comment">//要求用户具备的角色</span></span><br><span class="line">            .usernameParameter(<span class="string">&quot;loginAcct&quot;</span>)</span><br><span class="line">            .passwordParameter(<span class="string">&quot;userPwd&quot;</span>)</span><br><span class="line">            .and()</span><br><span class="line">            .logout()	</span><br><span class="line">            .logoutUrl(<span class="string">&quot;/do/logout.html&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//指定异常处理器</span></span><br><span class="line">            .exceptionHandling()	</span><br><span class="line"><span class="comment">//            .accessDeniedPage(&quot;/to/error/page.html&quot;)	//访问被拒时去的页面</span></span><br><span class="line">            .accessDeniedHandler(<span class="keyword">new</span> AccessDeniedHandler()) <span class="comment">//定制异常处理</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//记住登录状态</span></span><br><span class="line">			.rememberMe()</span><br><span class="line">            <span class="comment">//setCreateTableOnStartup 自动创建表</span></span><br><span class="line">            .tokenRepository(<span class="meta">@Bean</span> <span class="keyword">new</span> PersistentTokenRepository.setDataSourse())</span><br><span class="line">            .tokenValiditySeconds(<span class="number">60</span>)</span><br><span class="line">            .userDetailsService(userDetailServiceImpl)</span><br><span class="line">	</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录信息保存(Remenber me)</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220908142444889.png" alt="image-20220908142444889"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">记住我:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remember-me&quot;</span> <span class="attr">title</span>=<span class="string">记住密码</span>&quot;/&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td>access(String)</td>
<td align="left">如果给定的SpEL表达式计算结果为true，就允许访问</td>
</tr>
<tr>
<td>anonymous()</td>
<td align="left">允许匿名用户访问</td>
</tr>
<tr>
<td>authenticated()</td>
<td align="left">允许认证过的用户访问</td>
</tr>
<tr>
<td>denyAll()</td>
<td align="left">无条件拒绝所有访问</td>
</tr>
<tr>
<td>fullyAuthenticated()</td>
<td align="left">如果用户是完整认证的话（不是通过Remember-me功能认证的），就允许访问</td>
</tr>
<tr>
<td>hasAnyAuthority(String…)</td>
<td align="left">如果用户具备给定权限中的某一个的话，就允许访问</td>
</tr>
<tr>
<td>hasAnyRole(String…)</td>
<td align="left">如果用户具备给定角色中的某一个的话，就允许访问</td>
</tr>
<tr>
<td><strong>hasAuthority(String)</strong></td>
<td align="left"><strong>如果用户具备给定权限的话，就允许访问</strong></td>
</tr>
<tr>
<td>hasIpAddress(String)</td>
<td align="left">如果请求来自给定IP地址的话，就允许访问</td>
</tr>
<tr>
<td><strong>hasRole(String)</strong></td>
<td align="left"><strong>如果用户具备给定角色的话，就允许访问</strong></td>
</tr>
<tr>
<td>not()</td>
<td align="left">对其他访问方法的结果求反</td>
</tr>
<tr>
<td>permitAll()</td>
<td align="left">无条件允许访问</td>
</tr>
<tr>
<td>rememberMe()</td>
<td align="left">如果用户是通过Remember-me功能认证的，就允许访问</td>
</tr>
<tr>
<td>usernameParameter()</td>
<td align="left">定制登录账号请求参数名</td>
</tr>
<tr>
<td>passwordParameter()</td>
<td align="left">定制登录密码请求参数名</td>
</tr>
<tr>
<td>defaultSuccessUrl()</td>
<td align="left">登录成功后去往的页面</td>
</tr>
<tr>
<td>loginProcessingUrl()</td>
<td align="left">登录放行</td>
</tr>
</tbody></table>
<p>(1).引入SpringSecurity标签库</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">&quot;security&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;http://www.springframework.org/security/tags&quot;</span> %&gt;</span></span><br></pre></td></tr></table></figure>

<p>(2).获取(UsernamePasswordAuthenticationToken会擦除密码)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security:authentication</span> <span class="attr">property</span>=<span class="string">&quot;principal.original.username&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="注解使用"><a href="#注解使用" class="headerlink" title="注解使用"></a>注解使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line">    <span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span>	<span class="comment">//开启注解 (配置类或者启动类上)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> configure........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller上使用注解:@PreAuthority,@PostAuthority,@PreFilter,@PostFilter</p>
<ul>
<li>@Secured: 具有某个角色可以访问</li>
<li>@PreAuthority: 进入方法前, 验证权限</li>
<li>@PostAuthority: 进入方法后, 验证权限</li>
<li>@PreFilter: 对传入数据做过滤</li>
<li>@PostFilter: 对返回数据做过滤</li>
</ul>
<h3 id="csrf"><a href="#csrf" class="headerlink" title="csrf"></a><strong>csrf</strong></h3><p>用来生成token防止跨站请求伪造,需要在表单添加</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;_csrf.parameterName&#125;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者配置HttpSecurity禁用否则会发生403错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.csrf().disable();</span><br></pre></td></tr></table></figure>





<h3 id="配置文件使用"><a href="#配置文件使用" class="headerlink" title="配置文件使用"></a>配置文件使用</h3><p><strong>配置xml</strong></p>
<p>SpringSecurity使用的是过滤器Filter而不是拦截器Interceptor,意味着SpringSecurity能够管理的不仅仅是SpringMVC中的handler请求,还包含Web应用中的所有请求,包括静态资源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFileterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFileterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>filter-name中的名字必须是springSecurityFileterChain才能加载到ioc容器中的Filter</p>
<p><strong>导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringSecurity 对 Web 应用进行权限管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- SpringSecurity 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- SpringSecurity 标签库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-taglibs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><blockquote>
<p>No bean named ‘springSecurityFilterChain’ available:</p>
</blockquote>
<p>当SpringSecurity配置类添加到SpringMvc Ioc中时,会抛出找不到pspringSecurityFilterChain异常</p>
<ul>
<li><p>三大组件启动顺序:</p>
<p>首先:ContextLoaderListener初始化,创建Spring的IOC容器</p>
<p>其次:DelegatingFilterProxy初始化,查找IOC容器,查找bean</p>
<p>最后:DispatherServlet初始化,创建SpringMVC的IOC容器</p>
</li>
<li><p>Filter查找IOC容器然后找Bean的工作机制</p>
</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192028931.png" alt="20201110111808"></p>
<ul>
<li><p>解决方案一:把两个ioc容器合二为一</p>
<p>不使用ContextLoaderListener,让Dispater加载所有Spring配置文件,但是会破环现有程序结构</p>
</li>
<li><p>解决方案二:改源码</p>
<p>修改DelegatingFilterProxy类的initFilterBean(),doFilter()方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.delegateMonitor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.delegate == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If no target bean name specified, use filter name.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.targetBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.targetBeanName = getFilterName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Fetch Spring root application context and initialize the delegate early,</span></span><br><span class="line">            <span class="comment">// if possible. If the root application context will be started after this</span></span><br><span class="line">            <span class="comment">// filter proxy, we&#x27;ll have to resort to lazy initialization.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*注释掉</span></span><br><span class="line"><span class="comment">                WebApplicationContext wac = findWebApplicationContext();</span></span><br><span class="line"><span class="comment">                if (wac != null) &#123;</span></span><br><span class="line"><span class="comment">                    this.delegate = initDelegate(wac);</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">	<span class="comment">// Lazily initialize the delegate if necessary.</span></span><br><span class="line">	Filter delegateToUse = <span class="keyword">this</span>.delegate;</span><br><span class="line">	<span class="keyword">if</span> (delegateToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.delegateMonitor) &#123;</span><br><span class="line">			delegateToUse = <span class="keyword">this</span>.delegate;</span><br><span class="line">			<span class="keyword">if</span> (delegateToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">//把原来查找IOC容器的代码注释掉,按需要重新编写</span></span><br><span class="line">				<span class="comment">//WebApplicationContext wac = findWebApplicationContext();</span></span><br><span class="line">                   <span class="comment">//1.获取ServletContext对象</span></span><br><span class="line">                   ServletContext sc = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">                   <span class="comment">//2.拼接SpingMvc将Ioc容器存入ServletContext域的时候使用的属性名</span></span><br><span class="line">                   String servletName = <span class="string">&quot;springDispatherServlet&quot;</span>;</span><br><span class="line">                   String attrName = FrameworkServlet.SERVLET_CONTEXT_PREFIX+servletName;</span><br><span class="line">                   <span class="comment">//3.根据attrName从ServletCOntext域中获取IOC容器对象</span></span><br><span class="line">                   WebApplicationContext wac = (WebApplicationContext)sc.getAttribute(attrName)</span><br><span class="line">				<span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No WebApplicationContext found: &quot;</span> +</span><br><span class="line">							<span class="string">&quot;no ContextLoaderListener or DispatcherServlet registered?&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				delegateToUse = initDelegate(wac);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.delegate = delegateToUse;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Cannot pass a pull GrantedAuthorrity collection:</p>
</blockquote>
<p>没有设置roles()或者authorities方法导致的</p>
<blockquote>
<p>Spring Security 登陆报错：There is no PasswordEncoder mapped for the id “null”:</p>
<p>必须设置密码的加密方式</p>
</blockquote>
<p>5.0以后对于密码的管理有些变化,现如今Spring Security中密码的存储格式是“{id}…………”。前面的id是加密方式，id可以是bcrypt、sha256等，后面跟着的是加密后的密码。也就是说，程序拿到传过来的密码的时候，会首先查找被“{”和“}”包括起来的id，来确定后面的密码是被怎么样加密的，如果找不到就认为id是null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">auth.passwordEncoder(<span class="keyword">new</span> BCryptPasswordEncoder())</span><br><span class="line">    .password(<span class="keyword">new</span> BCryptPasswordEncoder().encode(<span class="string">&quot;123123&quot;</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@PreAuthorize()无法拦截：</p>
</blockquote>
<p>在使用@PreAuthorize()做拦截时,如果同时也设置了@EnableGlobalMethodSecurity(prePostEnabled = true),还是无法拦截,可能时因为在扫描SpringSecurity时是使用Spring扫描,而拦截注解加在了请求上,将注解加在Service文件或者是Mapper文件即可,反之亦然</p>
<h2 id="微服务权限方案"><a href="#微服务权限方案" class="headerlink" title="微服务权限方案"></a>微服务权限方案</h2><ol>
<li><p>继承UsernamePasswordAuthenticationFilter类, 重写attemptAuthentication()认证逻辑, (保存token储存的权限信息)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span> <span class="keyword">extends</span> <span class="title">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="keyword">private</span> TokenManager tokenManager;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginFilter</span><span class="params">(AuthenticationManager authenticationManager, TokenManager tokenManager)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authenticationManager = authenticationManager;</span><br><span class="line">        <span class="keyword">this</span>.tokenManager = tokenManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//认证token</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(request.getParameter(<span class="string">&quot;username&quot;</span>), request.getParameter(<span class="string">&quot;password&quot;</span>), <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            <span class="keyword">return</span> authenticationManager.authenticate(<span class="keyword">new</span> UsernamePasswordAuthenticationToken(user.getUsername(),user.getPassword(),user.getAuthorities()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//认证成功 生成token</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">successfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        User user = (User) authResult.getPrincipal();</span><br><span class="line">        String token = tokenManager.createToken(user.getUsername());</span><br><span class="line">		...保存token...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//认证失败</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">unsuccessfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;认证失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承BasicAuthenticationFilter类, 重写doFilterInternal过滤逻辑 , (监控token)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthFilter</span> <span class="keyword">extends</span> <span class="title">BasicAuthenticationFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TokenManager tokenManager;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthFilter</span><span class="params">(AuthenticationManager authenticationManager, TokenManager tokenManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(authenticationManager);</span><br><span class="line">        <span class="keyword">this</span>.tokenManager = tokenManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前认证成功用户权限信息</span></span><br><span class="line">        UsernamePasswordAuthenticationToken authRequest = getAuthentication(request);</span><br><span class="line">        <span class="comment">//判断如果有权限信息，放到权限上下文中</span></span><br><span class="line">        <span class="keyword">if</span>(authRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authRequest);</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> UsernamePasswordAuthenticationToken <span class="title">getAuthentication</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从header获取token</span></span><br><span class="line">        String token = request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(token != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//从token获取用户名</span></span><br><span class="line">            String username = tokenManager.getUserInfoFromToken(token);</span><br><span class="line">            <span class="comment">//从redis获取对应权限列表</span></span><br><span class="line">            List&lt;String&gt; permissionValueList = getTokenByUsername();</span><br><span class="line">            Collection&lt;GrantedAuthority&gt; authority = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(String permissionValue : permissionValueList) &#123;</span><br><span class="line">                SimpleGrantedAuthority auth = <span class="keyword">new</span> SimpleGrantedAuthority(permissionValue);</span><br><span class="line">                authority.add(auth);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UsernamePasswordAuthenticationToken(username,token,authority);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>Session共享的实现</title>
    <url>/2020/12/01/Session%E5%85%B1%E4%BA%AB%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="Session共享"><a href="#Session共享" class="headerlink" title="Session共享"></a>Session共享</h3><p> Session 共享是指在一个浏览器访问多个 Web 服务时，服务端的 Session 数据需要共享。</p>
<a id="more"></a>

<h4 id="cookie加密的方式保存在客户端"><a href="#cookie加密的方式保存在客户端" class="headerlink" title="cookie加密的方式保存在客户端"></a>cookie加密的方式保存在客户端</h4><ul>
<li><p>优点：减轻服务器端压力</p>
</li>
<li><p>缺点：受到cookie大小限制，因为每次请求会在头部附带cookie信息，占用一定的带宽。另外，这种方式在用户禁用cookie的情况下无效。这种方式不常用。</p>
</li>
</ul>
<h4 id="服务器间同步"><a href="#服务器间同步" class="headerlink" title="服务器间同步"></a>服务器间同步</h4><p>服务器间同步比如tomcat集群：通过配置tomcat，实现session共享。每个tomcat都会在局域网中广播自己的session信息，同时监听其他tomcat广播的session，一旦自己的session发生变化，其他的tomcat能够感知到的，同时就可以同步自己的session和它一样。</p>
<ul>
<li>缺点：当集群服务器数量比较大如200台，每一台服务器的tomcat都需要广播自己的session，同时监听另外199台，此时，服务器的大量资源都用来处理session同步的事情，用户正常的访问就会受到影响。要视部署的tomcat集群数量等来定是否使用这种方式。</li>
</ul>
<h4 id="基于分布式缓存"><a href="#基于分布式缓存" class="headerlink" title="基于分布式缓存"></a>基于分布式缓存</h4><p>基于分布式缓存的session共享机制</p>
<p>使用redis取代session保存用户信息，这种方式比较常用</p>
<h3 id="SpringSession"><a href="#SpringSession" class="headerlink" title="SpringSession"></a>SpringSession</h3><p>Spring Session 是 Spring 的项目之一。Spring Session 提供了一套创建和管理 Servlet HttpSession 的方案，默认采用外置的 Redis 来存储 Session 数据，以此来解决 Session 共享的 问题。</p>
<h4 id="基本实现原理"><a href="#基本实现原理" class="headerlink" title="基本实现原理"></a>基本实现原理</h4><p>SpringSession从底层全方位”接管”了Tomcat对Session的管理</p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201201155030.png" alt="SpringSession基本实现原理"></p>
<h5 id="SessionRepositoryFilter"><a href="#SessionRepositoryFilter" class="headerlink" title="SessionRepositoryFilter"></a>SessionRepositoryFilter</h5><p>利用Filter原理,在每次请求到达目标方法之前,将原生HttpSetvletRequest / HttpSetvletResponse对象包装为SessionRepository / ResponseWrapper </p>
]]></content>
  </entry>
  <entry>
    <title>git&amp;Linux基本命令</title>
    <url>/2020/11/07/git-Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>git和Linux的一些基本命令操作</p>
<a id="more"></a>

<h5 id="git"><a href="#git" class="headerlink" title="git"></a>git</h5><h6 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Your Name&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;wrote a readme file&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff readme.txt </span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span>		$ git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard 1094a</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure>



<h6 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin https://.....($ git remote add origin git@github.com:michaelliao/learngit.git)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin(远程仓库名) master(本地分支名) master(远程分支名)  (-u首次建立关联)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@github.com:michaelliao/gitskills.git</span></span><br><span class="line">git remote rm origin</span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin  master(本地分支名) master(远程分支名)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream-to=origin/dev dev（绑定本地分支）</span></span><br></pre></td></tr></table></figure>

<h6 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dev（$ git switch -c dev）===</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev（$ git switch master）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d dev（not merge  -D）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase（直线提交历史）</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">git stash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash list</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br><span class="line"><span class="meta">$</span><span class="bash">git stash apply(恢复不删除)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick 4c805e2</span></span><br></pre></td></tr></table></figure>

<h6 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag v0.9 [f52c633]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [标签名]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show v0.9</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v0.9		删除标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin v1.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags	推送所有标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/v0.9</span></span><br></pre></td></tr></table></figure>

<h6 id="多关联"><a href="#多关联" class="headerlink" title="多关联"></a>多关联</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add github git@github.com:michaelliao/learngit.git</span><br><span class="line">git remote add gitee git@gitee.com:liaoxuefeng/learngit.git</span><br><span class="line">git push github master</span><br><span class="line">git push gitee master</span><br></pre></td></tr></table></figure>

<h6 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.co checkout</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.ci commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.br branch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><h6 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls: 列出目录	</span><br><span class="line">cd：切换目录	(Change Directory)</span><br><span class="line">pwd：显示目前的目录	(Print Working Directory)</span><br><span class="line">mkdir：创建一个新的目录	 (make directory)</span><br><span class="line">rmdir：删除一个空的目录</span><br><span class="line">cp: 复制文件或目录</span><br><span class="line">rm: 移除文件或目录</span><br><span class="line">mv: 移动文件与目录，或修改文件与目录的名称</span><br><span class="line">dhclient 自动分配地址[BOOTPROTO&#x3D;STATIC	ONBOOT&#x3D;YES	</span><br><span class="line">IPADDR&#x3D;192.168.XX.XXX	NETMASK&#x3D;255.255.255.0 	GATEWAY&#x3D;192.168.XX.X</span><br><span class="line">DNS1&#x3D;119.29.29.29]</span><br></pre></td></tr></table></figure>

<h6 id="用户-组管理"><a href="#用户-组管理" class="headerlink" title="用户/组管理"></a>用户/组管理</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd [user]	useradd [-g]  组名 [user]</span><br><span class="line">passwd [user] </span><br><span class="line">userdel [-r] [user]</span><br><span class="line">id [user]</span><br><span class="line">su [user]</span><br><span class="line"></span><br><span class="line">groupadd [group]</span><br><span class="line">groupdel [group]</span><br><span class="line">gpasswd  -d student root 将用户student从root组删除</span><br><span class="line">usermod [-g] 组名 [user]</span><br></pre></td></tr></table></figure>

<h6 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat [dir] | grep [..]</span><br><span class="line">ls -l /home |grep &quot;!-&quot;|wc -l 查看某文件夹下文件的个数</span><br><span class="line">stat [file]</span><br><span class="line"></span><br><span class="line">[ls,cat,echo...] &gt;&gt;追加</span><br><span class="line">[ls,cat,echo...] &gt;覆盖</span><br><span class="line"></span><br><span class="line">head/tail -n [num] [file]     		tail -f [file]</span><br><span class="line"></span><br><span class="line">ln -s [dir] [name] </span><br><span class="line"></span><br><span class="line">date &quot;+%Y %M %D.....&quot;</span><br><span class="line">cal</span><br><span class="line"></span><br><span class="line">find [scope] -name [name]</span><br><span class="line">find [scope] -user [user]</span><br><span class="line">find [scope] -size  [+-n]</span><br><span class="line"></span><br><span class="line">tar -zcvf [name].tar.gz [files] 打包</span><br><span class="line">tar -zxvf [files] -C [dir] 解压</span><br><span class="line"></span><br><span class="line">rpm [-qa | -qi | qf]</span><br><span class="line">rpm -e [--nodeps(强删)] [name]</span><br><span class="line">rpm -ivh		i=install  v=verbose提示  h=hash进度条</span><br></pre></td></tr></table></figure>

<h6 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown/chgrp [user/group] [file]</span><br><span class="line">chmod u=[rwx],g=[rwx],o=[rwx] [file]</span><br><span class="line">chmod u[+-][rwx],g[+-][rwx],o[+-][rwx] [file]</span><br><span class="line">chomd [777] [file]     (4=r,2=w,1=x)</span><br></pre></td></tr></table></figure>

<h6 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab [-e -l -r]  ([写入 查看 删除])</span><br><span class="line">*/1 * * * * [执行文件/脚本] </span><br></pre></td></tr></table></figure>

<h6 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h</span><br><span class="line">du -axh	文件夹占用</span><br><span class="line">lsblk -f  	查看是否已分配</span><br><span class="line">fdisk /dev/dba	分区</span><br><span class="line">mkfs -t ext4 /dev/sdb1   格式化</span><br><span class="line">mount  /dev/sdb1   /home/newdisk	挂载</span><br><span class="line">/dev/fstab  设置开机自动挂载</span><br></pre></td></tr></table></figure>

<h6 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -aux | grep ...</span><br><span class="line">ps -ef 		-e显示所有进程 -f全格式</span><br><span class="line">kill [-9] 进程号	-9强制</span><br><span class="line">killall 进程名称</span><br><span class="line">top [-d | -i | -p]	-d秒数 -i不显示闲置或僵死 -p指定进程id监控</span><br></pre></td></tr></table></figure>

<h6 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl [status | stop | start | restart | reload ]firewalld</span><br><span class="line">ll /etc/init.d/	</span><br><span class="line">netstat -anp 	-an按一定顺序 -p显示哪个在调用   查看网络服务</span><br></pre></td></tr></table></figure>

<h6 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h6><pre><code>  #!/bin/bash开头
  A=100;
  unset A ---&gt;A=
位置参数变量
$n    第n个参数
$*    整体
$@    分别
$#    参数个数
=====================</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">预定义变量</span><br><span class="line"><span class="meta">$</span><span class="bash">$	当前进程PID</span></span><br><span class="line"><span class="meta">$</span><span class="bash">!	后台运行最后一个PID</span></span><br><span class="line"><span class="meta">$</span><span class="bash">?	最后一次命名的返回状态 0√</span></span><br><span class="line">========================</span><br><span class="line"></span><br><span class="line">运算(2+3)*4</span><br><span class="line"><span class="meta">#</span><span class="bash">方式一$()</span></span><br><span class="line">RESULT1=$(((2+3)*4))</span><br><span class="line"><span class="meta">#</span><span class="bash">方式二$[]  推荐方式</span></span><br><span class="line">RESULT2=$[(2+3)*4]</span><br><span class="line"><span class="meta">#</span><span class="bash">方式三 expr</span></span><br><span class="line">................</span><br><span class="line">==========================</span><br><span class="line">条件判断</span><br><span class="line">if[ condition ] </span><br><span class="line">then</span><br><span class="line">	echo&quot;&quot;</span><br><span class="line">elif[ condirion ] </span><br><span class="line">	echo&quot;&quot;</span><br><span class="line">fi</span><br><span class="line"> -lt小于 -le小于等于  -gt大于 -ge大于等于  -eq等于 -ne不等于</span><br><span class="line">-r/-w/-x 有读/写/执行的权限</span><br><span class="line">-f文件存在并且时一个常规文件 -e文件存在 -d文件存在并是目录</span><br><span class="line">------------------------</span><br><span class="line">case $变量名 in</span><br><span class="line">&quot;值1&quot;)</span><br><span class="line">echo&quot;1&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;值2&quot;)</span><br><span class="line">echo&quot;2&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo&quot;other&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">循环</span><br><span class="line">for 变量 in 值1 值2 值3...</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done </span><br><span class="line">-------------------------</span><br><span class="line">for ((i=0;i&lt;100;i++))</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done </span><br><span class="line">--------------------------</span><br><span class="line">while[ condition ]</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done </span><br><span class="line">===============</span><br><span class="line"></span><br><span class="line">read读取控制台输入</span><br><span class="line">read -p  &quot;读取时的提示符&quot; -t指定读取时等待的时间(秒)	NUM</span><br><span class="line"></span><br><span class="line">================</span><br><span class="line">函数</span><br><span class="line">function getSum()&#123;</span><br><span class="line">	SUM=$[$n1+$n2]</span><br><span class="line">&#125;</span><br><span class="line">read -p &quot;输入n1&quot; n1</span><br><span class="line">read -p &quot;输入n2&quot; n2</span><br><span class="line"><span class="meta">#</span><span class="bash">调用</span></span><br><span class="line">getSum $n1 $n2</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud-netflix使用</title>
    <url>/2020/11/23/spring-cloud-netflix%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="SpringCloud简介"><a href="#SpringCloud简介" class="headerlink" title="SpringCloud简介"></a>SpringCloud简介</h3><p>springCloud是基于SpringBoot的一整套实现微服务的框架。他提供了微服务开发所需的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等组件。</p>
<a id="more"></a>

<h3 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h3><p>Eureka: 服务注册和发现组件<br>Ribbon: 负载均衡<br>Feign: 远程接口的声明式调用<br>Hystrix: 服务的熔断,降级,监控<br><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201120150542.png"></p>
<h4 id="Eureka-注册"><a href="#Eureka-注册" class="headerlink" title="Eureka(注册)"></a>Eureka(注册)</h4><ul>
<li>服务端配置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span>     <span class="comment">#配置当前Eureka服务的主机地址</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span>     <span class="comment">#当前服务本身就是注册中心,不用注册自己</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span>           <span class="comment">#不用从注册中心取回信息</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;/$&#123;server.port&#125;/eureka</span> <span class="comment">#设置与Eureka交互的地址查询服务和注册服务</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span><span class="comment">//开启服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaMainType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaMainType.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端配置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:5000/eureka</span>  <span class="comment">#Eureka服务地址</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">  	<span class="attr">instance-id:</span> <span class="string">xxx</span>		<span class="comment">#修改服务名称</span></span><br><span class="line">  	<span class="attr">prefer-ip-address:</span> <span class="literal">true</span>		<span class="comment">#访问路径显示ip地址</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">xxx</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderMainType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ProviderMainType.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Ribbon-负载均衡"><a href="#Ribbon-负载均衡" class="headerlink" title="Ribbon(负载均衡)"></a>Ribbon(负载均衡)</h4><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//让RestTemplate具有负载均衡的功能,通过Ribbon访问provider集群</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Feign-声明式调用"><a href="#Feign-声明式调用" class="headerlink" title="Feign(声明式调用)"></a>Feign(声明式调用)</h4><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CosumerMainType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(CosumerMainType.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Feigin依赖有Ribbon, 不需要配置Ribbon</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201120150725105.png" alt="Feign(声明式调用)"></p>
<p>@FeignClient注解</p>
<p>value:</p>
<ul>
<li>表示当前接口和一个Provider对应,注解中value属性指定要用的Provider的微服务名称</li>
<li>要求@RequestMapping注解映射的地址一致</li>
<li>要求方法声明一致</li>
<li>用来获取请求参数的@RequstParam, @PathVariable, @RequestBody不能省略, 两边一致</li>
</ul>
<p>fallbackFactory:</p>
<ul>
<li>指定Provider不可用时提供的备用方案的工厂类型</li>
</ul>
<p>@EnableFeignClients</p>
<ul>
<li>启用Feign客户端功能</li>
</ul>
<h4 id="Hystrix-熔断-降级-监控"><a href="#Hystrix-熔断-降级-监控" class="headerlink" title="Hystrix(熔断,降级,监控)"></a>Hystrix(熔断,降级,监控)</h4><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="熔断-Provider"><a href="#熔断-Provider" class="headerlink" title="熔断(Provider)"></a>熔断(Provider)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定当前方法出问题时调用的方法</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;MethodName)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span>	<span class="comment">//开启熔断支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderMainType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ProviderMainType.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="降级-Consumer"><a href="#降级-Consumer" class="headerlink" title="降级(Consumer)"></a>降级(Consumer)</h5><ul>
<li>实现Consumer端服务降级功能</li>
<li>实现FallbackFactory接口要传入@FeignClient标记的接口类型</li>
<li>在create()方法中返回@FeignClient注解标记的接口类型的对象,当Provider调用失败后,会执行这个对象对应的方法</li>
<li>使用@Component将当前对象加入IOC容器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>	<span class="comment">//大坑	</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFallBackFactory</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">EmployeeRemoteService</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EmployeeRemoteService <span class="title">create</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmployeeRemoteService() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            .....</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启用</p>
<p>在Consumer的配置文件中启用</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h5 id="监控-Provier"><a href="#监控-Provier" class="headerlink" title="监控(Provier)"></a>监控(Provier)</h5><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">hystrix.stream</span></span><br></pre></td></tr></table></figure>

<p>启动类上加@EnableHystrixDashboard注解启动仪表盘功能</p>
<h4 id="Zuul-网关"><a href="#Zuul-网关" class="headerlink" title="Zuul(网关)"></a>Zuul(网关)</h4><p>添加依赖并使用@EnableZuulProxy开启</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">prefix</span>: <span class="string">/prefix</span></span><br><span class="line">  <span class="meta">ignored-services</span>: <span class="string">微服务名称/&quot;*&quot;</span></span><br><span class="line">  <span class="attr">routes</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">mydept.serviceId</span>: <span class="string">微服务名称</span></span><br><span class="line">    <span class="meta">mydept.path</span>: <span class="string">/mydept/**		//映射</span></span><br></pre></td></tr></table></figure>



<p>访问: <span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMTp6dXVs56uv5Y+j">http://127.0.0.1:zuul端口<i class="fa fa-external-link-alt"></i></span> / 微服务名称 / 具体功能地址</p>
<p><strong>ZuulFilter过滤类</strong></p>
<p><code>shouldFilter</code>：返回一个boolean类型来判断该过滤器是否要执行，所以通过此函数可实现过滤器的开关。</p>
<p><code>filterType</code>：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：</p>
<ul>
<li><code>pre</code>：可以在请求被路由之前调用</li>
<li><code>route</code>：在路由请求时候被调用</li>
<li><code>post</code>：在route和error过滤器之后被调用</li>
<li><code>error</code>：处理请求时发生错误时被调用</li>
</ul>
<p><code>filterOrder</code>：通过int值来定义过滤器的执行顺序</p>
<p><code>run</code>：过滤器的具体实现功能。</p>
<h4 id="SpringCloud-Config"><a href="#SpringCloud-Config" class="headerlink" title="SpringCloud Config"></a>SpringCloud Config</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#Server端</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>: <span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">xx</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">git</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">uri</span>: <span class="string">git@github.com:/xxxx/git		#git配置文件仓库</span></span><br><span class="line">          </span><br><span class="line"><span class="comment">#==============================================================</span></span><br><span class="line"><span class="comment">#Client端 </span></span><br><span class="line"><span class="comment">#创建bootstrap.yml 系统级配置文件</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">xxxx</span></span><br><span class="line">      <span class="attr">profile</span>: <span class="string">dev</span></span><br><span class="line">      <span class="attr">lable</span>: <span class="string">master</span></span><br><span class="line">      <span class="attr">uri</span>: <span class="string">http://config.com	#SpringCloud Config服务的地址 </span></span><br><span class="line">      </span><br><span class="line"><span class="comment">#创建application.yml 系统级配置文件</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">xxxx		#名字一致</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigServer</span></span><br></pre></td></tr></table></figure>



<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h5 id="fallback-method-wasn’t-found"><a href="#fallback-method-wasn’t-found" class="headerlink" title="fallback method wasn’t found"></a>fallback method wasn’t found</h5><p> 备用方法 和 原方法 的参数类型，个数不同造成的</p>
<h5 id="Unable-to-connect-to-Command-Metric-Stream"><a href="#Unable-to-connect-to-Command-Metric-Stream" class="headerlink" title="Unable to connect to Command Metric Stream."></a>Unable to connect to Command Metric Stream.</h5><p>dashboard无法显示,控制台显示<span class="exturl" data-url="aHR0cDovL3h4eC54eHgueHg6eHh4L2h5c3RyaXguc3RyZWFt">http://xxx.xxx.xx:xxx/hystrix.stream<i class="fa fa-external-link-alt"></i></span> is not in the allowed list of proxy host names.  If it should be allowed add it to hystrix.dashboard.proxyStreamAllowList. </p>
<p>解决: 配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">dashboard:</span></span><br><span class="line">    <span class="attr">proxy-stream-allow-list:</span> <span class="string">&quot;localhost&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>十大常用算法</title>
    <url>/2021/08/30/%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="二分查找（非递归）"><a href="#二分查找（非递归）" class="headerlink" title="二分查找（非递归）"></a>二分查找（非递归）</h4><a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(left &lt;= right) &#123; <span class="comment">//说明继续查找</span></span><br><span class="line">      <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(arr[mid] == target) &#123;</span><br><span class="line">         <span class="keyword">return</span> mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( arr[mid] &gt; target) &#123;</span><br><span class="line">         right = mid - <span class="number">1</span>;<span class="comment">//需要向左边查找</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         left = mid + <span class="number">1</span>; <span class="comment">//需要向右边查找</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h4><blockquote>
<p>在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)，汉诺塔……</p>
</blockquote>
<p>分治法在每一层递归上都有三个步骤：</p>
<ol>
<li>分解：将原问题分解为若千个规模较小，相互独立，与原问题形式相同的子问题</li>
<li>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li>
<li>合并：将各个子问题的解合并为原问题的解。</li>
</ol>
<p>分治算法设计模式：<br> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> |P|≤n0</span><br><span class="line"><span class="function">then <span class="title">return</span><span class="params">(ADHOC(P))</span>  <span class="comment">//将P分解为较小的子问题 P1 ,P2 ,...,Pk</span></span></span><br><span class="line">for i←1 to k</span><br><span class="line"><span class="keyword">do</span> yi ← Divide-<span class="keyword">and</span>-Conquer(Pi) △ 递归解决Pi</span><br><span class="line">T ← MERGE(y1,y2,...,yk) △ 合并子问题</span><br><span class="line"><span class="keyword">return</span>(T)</span><br></pre></td></tr></table></figure></p>
<p>   汉诺塔算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoiTower</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">char</span> a, <span class="keyword">char</span> b, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//如果只有一个盘</span></span><br><span class="line">   <span class="keyword">if</span>(num == <span class="number">1</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;第1个盘从 &quot;</span> + a + <span class="string">&quot;-&gt;&quot;</span> + c);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果我们有 n &gt;= 2 情况，总是可以看做是两个盘 1.最下边的一个盘  2. 上面的所有盘</span></span><br><span class="line">      <span class="comment">//1. 先把 最上面的所有盘 A-&gt;B， 移动过程会使用到 c</span></span><br><span class="line">      hanoiTower(num - <span class="number">1</span>, a, c, b);</span><br><span class="line">      <span class="comment">//2. 把最下边的盘 A-&gt;C</span></span><br><span class="line">      System.out.println(<span class="string">&quot;第&quot;</span> + num + <span class="string">&quot;个盘从 &quot;</span> + a + <span class="string">&quot;-&gt;&quot;</span> + c);</span><br><span class="line">      <span class="comment">//3. 把B塔的所有盘 从 B-&gt;C , 移动过程使用到 a塔  </span></span><br><span class="line">      hanoiTower(num - <span class="number">1</span>, b, a, c);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态规划算法-Dynamic-Programming"><a href="#动态规划算法-Dynamic-Programming" class="headerlink" title="动态规划算法(Dynamic Programming)"></a>动态规划算法(Dynamic Programming)</h4><blockquote>
<p><strong>动态规划</strong>（Dynamic Programming，DP）是运筹学的一个分支，是求解<strong>决策过程</strong>最优化的过程。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果。</p>
</blockquote>
<ol>
<li>动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法</li>
<li>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若千个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li>
<li>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。(即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解)</li>
<li>动态规划可以通过填表的方式来逐步推进，得到最优解.</li>
</ol>
<p>背包问题思路分析：</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192004115.png" alt="img"></p>
<p>每次遍历到的第i个物品，根据 w[i] 和 v[i] 来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，j为背包的容量。再令 v[i] [j] 表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)v[i][<span class="number">0</span>]=v[<span class="number">0</span>][j]=<span class="number">0</span>;	<span class="comment">//表示填入表第一行和第一列是0</span></span><br><span class="line">(<span class="number">2</span>)当w[i]&gt;j时: v[i][j]=v[i-<span class="number">1</span>][j]	<span class="comment">//当准备加入新增的商品的重量大于当前背包的容量时，就直接使用上一个单元格的装入策略</span></span><br><span class="line">(<span class="number">3</span>)当j&gt;=w[i]时: v[i][j]=max&#123;v[i-<span class="number">1</span>][j], v[i]+v[i-<span class="number">1</span>][j-w[i]]&#125;	<span class="comment">//当准备加入的新增的商品的容量小于等于当前背包的容量时</span></span><br><span class="line"><span class="comment">//v[i-1][j]：就是上面一个单元格（商品）的装入的最大价值</span></span><br><span class="line"><span class="comment">//v[i]:表示当前商品的价值</span></span><br><span class="line"><span class="comment">//v[i-1][j-w[i]]:	v[i-1]上面一个商品，[j-w[i]]	背包容量减去当前商品重量---》剩余容量装入上一个商品的价值</span></span><br></pre></td></tr></table></figure>

<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><blockquote>
<p>　　KMP 算法（Knuth-Morris-Pratt 算法）是一个著名的字符串匹配算法,是 Knuth、Morris 和 Pratt 共同提出的，称之为 Knuth-Morria-Pratt 算法，简称 KMP 算法。该算法相对于 Brute-Force（暴力）算法有比较大的改进，主要是消除了主串指针的回溯，从而    使算法效率有了某种程度的提高。</p>
<p>　字符串匹配问题：两个字符串 str1，str2，判断str1是否含有str2，如果存在，返回第一次出现的位置</p>
</blockquote>
<p>暴力匹配算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力匹配（伪码）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(String pat, String txt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = pat.length;</span><br><span class="line">    <span class="keyword">int</span> N = txt.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N - M; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pat[j] != txt[i+j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pat 全都匹配了</span></span><br><span class="line">        <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// txt 中不存在 pat 子串</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KMP算法：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIxOTIzMDIxL2Fuc3dlci8yODEzNDY3NDY=">KMP算法详解<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li>KMP算法的核心，是一个被称为部分匹配表(Partial Match Table)的数组。PMT中的值是字符串的前缀集合与后缀集合的<strong>交集</strong>中最长元素的长度。</li>
<li>如果是在 j 位 失配，那么影响 j 指针回溯的位置的其实是第 j 位的 PMT 值-1，为了编程的方便， 我们不直接使用PMT数组，而是将PMT数组向后偏移一位得到next数组。</li>
</ol>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192005260.jpeg" alt="img"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于计算匹配的位置（从头到尾）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str 主串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sub 模式串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String str, String sub)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span>[] next = getNext(sub);</span><br><span class="line">   <span class="keyword">while</span> (i &lt; str.length() &amp;&amp; j &lt; sub.length())&#123;</span><br><span class="line">      <span class="keyword">if</span>(j == -<span class="number">1</span> || str.charAt(i) == sub.charAt(j))&#123;<span class="comment">//j==-1时说明第一位不匹配 直接++匹配后面</span></span><br><span class="line">         i++;</span><br><span class="line">         j++;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         j = next[j];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(j == sub.length())</span><br><span class="line">      <span class="keyword">return</span> i-j;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于生成部分匹配表next</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sub 模式串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(String sub) &#123;</span><br><span class="line">   <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[sub.length()+<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>, j = -<span class="number">1</span>;</span><br><span class="line">   next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;sub.length())&#123;</span><br><span class="line">      <span class="keyword">if</span> (j==-<span class="number">1</span> || sub.charAt(i) == sub.charAt(j))&#123;</span><br><span class="line">         next[++i] = ++j;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         j = next[j];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><blockquote>
<ol>
<li>贪心算法，又称贪婪算法(Greedy Algorithm)，是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优解出发来考虑，它所做出的仅是在某种意义上的局部最优解。</li>
<li>贪婪算法是一种分阶段的工作，在每一个阶段，可以认为所做决定是最好的，而不考虑将来的后果。这种“眼下能够拿到的就拿”的策略是这类算法名称的来源。</li>
<li>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</li>
</ol>
</blockquote>
<h4 id="普利姆算法（Prim）"><a href="#普利姆算法（Prim）" class="headerlink" title="普利姆算法（Prim）"></a>普利姆算法（Prim）</h4><blockquote>
<p>普利姆(Prim)算法求<strong>最小生成树</strong>——即树中所有边的权值之和最小，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的<strong>极小连通子图</strong>。</p>
<p>生活中最小生成树的应用十分广泛，比如：要连通n个城市需要n－1条边线路，怎么样建设才能使工程造价最小？可以把线路的造价看成权值求这几个城市的连通图的最小生成树。求最小造价的过程也就转化成求最小生成树的过程，则最小生成树表示使其造价最小的生成树。</p>
<p><strong>每次选择最优解</strong></p>
</blockquote>
<p>修路问题：</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192008299.png" alt="img"></p>
<ol>
<li><p>从&lt; A &gt;顶点开始处理====&gt;&lt;A,G&gt;</p>
<p>A-C[7]    <strong>A-G[2]</strong>    A-B[5]</p>
</li>
<li><p>&lt;A,G&gt;开始,将A和G顶点和他们相邻的还没有访问的顶点进行处理====&gt;&lt;A,G,B&gt;</p>
<p>A-C[7]    A-B[5]    <strong>G-B[3]</strong>    G-E[4]    G-F[6]</p>
</li>
<li><p>&lt;A,G,B&gt;开始，将A,G,B顶点和他们相邻的还没有访问的顶点进行处理====&gt;&lt;A,G,B,E&gt;</p>
<p>A-C[7]    <strong>G-E[4]</strong>    G-F[6]    B-D[9]</p>
<p>…….</p>
</li>
</ol>
<p>代码实现：</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210825173950827.png" alt="image-20210825173950827"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prim</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 参数G：给定的图，其顶点分别为0~G.length-1，相应权值为具体元素的值</span></span><br><span class="line"><span class="comment">    * 函数功能：返回构造生成的最小生成树，以二维数组形式表示，其中元素为0表示最小生成树的边</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMinTree</span><span class="params">(<span class="keyword">int</span>[][] G)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[][] result = G;</span><br><span class="line">      <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[G.length];   <span class="comment">//记录顶点是否被访问，如果已被访问，则置相应顶点的元素值为-2</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.length;i++)</span><br><span class="line">         visited[i] = i;</span><br><span class="line">      ArrayList&lt;Integer&gt; listV = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">//保存已经遍历过的顶点</span></span><br><span class="line">      listV.add(<span class="number">0</span>);      <span class="comment">//初始随意选择一个顶点作为起始点，此处选择顶点0，记录访问顺序</span></span><br><span class="line">      visited[<span class="number">0</span>] = -<span class="number">2</span>;    <span class="comment">//表示顶点0被访问</span></span><br><span class="line">      <span class="keyword">while</span>(listV.size() &lt; G.length) &#123;  <span class="comment">//当已被遍历的顶点数等于给定顶点数时，退出循环</span></span><br><span class="line">         <span class="keyword">int</span> minDistance = Integer.MAX_VALUE;    <span class="comment">//用于寻找最小权值，初始化为int最大值，相当于无穷大的意思</span></span><br><span class="line">         <span class="keyword">int</span> minV = -<span class="number">1</span>;   <span class="comment">//用于存放未被遍历的顶点中与已被遍历顶点有最小权值的顶点</span></span><br><span class="line">         <span class="keyword">int</span> minI = -<span class="number">1</span>;   <span class="comment">//用于存放已被遍历的顶点与未被遍历顶点有最小权值的顶点  ；即G[minI][minV]在剩余的权值中最小</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; listV.size();i++) &#123;   <span class="comment">//i 表示已被访问的顶点</span></span><br><span class="line">            <span class="keyword">int</span> v1 = listV.get(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; G.length;j++) &#123;</span><br><span class="line">               <span class="keyword">if</span>(visited[j] != -<span class="number">2</span>) &#123;    <span class="comment">//满足此条件的表示，顶点j未被访问</span></span><br><span class="line">                  <span class="keyword">if</span>(G[v1][j] != -<span class="number">1</span> &amp;&amp; G[v1][j] &lt; minDistance) &#123;<span class="comment">//G[v1][j]值为-1表示v1和j不是相邻顶点</span></span><br><span class="line">                     minDistance = G[v1][j];</span><br><span class="line">                     minV = j;</span><br><span class="line">                     minI = v1;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         visited[minV] = -<span class="number">2</span>;       <span class="comment">//将j节点记入被访问顶点</span></span><br><span class="line">         listV.add(minV);      <span class="comment">//计入访问顺序</span></span><br><span class="line">         result[minI][minV] = <span class="number">0</span>;</span><br><span class="line">         result[minV][minI] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;使用Prim算法，对于给定图中的顶点访问顺序为：&quot;</span>);</span><br><span class="line">      System.out.println(listV);</span><br><span class="line">      System.out.println(<span class="string">&quot;使用Prim算法，构造的最小生成树的二维数组表示如下（PS：元素为0表示连通的边）：&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; result.length;i++) &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; result[<span class="number">0</span>].length;j++)</span><br><span class="line">            System.out.print(result[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">         System.out.println();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Prim test = <span class="keyword">new</span> Prim();</span><br><span class="line">      <span class="keyword">int</span>[][] G = &#123;&#123;-<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">4</span>&#125;,</span><br><span class="line">            &#123;-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">6</span>,-<span class="number">1</span>,<span class="number">4</span>&#125;,</span><br><span class="line">            &#123;-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">6</span>,-<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">6</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">8</span>,-<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">      test.getMinTree(G);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="克鲁斯卡尔（Kruskal）"><a href="#克鲁斯卡尔（Kruskal）" class="headerlink" title="克鲁斯卡尔（Kruskal）"></a>克鲁斯卡尔（Kruskal）</h4><blockquote>
<p>Kruskal是另一个计算最小生成树的算法，从给定加权连通图中，将所有边的权值进行排序，选择当前未被选择的，<strong>不能形成回路</strong>且权值最小的边，加入到当前正在构造的最小生成树中。</p>
<p>使用<strong>并查算法</strong>实现检查回环问题：</p>
<p>并查集是一种树型的数据结构，用于处理一些不相交集合（disjoint sets）的合并及查询问题。常常在使用中以森林来表示。</p>
<p>主要作用：检查图中是否存在一个环</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192009480.png" alt="202108261634246"></p>
</blockquote>
<p>代码实现： <img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192009883.png" alt="20210826163446"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kruskal</span> </span>&#123;</span><br><span class="line">    <span class="comment">//内部类，其对象表示连通图中一条边</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> a;   <span class="comment">// 开始顶点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> b;   <span class="comment">//结束顶点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;   <span class="comment">//权值</span></span><br><span class="line">        </span><br><span class="line">        edge(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">            <span class="keyword">this</span>.b = b;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) id[i] = -<span class="number">1</span>;  <span class="comment">//初始化id(x)，令所有顶点的id值为-1，即表示为根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取节点a的根节点编号 []id：记录父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] id, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, root, k;</span><br><span class="line">        root = a;</span><br><span class="line">        <span class="keyword">while</span>(id[root] &gt;= <span class="number">0</span>) root = id[root];  <span class="comment">//一直往上查到当前节点的根节点，</span></span><br><span class="line">        k = a;</span><br><span class="line">        <span class="keyword">while</span>(k != root) &#123;  <span class="comment">//（当前节点不是根节点）</span></span><br><span class="line">            i = id[k];	<span class="comment">// 当前节点的父节点</span></span><br><span class="line">            id[k] = root;	<span class="comment">//设置[]id中当前节点的父节点为root</span></span><br><span class="line">            k = i;	<span class="comment">//循环将a节点所在树的所有节点，都变成root的直接子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//并查集算法（检查图中是否存在一个环）</span></span><br><span class="line">    <span class="comment">//判断顶点a和顶点b的根节点大小，根节点值越小，代表其对应树的节点越多，将节点少的树的根节点作为节点多的树的根节点的直接子节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] id, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ida = find(id, a);   <span class="comment">//得到顶点a的根节点</span></span><br><span class="line">        <span class="keyword">int</span> idb = find(id, b);   <span class="comment">//得到顶点b的根节点</span></span><br><span class="line">        <span class="keyword">int</span> num = id[ida] + id[idb];  <span class="comment">//！！由于根节点值必定小于0，此处num值必定小于零（不懂）</span></span><br><span class="line">        <span class="keyword">if</span>(id[ida] &lt; id[idb]) &#123;</span><br><span class="line">            id[idb] = ida;    <span class="comment">//将顶点b的根节点作为顶点a根节点的直接子节点</span></span><br><span class="line">            id[ida] = num;   <span class="comment">//更新根节点的id值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            id[ida] = idb;    <span class="comment">//将顶点a的根节点作为顶点b根节点的直接子节点</span></span><br><span class="line">            id[idb] = num;    <span class="comment">//更新根节点的id值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Kruskal获取图A的最小生成树</span></span><br><span class="line"><span class="comment">    * 参数n：顶点个数</span></span><br><span class="line"><span class="comment">    * edge[] A: 边对应的顶点和权值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;edge&gt; <span class="title">getMinSpanTree</span><span class="params">(<span class="keyword">int</span> n, edge[] A)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;edge&gt; list = <span class="keyword">new</span> ArrayList&lt;edge&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] id = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) </span><br><span class="line">            id[i] = -<span class="number">1</span>;        <span class="comment">//初始化id(x)，令所有顶点的id值为-1，即表示为根节点</span></span><br><span class="line">        edgeSort(A);   <span class="comment">//使用合并排序，对于图中所有边权值进行从小到大排序</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;		</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = A[i].a;</span><br><span class="line">            <span class="keyword">int</span> b = A[i].b;</span><br><span class="line">            <span class="keyword">int</span> ida = find(id, a - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> idb = find(id, b - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(ida != idb) &#123;</span><br><span class="line">                list.add(A[i]);</span><br><span class="line">                count++;</span><br><span class="line">                union(id, a - <span class="number">1</span>, b - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出每一次添加完一条边后的所有顶点id值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; id.length;j++)</span><br><span class="line">                System.out.print(id[j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(count &gt;= n - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Kruskal test = <span class="keyword">new</span> Kruskal();</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入顶点数a和具体边数p：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> p = in.nextInt();</span><br><span class="line">        edge[] A = <span class="keyword">new</span> edge[p];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入具体边对应的顶点和权值：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; p;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> b = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> value = in.nextInt();</span><br><span class="line">            A[i] = test.<span class="function">new <span class="title">edge</span><span class="params">(a, b, value)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;edge&gt; list = test.getMinSpanTree(n, A);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用Kruskal算法得到的最小生成树具体边和权值分别为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; list.size();i++) &#123;</span><br><span class="line">            System.out.println(list.get(i).a+<span class="string">&quot;——&gt;&quot;</span>+list.get(i).b+<span class="string">&quot;, &quot;</span>+list.get(i).value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迪杰斯特拉（Dijkstra）"><a href="#迪杰斯特拉（Dijkstra）" class="headerlink" title="迪杰斯特拉（Dijkstra）"></a>迪杰斯特拉（Dijkstra）</h4><blockquote>
<p>Dijkstra算法用于构建**<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2hvcnRlc3QtcGF0aF90cmVl">单源点的最短路径树<i class="fa fa-external-link-alt"></i></span>**(MST)——即树中某个点到任何其他点的距离都是最短的。</p>
<p>迪杰斯特拉的主要特点是以起始点为中心向外层层扩展(<strong>广度优先搜索思想</strong>)，直到扩展到终点为止。</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192006374.png" alt="img"></p>
</blockquote>
<p>代码实现: <img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192007547.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 参数adjMatrix:为图的权重矩阵，权值为-1的两个顶点表示不能直接相连</span></span><br><span class="line"><span class="comment">     * 函数功能：返回顶点0到其它所有顶点的最短距离，其中顶点0到顶点0的最短距离为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getShortestPaths(<span class="keyword">int</span>[][] adjMatrix) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[adjMatrix.length];   <span class="comment">//用于存放顶点0到其它顶点的最短距离</span></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[adjMatrix.length];  <span class="comment">//用于判断顶点是否被遍历</span></span><br><span class="line">        used[<span class="number">0</span>] = <span class="keyword">true</span>;  <span class="comment">//表示顶点0已被遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; adjMatrix.length;i++) &#123;</span><br><span class="line">            result[i] = adjMatrix[<span class="number">0</span>][i];	<span class="comment">//从邻接矩阵获取到其他顶点的距离 不相邻是-1</span></span><br><span class="line">            used[i] = <span class="keyword">false</span>;				</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; adjMatrix.length;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;    <span class="comment">//用于暂时存放顶点0到i的最短距离，初始化为Integer型最大值</span></span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; adjMatrix.length;j++) &#123;  <span class="comment">//找到顶点0到 其它顶点 中距离最小的一个顶点</span></span><br><span class="line">                <span class="keyword">if</span>(!used[j] &amp;&amp; result[j] != -<span class="number">1</span> &amp;&amp; min &gt; result[j]) &#123;</span><br><span class="line">                    min = result[j];</span><br><span class="line">                    k = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            used[k] = <span class="keyword">true</span>;    <span class="comment">//将距离最小的顶点，记为已遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; adjMatrix.length;j++) &#123;  <span class="comment">//然后，将顶点0到其它顶点的距离与加入中间顶点k之后的距离进行比较，更新最短距离</span></span><br><span class="line">                <span class="keyword">if</span>(!used[j]) &#123;  <span class="comment">//当顶点j未被遍历时</span></span><br><span class="line">                    <span class="comment">//首先，顶点k到顶点j要能通行；这时，当 顶点0到顶点j的距离 大于 顶点0到k再到j的距离 或者  顶点0无法直接到达顶点j时，更新顶点0到顶点j的最短距离</span></span><br><span class="line">                    <span class="keyword">if</span>(adjMatrix[k][j] != -<span class="number">1</span> &amp;&amp; (result[j] &gt; min + adjMatrix[k][j] || result[j] == -<span class="number">1</span>))</span><br><span class="line">                        result[j] = min + adjMatrix[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dijkstra test = <span class="keyword">new</span> Dijkstra();</span><br><span class="line">        <span class="keyword">int</span>[][] adjMatrix = &#123;&#123;<span class="number">0</span>,<span class="number">6</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">6</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">                &#123;-<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">5</span>&#125;,</span><br><span class="line">                &#123;-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] result = test.getShortestPaths(adjMatrix);</span><br><span class="line">        System.out.println(<span class="string">&quot;顶点0到图中所有顶点之间的最短距离为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; result.length;i++) </span><br><span class="line">            System.out.print(result[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="弗洛伊德（Floyd）"><a href="#弗洛伊德（Floyd）" class="headerlink" title="弗洛伊德（Floyd）"></a>弗洛伊德（Floyd）</h4><h4 id="马踏棋盘算法"><a href="#马踏棋盘算法" class="headerlink" title="马踏棋盘算法"></a>马踏棋盘算法</h4><p>178P</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链学习</title>
    <url>/2022/11/14/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>以太坊、Hyperledger Fabric 和 Corda 的对比</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/640" alt="img"></p>
<ol>
<li>Corda 的用例来自于金融服务行业，这也是 Corda 可见的主要应用领域。</li>
<li>Fabric 设计提供一种模块化、可扩展的架构，可用于从银行、医疗保健到供应链等各个行业。以太坊表现出完全独立于任何特定的应用领域。</li>
<li>与 Fabric 相比，以太坊并未突出模块化，而重在为各种交易和应用提供一个通用平台。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2021/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>数据结构包括：线性结构和非线性结构</p>
<a id="more"></a>

<ul>
<li><p>线性结构</p>
<ol>
<li>线性结构作为最常用的数据结构，其特点是数据元素之间存在<strong>一对一的线性关系</strong>（eg: int a[] =0 ）</li>
<li>线性结构有两种不同的存储结构，即<strong>顺序存储结构(数组)**和</strong>链式存储结构（链表）**</li>
<li>顺序存储的线性表称为<strong>顺序表</strong>，顺序表中存储的元素是连续的；链式存储的线性表称为<strong>链表</strong>，链表中存储的元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息</li>
<li>常见的线性结构：数组、队列、链表和栈</li>
</ol>
</li>
<li><p>非线性结构</p>
<p>非线性结构包括：二位数组、多维数组、广义表、树结构、图结构</p>
</li>
</ul>
<h4 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h4><p>当一个数组中大部分元素为0，或者同一个值得数组时，可以使用稀疏数组来保存该数组。</p>
<p>二维数组转稀疏数组：</p>
<ol>
<li>遍历二维数组，得到有效数据sum</li>
<li>根据sum创建稀疏数组<code>sparseArr int[sum+1][3]</code>，第一行记录数组一共有几行，几列，有多少个不同的值</li>
<li>将二维数组的有效数据存入到稀疏数组</li>
</ol>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li>队列是一个有序列表，可以用<strong>数组</strong>或<strong>链表</strong>来实现</li>
<li>遵循先进先出</li>
<li>数组模拟队列示意图</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192021255.png"></p>
<ul>
<li><p>数组队列：其中maxSize是该队列的最大容量，front及rear分别记录队列前后端的下标，front 会随着数据<strong>输出</strong>而改变，而rear则是随着数据<strong>输入</strong>而改变。</p>
<p>将尾指针往后移: <code>rear+1</code>，当<code>front == rear</code> 【空】</p>
<p>若尾指针rear小于队列的最大下标<code>maxSize-1</code>，则将数据存入rear所指的数组元素中，否则无法存入数据。<code>rear == maxSize-1</code>[队列满]</p>
</li>
<li><p>环形队列：front和rear初始值为0，当队列满时：<code>(rear+1)%maxSize==front</code>队列中有效数据：<code>(rear+maxSize-front)%maxSize</code></p>
</li>
</ul>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><ul>
<li>链表是以节点的方式来存储</li>
<li>每个节点包含data域，next域：指向下一个节点</li>
<li>链表是有序的列表，但在内存中不一定是连续存储</li>
<li>链表分带头节点的和不带头结点的链表，根据实际需求确定</li>
</ul>
<p><strong><em>单链表面试题:</em></strong></p>
<ol>
<li>求单链表中节点的个数</li>
<li>查找单链表综中的倒数第K个节点【新浪】</li>
<li>单链表的反转【腾讯】</li>
<li>从尾到头打印单链表【百度】</li>
</ol>
<h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><ul>
<li>单项链表查找的方向只能是一个方向，而双向链表可以向前或者向后查找</li>
<li>单向链表不能自我删除，需要靠辅助节点，而双向链表可以自我删除(1)<code>temp.pre.next=temp.next</code>(2)<code>temp.next.pre=temp.pre</code></li>
</ul>
<h5 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h5><h6 id="约瑟夫问题："><a href="#约瑟夫问题：" class="headerlink" title="约瑟夫问题："></a><strong><em>约瑟夫问题：</em></strong></h6><p>n = 5，即有5个人；k=1，从第一个人开始报数；m = 2，数2下</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192021531.png" alt="202107yueshefu"></p>
<ol>
<li>需求创建一个辅助指针(变量) helper ,事先应该指向环形链表的最后这个节点.</li>
<li>先让first和helper移动k-1次</li>
<li>报数时，让first和helper指针同时的移动m -1次</li>
<li>将first指向的小孩节点出圈<br>first= first.next<br>helper.next =first<br>原来first指向的节点就没有任何引用，就会被回牧</li>
</ol>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>树的存储方式能提高数据<strong>存储</strong>，<strong>读取</strong>的效率，比如利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。</p>
<h5 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T)<span class="comment">//如果当前节点不为空</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T-&gt;data);    <span class="comment">//输出当前节点的值 上中下决定前中后</span></span><br><span class="line">      PreOrderTraverse(T-&gt;Left); <span class="comment">//再调用自己到左节点</span></span><br><span class="line">      PreOrderTraverse(T-&gt;Right);<span class="comment">//最后到右节点</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历(深度优先算法)</span></span><br><span class="line"><span class="comment"> * 利用栈实现循环先序遍历二叉树</span></span><br><span class="line"><span class="comment"> * 这种实现类似于图的深度优先遍历（DFS）</span></span><br><span class="line"><span class="comment"> * 维护一个栈，将根节点入栈，然后只要栈不为空，出栈并访问，接着依次将访问节点的右节点、左节点入栈。</span></span><br><span class="line"><span class="comment"> * 这种方式应该是对先序遍历的一种特殊实现（看上去简单明了），但是不具备很好的扩展性，在中序和后序方式中不适用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param root 树根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderStack_1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="built_in">stack</span>.push(root);</span><br><span class="line">    TreeNode currentNode;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">        currentNode = <span class="built_in">stack</span>.pop();</span><br><span class="line">        System.out.print(currentNode.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (currentNode.right != null) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(currentNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode.left != null) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(currentNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 层序遍历(广度优先算法)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">treeIteratorByLevel</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="built_in">queue</span>.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">        TreeNode temp = <span class="built_in">queue</span>.poll();</span><br><span class="line">        System.out.println(temp.value);</span><br><span class="line">        <span class="keyword">if</span> (temp.left != null) &#123;</span><br><span class="line">            <span class="built_in">queue</span>.add(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.right != null) &#123;</span><br><span class="line">            <span class="built_in">queue</span>.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树查找"><a href="#二叉树查找" class="headerlink" title="二叉树查找"></a>二叉树查找</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DLR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点 上中下决定前中后</span></span><br><span class="line">	<span class="comment">// 左子树递归</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.left.DLR();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 右子树递归</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.right.DLR();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="节点删除"><a href="#节点删除" class="headerlink" title="节点删除"></a>节点删除</h5><ol>
<li>因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.</li>
<li>如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</li>
<li>如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right=null ;并且就返回(结束递归删除)</li>
<li>如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</li>
<li> 如果第4步也没有删除结点，则应当向右子树进行递归删除.</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果只有一个root结点, 这里立即判断root是不是就是要删除结点</span></span><br><span class="line">			<span class="keyword">if</span>(root.getNo() == no) &#123;</span><br><span class="line">				root = <span class="keyword">null</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//递归删除</span></span><br><span class="line">				root.delNode(no);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;空树，不能删除~&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//递归删除结点</span></span><br><span class="line">    <span class="comment">//1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line">    <span class="comment">//2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        */</span><br><span class="line">       <span class="comment">//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line">          <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line">          <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4.我们就需要向左子树进行递归删除</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//5.则应当向右子树进行递归删除</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="顺序存储二叉树"><a href="#顺序存储二叉树" class="headerlink" title="顺序存储二叉树"></a>顺序存储二叉树</h5><ol>
<li>顺序二叉树通常只考虑完全二叉树</li>
<li>第n个元素的左子节点为 2*n +1</li>
<li>第n个元素的右子节点为 2*n +2</li>
<li>第n个元素的父子节点为 (n-1)/2</li>
<li>n：表示二叉树中的第几个元素（0开始编号）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序存储二叉树遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//如果数组为空，或者 arr.length = 0</span></span><br><span class="line">   <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;数组为空，不能按照二叉树的前序遍历&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//输出当前这个元素</span></span><br><span class="line">   System.out.println(arr[index]); </span><br><span class="line">   <span class="comment">//向左递归遍历</span></span><br><span class="line">   <span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length) &#123;</span><br><span class="line">      preOrder(<span class="number">2</span> * index + <span class="number">1</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//向右递归遍历</span></span><br><span class="line">   <span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">2</span>) &lt; arr.length) &#123;</span><br><span class="line">      preOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h5><ol>
<li>n个结点的二叉链表中含有n+1【公式2n-(n-1)=n+1】个<strong>空指针域</strong>。利用二叉链表中的空指针域，<strong>存放指向该结点</strong>在某种遍历次序下（前中后序）的<strong>前驱和后继结点</strong>的指针(这种附加的指针称为”线索”)</li>
<li>这种加上了线索的二叉链表称为<strong>线索链表</strong>，相应的二叉树称为<strong>线索二叉树</strong>(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种</li>
<li>一个结点的前一个结点，称为前驱结点</li>
<li>一个结点的后一个结点，称为后继结点</li>
</ol>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192021470.png" alt="20210803xianshuo"></p>
<p>说明：当线索化二叉树后，Node节点的属性left和right，有如下情况:</p>
<ol>
<li>left指向的是左子树，也可能是指向的前驱节点，比如节点left指向的左子树,而⑩节点的 left指向的就是前驱节点.</li>
<li>right指向的是右子树，也可能是指向后继节点，比如①节点right指向的是右子树，而⑩节点的right指向的是后继节点.</li>
<li>为了区分left，right的指向，节点类中添加leftType，rightType。如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点，rightType同理 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果node==null, 不能线索化</span></span><br><span class="line">       <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//(一)递归线索化左子树</span></span><br><span class="line">       threadedNodes(node.getLeft());</span><br><span class="line">       <span class="comment">//(二)线索化当前结点</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//处理当前结点的前驱结点</span></span><br><span class="line">       <span class="keyword">if</span>(node.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//让当前结点的左指针指向前驱结点 </span></span><br><span class="line">          node.setLeft(pre); </span><br><span class="line">          <span class="comment">//修改当前结点的左指针的类型,指向前驱结点</span></span><br><span class="line">          node.setLeftType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//处理后继结点</span></span><br><span class="line">       <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//让前驱结点的右指针指向当前结点</span></span><br><span class="line">          pre.setRight(node);</span><br><span class="line">          <span class="comment">//修改前驱结点的右指针类型</span></span><br><span class="line">          pre.setRightType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点</span></span><br><span class="line">       pre = node;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//(三)递归线索化右子树</span></span><br><span class="line">       threadedNodes(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线索化二叉树遍历</p>
<blockquote>
<p>因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//遍历线索化二叉树的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个变量，存储当前遍历的结点，从root开始</span></span><br><span class="line">        HeroNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//循环的找到leftType == 1的结点，</span></span><br><span class="line">            <span class="comment">//后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化</span></span><br><span class="line">            <span class="comment">//处理后的有效结点</span></span><br><span class="line">            <span class="keyword">while</span>(node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打印当前这个结点</span></span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="comment">//如果当前结点的右指针指向的是后继结点,就一直输出</span></span><br><span class="line">            <span class="keyword">while</span>(node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//获取到当前结点的后继结点</span></span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//替换这个遍历的结点</span></span><br><span class="line">            node = node.getRight();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h5><p>二叉排序树：BST(Binary Sort(Search) Tree),对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。<img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192022933.png" alt="20210812paixusu"></p>
<p><strong>添加节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//判断传入的结点的值，和当前子树的根结点的值关系</span></span><br><span class="line">   <span class="keyword">if</span>(node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">      <span class="comment">//如果当前结点左子结点为null</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.left = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//递归的向左子树添加</span></span><br><span class="line">         <span class="keyword">this</span>.left.add(node);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//添加的结点的值大于 当前结点的值</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.right = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//递归的向右子树添加</span></span><br><span class="line">         <span class="keyword">this</span>.right.add(node);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除节点</strong></p>
<p>第一种情况：删除叶子节点思路</p>
<ol>
<li>需求先去找到要删除的结点targetNode</li>
<li>找到targetNode的父结点parent</li>
<li>确定targetNode是parent的左子结点还是右子结点</li>
<li>根据前面的情况来对应删除左子结点parent.left = null右子结点parent.right = null;</li>
</ol>
<p>第二种情况：删除只有一颗子树的节点</p>
<p>​    ….</p>
<ol start="4">
<li><p>判断targetNode下面是左子结点还是右子结点</p>
<p>（1）左：</p>
<ul>
<li>如果targetNode是parent的左子结点parent.left = targetNode.left;<ul>
<li>如果targetNode是 parent的右子结点parent.right = targetNode.left;</li>
</ul>
</li>
</ul>
<p>（2）右：</p>
<ul>
<li>如果 targetNode是parent的左子结点parent.left = targetNode.right;<ul>
<li>如果argetNode是parent的右子结点parent.right = targetNode.right</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>第三种情况：删除有两颗子树的节点</p>
<p>​    …</p>
<ol start="3">
<li>从targetNode 的右子树找到最小的结点(或者左子树最大的结点)</li>
<li>用一个临时变量，将最小结点的值保存</li>
<li>删除该最小结点，令targetNode等于该节点 targetNode.value = temp</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">      Node targetNode = search(value);</span><br><span class="line">      <span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line">      <span class="keyword">if</span>(targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点</span></span><br><span class="line">      <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">         root = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">      Node parent = searchParent(value);</span><br><span class="line">      <span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line">      <span class="keyword">if</span>(targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的节点*</span></span><br><span class="line">         <span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">         targetNode.value = minVal;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 删除只有一颗子树的结点</span></span><br><span class="line">          ...</span><br><span class="line">         <span class="keyword">if</span>(targetNode.left != <span class="keyword">null</span>) &#123;<span class="comment">//如果要删除的结点有左子结点</span></span><br><span class="line">			...</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果要删除的结点有右子结点 </span></span><br><span class="line">            ...</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node target = node;</span><br><span class="line">    <span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line">    <span class="keyword">while</span>(target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target = target.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这时 target就指向了最小结点 删除最小结点</span></span><br><span class="line">    delNode(target.value);</span><br><span class="line">    <span class="keyword">return</span> target.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h5><blockquote>
<ol>
<li>平衡二叉树也叫平衡二叉搜索树(Self-balancing binary search tree）又被称为AVL树，可以保证查询效率较高。</li>
<li>具有以下特点:它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。</li>
</ol>
</blockquote>
<p><strong>单旋转</strong>（左旋：当右子树的高度 - 左子树的高度 &gt; 1）</p>
<ol>
<li>创建一个新的节点，令其值等于当前<strong>根节点</strong>的值</li>
<li>把新节点的左子树指向当前节点的左子树  newNode.left = left</li>
<li>把新节点的右子树指向当前节点的<strong>右子树的左子树</strong>  newNode.right =right.left</li>
<li>把当前节点的<strong>值换</strong>为右子节点的值 value=right.value</li>
<li>把当前节点的右子树指向成<strong>右子树的右子树</strong> right=right.right</li>
<li>把当前节点的左子树指向新节点 left=newNode </li>
</ol>
<p>注：右旋将所有left和right对换</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192022932.png" alt="202100812zuoxuan"></p>
<p><strong>双旋转</strong></p>
<p>当符合右旋转的条件时，如果它的<strong>左子树的右子树</strong>高度大于它的<strong>右子树</strong>高度，先对左子树进行左旋转，再对当前节点进行右旋转</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192022217.png" alt="20210813shuangxuan"></p>
<h4 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a>多叉树</h4><h5 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h5><blockquote>
<ol>
<li>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</li>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</li>
<li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.)，2-3树是由二节点和三节点构成的树。</li>
<li>当按照规则插入一个数到某个节点时，不能满足上面三个要求,就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满定上面3个条件。</li>
<li>对于三节点的子树的值大小仍然遵守<strong>二叉排序树</strong>的规则</li>
</ol>
</blockquote>
<h5 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h5><blockquote>
<ol>
<li>B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4</li>
<li>B-树的搜索，从根结点开始,对结点内的关键字（有序）序列进**行二分查找,**如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li>
<li>关键字集合分布在整颗树中，即叶子节点和非叶子节点都存放数据-<br> 搜索有可能在非叶子结点结束</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找</li>
</ol>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192023648.jpg" alt="1347265816_7366"></p>
</blockquote>
<h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><blockquote>
<ol>
<li>B+树是B树的变体，也是多路B+树的搜索与B树也基本相同，区别是B树只有达到叶子结点才命中(树可以在非叶子结点合中)，其性能也等价于在关键字全集做一次二分查找</li>
<li>所有<strong>关键字都出现在叶了结点的链表中</strong>(即数据只能在叶子节点【也叫稠密索引】)，且链表中的关键字数据)恰好是有序的。</li>
<li>不可能在非叶子结点命中</li>
<li>非叶子结点相当于是叶子结点的索引(稀疏索引叶子结点相当子是存储(关键字)数据的数据层</li>
<li>更适合文件索引系统</li>
<li>B树和B+树各有自己的应用场景,不能说B+树完全比B树好，反之亦然.</li>
</ol>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192023159.jpg" alt="1347265821_7407"></p>
</blockquote>
<h5 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h5><blockquote>
<p>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</p>
<ol>
<li>B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。</li>
<li>从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高</li>
</ol>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192024504.jpg" alt="1347265826_6256"></p>
</blockquote>
<h4 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h4><blockquote>
<ol>
<li><p>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为<strong>路径</strong>。通路中分支的数目称为<strong>路径长度</strong>。若规定根结点的层数为1，则从根结点到第L层结点的<strong>路径长度为L-1</strong></p>
</li>
<li><p>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为<strong>该结点的权</strong>。</p>
<p>结点的带权路径长度为：从根结点到该结点之间的<strong>路径长度</strong>与该结点的<strong>权</strong>的<strong>乘积</strong></p>
</li>
<li><p>树的带权路径长度：树的带权路径长度规定为<strong>所有叶子结点的带权路径长度之和</strong>，记为WPL(weighted path length) ，<strong>权值越大的结点离根结点越近</strong>的二叉树才是<strong>最优二叉树</strong>（赫夫曼树）</p>
</li>
<li><p>WPL最小的就是赫夫曼树</p>
</li>
<li><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192024500.png" alt="20210812heufman" style="zoom:50%;" />
</li>
</ol>
</blockquote>
<p>构成赫夫曼树的步骤：</p>
<ol>
<li>从小到大进行排序,将每一个数据，每个数据都是一个节点，每个节点可以看成是—颗最简单的二叉树</li>
<li>取出根节点权值最小的两颗二叉树</li>
<li>组成一颗新的二叉树,该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</li>
<li>再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步为了操作方便</span></span><br><span class="line">    <span class="comment">// 1. 遍历 arr 数组</span></span><br><span class="line">    <span class="comment">// 2. 将arr的每个元素构成成一个Node</span></span><br><span class="line">    <span class="comment">// 3. 将Node 放入到ArrayList中</span></span><br><span class="line">    List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">        nodes.add(<span class="keyword">new</span> Node(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序 从小到大 </span></span><br><span class="line">        Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;nodes =&quot;</span> + nodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出根节点权值最小的两颗二叉树 </span></span><br><span class="line">        <span class="comment">//(1) 取出权值最小的结点（二叉树）</span></span><br><span class="line">        Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//(2) 取出权值第二小的结点（二叉树）</span></span><br><span class="line">        Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(3)构建一颗新的二叉树</span></span><br><span class="line">        Node parent = <span class="keyword">new</span> Node(leftNode.value + rightNode.value);</span><br><span class="line">        parent.left = leftNode;</span><br><span class="line">        parent.right = rightNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(4)从ArrayList删除处理过的二叉树</span></span><br><span class="line">        nodes.remove(leftNode);</span><br><span class="line">        nodes.remove(rightNode);</span><br><span class="line">        <span class="comment">//(5)将parent加入到nodes</span></span><br><span class="line">        nodes.add(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回哈夫曼树的root结点</span></span><br><span class="line">    <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h5><blockquote>
<ol>
<li>赫夫曼编码也翻译为哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式,属于一种程序算法</li>
<li>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</li>
<li>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%~90%之间</li>
<li>赫夫曼码是<strong>可变字长</strong>编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Node类,待数据和权值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;  </span>&#123;</span><br><span class="line">   Byte data; <span class="comment">// 存放数据(字符)本身，比如&#x27;a&#x27; =&gt; 97 &#x27; &#x27; =&gt; 32</span></span><br><span class="line">   <span class="keyword">int</span> weight; <span class="comment">//权值, 表示字符出现的次数</span></span><br><span class="line">   Node left;<span class="comment">//</span></span><br><span class="line">   Node right;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Byte data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">      <span class="keyword">this</span>.weight = weight;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 从小到大排序</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.weight - o.weight;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字节数组转为Node集合以构建赫夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getNodes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历 bytes , 统计 每一个byte出现的次数-&gt;map[key,value]</span></span><br><span class="line">    Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">        Integer count = counts.get(b);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123; <span class="comment">// Map还没有这个字符数据,第一次</span></span><br><span class="line">            counts.put(b, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把每一个键值对转成一个Node 对象，并加入到nodes集合</span></span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Byte, Integer&gt; entry: counts.entrySet()) &#123;</span><br><span class="line">        nodes.add(<span class="keyword">new</span> Node(entry.getKey(), entry.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建赫夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span></span>&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将赫夫曼树所有叶子节点转为赫夫曼编码</span></span><br><span class="line"><span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;Byte,String&gt;();</span><br><span class="line"><span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">    StringBuilder stringBuilder2 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line">    <span class="comment">//将code 加入到 stringBuilder2</span></span><br><span class="line">    stringBuilder2.append(code);</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123; <span class="comment">//如果node == null不处理</span></span><br><span class="line">        <span class="comment">//判断当前node 是叶子结点还是非叶子结点</span></span><br><span class="line">        <span class="keyword">if</span>(node.data == <span class="keyword">null</span>) &#123; <span class="comment">//非叶子结点</span></span><br><span class="line">            <span class="comment">//递归处理</span></span><br><span class="line">            <span class="comment">//向左递归</span></span><br><span class="line">            getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder2);</span><br><span class="line">            <span class="comment">//向右递归</span></span><br><span class="line">            getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//说明是一个叶子结点</span></span><br><span class="line">            <span class="comment">//就表示找到某个叶子结点的最后</span></span><br><span class="line">            huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将赫夫曼编码转为字节数组  每8位转为一个byte  (byte)Integer.parseInt(str,2)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">		<span class="comment">//1.利用 huffmanCodes 将  bytes 转成  赫夫曼编码对应的字符串</span></span><br><span class="line">		StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//遍历bytes 数组 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">byte</span> b: bytes) &#123;</span><br><span class="line">			stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="comment">//一句话 </span></span><br><span class="line">		<span class="keyword">int</span> len = (stringBuilder.length() + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">		<span class="comment">//创建 存储压缩后的 byte数组</span></span><br><span class="line">		<span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//记录是第几个byte</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123; <span class="comment">//因为是每8位对应一个byte,所以步长 +8</span></span><br><span class="line">				String strByte;</span><br><span class="line">				<span class="keyword">if</span>(i+<span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">					strByte = stringBuilder.substring(i);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">				&#125;	</span><br><span class="line">				<span class="comment">//将strByte 转成一个byte,放入到 huffmanCodeBytes</span></span><br><span class="line">				huffmanCodeBytes[index] = (<span class="keyword">byte</span>)Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">				index++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="赫夫曼解码"><a href="#赫夫曼解码" class="headerlink" title="赫夫曼解码"></a>赫夫曼解码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 字节数组转二进制的字符串</span><br><span class="line">   <span class="number">2.</span> 将赫夫曼编码表key-value进行调换</span><br><span class="line">   <span class="number">3.</span> 将二进制根据编码表进行解码</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; stringBuilder.length(); ) &#123;</span><br><span class="line">           <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// 小的计数器</span></span><br><span class="line">           <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">               <span class="comment">//1010100010111...</span></span><br><span class="line">               <span class="comment">//递增的取出 key 1 </span></span><br><span class="line">               String key = stringBuilder.substring(i, i+count);<span class="comment">//i 不动，让count移动，指定匹配到一个字符</span></span><br><span class="line">               </span><br><span class="line">               <span class="keyword">if</span>(map.containsKey(key))&#123;<span class="comment">//匹配到</span></span><br><span class="line">                   flag = <span class="keyword">false</span>;</span><br><span class="line">                   list.add(map.get(key));<span class="comment">//添加到list</span></span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;					<span class="comment">//没有匹配到</span></span><br><span class="line">                    count++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           i += count;<span class="comment">//i 直接移动到 count	</span></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br></pre></td></tr></table></figure>

<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><blockquote>
<p>图(Graph)是由顶点和连接顶点的边构成的离散结构。在计算机科学中，图是最灵活的数据结构之一，很多问题都可以使用图模型进行建模求解。</p>
<p>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。结点也可以称为顶点。</p>
<p>当需要表示多对多的关系时，就用到了图</p>
</blockquote>
<p>图的表示方式有两种：</p>
<ol>
<li>二维数组表示（邻接矩阵）</li>
<li>链表表示（邻接表）</li>
</ol>
<p><strong>邻接矩阵</strong></p>
<p>1.邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1….n个点。（1表示能直接连接，0表示不能直接连接）<img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192025999.png" alt="5448614122959"></p>
<p><strong>邻接表</strong></p>
<ol>
<li>邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失.</li>
<li>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由<strong>数组+链表</strong>组成</li>
</ol>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192024017.png" alt="2846984564685"></p>
<p>​    说明：标号为0的结点的相关联的结点为1 2 3 4</p>
<h5 id="图的创建-邻接矩阵"><a href="#图的创建-邻接矩阵" class="headerlink" title="图的创建(邻接矩阵)"></a>图的创建(<strong>邻接矩阵</strong>)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList; <span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges; <span class="comment">//存储图对应的邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges; <span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="comment">//定义给数组boolean[], 记录某个结点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> ArrayList&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span> </span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> v1 表示点的下标即使第几个顶点(几行几列)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> weight 权值（是否连接） </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="图遍历"><a href="#图遍历" class="headerlink" title="图遍历"></a>图遍历</h5><blockquote>
<p>所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略:(1)深度优先遍历    (2)广度优先遍历</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192025443.png" alt="20210814dfs"></p>
</blockquote>
<p><strong>深度优先搜索DFS(Depth First Search)</strong></p>
<p>基本思想：</p>
<ol>
<li>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点，可以这样理解:每次都在访问完当前结点后首先访问<strong>当前结点的第一个邻接结点</strong>。</li>
<li>这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。</li>
<li>深度优先搜索是一个递归的过程</li>
</ol>
<p>实现步骤：</p>
<ol>
<li>访问初始结点v，并标记结点v为已访问。</li>
<li>查找结点v的第一个邻接结点w。</li>
<li>若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。</li>
<li>若w未被访间，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123)</li>
<li>若w已被访间，查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</li>
</ol>
<p><strong>广度优先搜索BFS(Broad First Search)</strong> </p>
<p>基本思想：</p>
<p>类似于一个分层搜索的过程，广度优先遍历需要使用一个<strong>队列</strong>以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</p>
<p>实现步骤：</p>
<ol>
<li><p>访问初始结点v并标记结点v为已访问。</p>
</li>
<li><p>结点v入队列</p>
</li>
<li><p>当队列非空时，继续执行，否则算法结束。</p>
</li>
<li><p>出队列，取得队头结点u。</p>
</li>
<li><p>查找结点u的第一个邻接结点w。</p>
</li>
<li><p>若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：</p>
<p>6.1 若结点w尚未被访问，则访问结点w并标记为已访问。</p>
<p>6.2 结点w入队列</p>
<p>6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</p>
</li>
</ol>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul>
<li>栈的英文为(stack)，是一个**先入后出(**FILO-First In Last Out)的有序列表。</li>
<li>栈(stack)是限制线性表中元素的插入和删除<strong>只能在线性表的同一端</strong>进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为<strong>栈顶</strong>(Top)，另一端为固定的一端，称为<strong>栈底</strong>(Bottom)。</li>
<li>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而<br>删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</li>
</ul>
<h5 id="实现栈的思路分析："><a href="#实现栈的思路分析：" class="headerlink" title="实现栈的思路分析："></a><strong><em>实现栈的思路分析：</em></strong></h5><ol>
<li>使用数组来模拟栈</li>
<li>定义一个top来表示栈顶,初始化为-1</li>
<li>入栈的操作，当有数据加入到栈时，<code>top++; stack[topl= data;</code></li>
<li>出栈的操作,<code>int value =stack[top];top--;returnvalue</code></li>
</ol>
<h5 id="使用栈完成表达式的计算界路："><a href="#使用栈完成表达式的计算界路：" class="headerlink" title="使用栈完成表达式的计算界路："></a><strong><em>使用栈完成表达式的计算界路：</em></strong></h5><p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192025065.png" alt="20210711zhan"></p>
<ol>
<li>通过一个index值（索引，来遍历表达式）</li>
<li>如果我们发现是一个数字,就直接入数栈</li>
<li>如果发现扫描到是一个符号,就分如下情况<ol>
<li>如果发现当前的符号核为空，就直接入栈</li>
<li>如果符号栈有操作符，就进行比较,如果<strong>当前的操作符的优先级小于或者等于</strong>栈中的操作符，就需要从数栈中pop出两个数在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈，如果<strong>当前的操作符的优先级大于</strong>栈中的操作符,就直接入符号栈.</li>
<li>当表达式扫描完毕,就顺序的从数栈和符号栈中pop出相应的数和符号，并运行.</li>
<li>最后在数栈只有一个数字,就是表达式的结果</li>
</ol>
</li>
<li>问题：加减顺序出错</li>
</ol>
<h5 id="中缀表达式转换为后缀表达式（逆波兰式）"><a href="#中缀表达式转换为后缀表达式（逆波兰式）" class="headerlink" title="中缀表达式转换为后缀表达式（逆波兰式）:"></a><strong><em>中缀表达式转换为后缀表达式（逆波兰式）:</em></strong></h5><ol>
<li>初始化两个栈:运算符栈s1和储存中间结果的栈s2;</li>
<li>从左至右扫描中缀表达式;</li>
<li>遇到操作数时，将其压s2;</li>
<li><strong>遇到运算符时</strong>，比较其与s1栈顶运算符的优先级:<ol>
<li>如果s1为空，或栈顶运算符为左括号“(“，则直接将此运算符入栈;</li>
<li>否则，若优先级比栈顶运算符的高，也将运算符压入s1;</li>
<li>否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算<br>符相比较;</li>
</ol>
</li>
<li><strong>遇到括号时</strong>:<ol>
<li>如果是左括号“(“，则直接压入s1</li>
<li>如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</li>
</ol>
</li>
<li>重复步骤2至5，直到表达式的最右边</li>
<li>将s1中剩余的运算符依次弹出并压入s2</li>
<li>依次弹出s2中的元素并输出，结果的<strong>逆序</strong>即为中缀表达式对应的后缀表达式</li>
</ol>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><blockquote>
<p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。HashTable的方法是同步的，即是线程安全的。</p>
</blockquote>
<p>HashTable和HaspMap区别：</p>
<ol>
<li>HaspMap的方法不是同步的，不是线程安全的的。</li>
<li>HashTable中不允许有null键和null值，HashMap中允许出现一个null键，可以存在一个或者多个键的值都为null,因此，在HashMap中，我们不能使用get()方法来查询键 对应的值，应该使用containskey()方法。</li>
<li>HashTable是直接使用对象的hashCode。HashMap是重新计算hash值。</li>
<li>HashTable和HashMap的底层实现的数组和初始大小和扩容方式。HashTable初始大小为11，并且每次扩容都为：2<em>old+1。HashMap的默认大小为16，并且一 定是2的指数，每次扩容都为old</em>2。</li>
</ol>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。</p>
<p>递归需要遵守规则：</p>
<ol>
<li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li>
<li>方法的局部变量是独立的，不会相互影响,比如n变量</li>
<li>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.</li>
<li>递归必须向退出递归的条件逼近，否则就是无限递归,出现<strong>StackOverflowError</strong></li>
<li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果<br>返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</li>
</ol>
<h5 id="八皇后问题："><a href="#八皇后问题：" class="headerlink" title="八皇后问题："></a><em>八皇后问题：</em></h5><p>八皇后问题，是一个古老而著名的问题，<strong>是回溯算法的典型案例</strong>。即:任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p>
<p><strong>算法思路分析：</strong></p>
<ol>
<li>第一个皇后先放第一行第一列</li>
<li>第二个皇后放在第二行第一列、然后判断是否冲突，如果不冲突，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</li>
<li>继续第三个皇后，还是第一列、第二列…….直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</li>
<li>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</li>
<li>然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4的步骤</li>
</ol>
<p>说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题.<code>arr[8]= &#123;0 ,4,7,5,2,6,1,3&#125;</code>//对应arr下标表示第几行，即第几个皇后，<code>arr[i]=val </code>, val表示第i+1个皇后，放在第i+1行的第val+1列</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/05/19/blog-images-master/README/</url>
    <content><![CDATA[<h1 id="BlogImages"><a href="#BlogImages" class="headerlink" title="BlogImages"></a>BlogImages</h1><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>{<strong>以下是 Gitee 平台说明，您可以替换此简介</strong><br>Gitee 是 OSCHINA 推出的基于 Git 的代码托管平台（同时支持 SVN）。专为开发者提供稳定、高效、安全的云端软件开发协作平台<br>无论是个人、团队、或是企业，都能够用 Gitee 实现代码托管、项目管理、协作开发。企业项目请看 <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZW50ZXJwcmlzZXM=">https://gitee.com/enterprises<i class="fa fa-external-link-alt"></i></span>}</p>
<h4 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h4><p>软件架构说明</p>
<h4 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h4><ol>
<li> xxxx</li>
<li> xxxx</li>
<li> xxxx</li>
</ol>
<h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><ol>
<li> xxxx</li>
<li> xxxx</li>
<li> xxxx</li>
</ol>
<h4 id="参与贡献"><a href="#参与贡献" class="headerlink" title="参与贡献"></a>参与贡献</h4><ol>
<li> Fork 本仓库</li>
<li> 新建 Feat_xxx 分支</li>
<li> 提交代码</li>
<li> 新建 Pull Request</li>
</ol>
<h4 id="特技"><a href="#特技" class="headerlink" title="特技"></a>特技</h4><ol>
<li> 使用 Readme_XXX.md 来支持不同的语言，例如 Readme_en.md, Readme_zh.md</li>
<li> Gitee 官方博客 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmdpdGVlLmNvbS8=">blog.gitee.com<i class="fa fa-external-link-alt"></i></span></li>
<li> 你可以 <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZXhwbG9yZQ==">https://gitee.com/explore<i class="fa fa-external-link-alt"></i></span> 这个地址来了解 Gitee 上的优秀开源项目</li>
<li> <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZ3Zw">GVP<i class="fa fa-external-link-alt"></i></span> 全称是 Gitee 最有价值开源项目，是综合评定出的优秀开源项目</li>
<li> Gitee 官方提供的使用手册 <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaGVscA==">https://gitee.com/help<i class="fa fa-external-link-alt"></i></span></li>
<li> Gitee 封面人物是一档用来展示 Gitee 会员风采的栏目 <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZ2l0ZWUtc3RhcnMv">https://gitee.com/gitee-stars/<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>排序查找算法</title>
    <url>/2021/08/31/%E6%8E%92%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>时间频度：<br>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</p>
<a id="more"></a>

<p>时间复杂度:</p>
<p>常见的算法时间复杂度由小到大依次为:O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n^2)&lt;O(n^3)&lt;O(n^k)&lt;O(2^n)，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低<br>从图中可见，我们应该尽可能避免使用指数阶的算法</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192014525.png" alt="20210712shijianfzd"></p>
<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p><strong>排序使用场景：</strong></p>
<p>(1)若n较小(如n≤50)，可采用直接插入或直接选择排序；</p>
<ul>
<li>当记录规模较小时，直接插入排序较好；</li>
<li>否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。</li>
</ul>
<p>(2)若文件初始状态基本有序(指正序)，则应选用直接插人或冒泡排序为宜；</p>
<p>(3)若文件初始状态随机分布，则应选用快速排序为宜；</p>
<p>(4)若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序；</p>
<ul>
<li>快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</li>
<li>堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。</li>
<li>若要求排序稳定，则可选用归并排序。但本章介绍的从单个记录起进行两两归并的 排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子文件，然后再两两归并之。因为直接插入排序是稳定 的，所以改进后的归并排序仍是稳定的。</li>
</ul>
<blockquote>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192014710.png"></p>
</blockquote>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192015685.png" alt="20210712paxu"></p>
<ol>
<li>相关术语解释:<ol>
<li>**稳定 **: 如果a原本在b前面，而a=b，排序之后a仍然在b的前面;</li>
<li>**不稳定 **: 如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面;</li>
<li><strong>内排序</strong> : 所有排序操作都在内存中完成</li>
<li><strong>外排序</strong> : 由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行;</li>
<li><strong>n</strong> : 数据规模</li>
<li>**k **: “桶”的个数</li>
<li><strong>in-place</strong> : 不占用额外内存</li>
<li><strong>out-place</strong> : 占用额外内存</li>
</ol>
</li>
</ol>
<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><blockquote>
<p>冒泡排序(Bubble Sorting）的基本思想是:通讨对待排序序列从前向后(从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。</p>
<p>优化：因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序 时间复杂度O(n^2)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr. length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j +<span class="number">1</span> ]&#123;</span><br><span class="line">            ...<span class="comment">//交换</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//没有交换说明后面的元素已经有序，就直接break</span></span><br><span class="line">	<span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><blockquote>
<p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序 时间复杂度O(n^2)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> minIndex = i;</span><br><span class="line">    <span class="comment">// 找出最小值得元素下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">            minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//与最小的元素交换位置</span></span><br><span class="line">    <span class="keyword">if</span>(minIndex != i)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[index];</span><br><span class="line">        arr[minIndex] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><blockquote>
<p>插入排序(InsertionSort)一般也被称为直接插入排序。</p>
<p>对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增 1 的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; temp; j--) &#123;</span><br><span class="line">        arr[j] = arr[j - <span class="number">1</span>];	<span class="comment">//原数往后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = temp;	<span class="comment">//插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><blockquote>
<p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为<strong>缩小增量排序</strong>，同时该算法是冲破O(n^2）的第一批算法之一。希尔排序有<strong>交换法</strong>和<strong>移动法</strong>，交换法较慢。</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192016423.png" alt="20210719xierpaixu"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>;gap&gt;<span class="number">0</span>;gap /= <span class="number">2</span>)&#123; <span class="comment">//gap：增量  7   3   1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++)&#123; </span><br><span class="line">        <span class="comment">//i:代表即将插入的元素角标，作为每一组比较数据的最后一个元素角标 </span></span><br><span class="line">        <span class="comment">//j:代表与i同一组的数组元素角标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i-gap; j&gt;=<span class="number">0</span>; j-=gap)&#123; <span class="comment">//在此处-gap 为了避免下面数组角标越界</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;<span class="comment">// j+gap 代表即将插入的元素所在的角标</span></span><br><span class="line">                <span class="comment">//符合条件，插入元素（交换位置）</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + gap];</span><br><span class="line">                arr[j + gap] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//移动法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>;gap&gt;<span class="number">0</span>;gap /= <span class="number">2</span>)&#123; </span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++)&#123; </span><br><span class="line">       <span class="keyword">int</span> j;</span><br><span class="line">       <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">       <span class="keyword">for</span> (j = i; j-gap &gt; <span class="number">0</span> &amp;&amp; arr[j - gap] &gt; temp; j-=gap) &#123;</span><br><span class="line">           arr[j] = arr[j - gap];	<span class="comment">//原数往后移</span></span><br><span class="line">       &#125;</span><br><span class="line">       arr[j] = temp;	<span class="comment">//插入</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><blockquote>
<p>快速排序（Quicksort)是对冒泡排序的一种改进。基本思想是:通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,pivot,temp;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i=left;</span><br><span class="line">    j=right;</span><br><span class="line">    <span class="comment">//pivot是基准位</span></span><br><span class="line">    pivot = arr[left];</span><br><span class="line">    <span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">        <span class="comment">//先看右边，依次往左找出小于基准的数</span></span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt;= pivot &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再看左边，依次往右递增找出大于基准的数</span></span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt;= pivot &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果满足条件则交换</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;j) &#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后将基准 与 i和j相遇位置的数字交换，此时i==j</span></span><br><span class="line">    arr[left] = arr[i];</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    <span class="comment">//递归调用左半数组</span></span><br><span class="line">    quickSort(arr, left, i-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//递归调用右半数组</span></span><br><span class="line">    quickSort(arr, i+<span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><blockquote>
<p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治(divide-and-conquer〉策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在-起，即分而治之)。</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192016720.png"></p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192017069.png" alt="20210722fen"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] tmp)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;				<span class="comment">//缓存数组个数</span></span><br><span class="line">   <span class="keyword">int</span> j = left,k = mid+<span class="number">1</span>;  <span class="comment">//左边序列和右边序列起始索引</span></span><br><span class="line">   <span class="keyword">while</span>(j &lt;= mid &amp;&amp; k &lt;= right)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &lt; arr[k])&#123;</span><br><span class="line">         tmp[i++] = arr[j++];</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         tmp[i++] = arr[k++];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若左、右边序列还有剩余，则将其全部拷贝进tmp[]中</span></span><br><span class="line">   <span class="keyword">while</span>(j &lt;= mid)&#123;</span><br><span class="line">      tmp[i++] = arr[j++];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(k &lt;= right)&#123;</span><br><span class="line">      tmp[i++] = arr[k++];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将temp数组中的元素拷贝到arr</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;i;t++)&#123;	</span><br><span class="line">      arr[left+t] = tmp[t];	</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] tmp)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">      mergeSort(arr,left,mid,tmp); <span class="comment">//对左边序列进行归并排序</span></span><br><span class="line">      mergeSort(arr,mid+<span class="number">1</span>,right,tmp);  <span class="comment">//对右边序列进行归并排序</span></span><br><span class="line">      merge(arr,left,mid,right,tmp);    <span class="comment">//合并两个有序序列</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h5><blockquote>
<p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。    基数排序是使用空间换时间的经典算法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基数排序方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//得到数组中最大的数的位数</span></span><br><span class="line">   <span class="keyword">int</span> max = arr[<span class="number">0</span>]; </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">         max = arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> maxLength = (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span></span><br><span class="line">   <span class="comment">//1. 二维数组包含10个一维数组</span></span><br><span class="line">   <span class="comment">//2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span></span><br><span class="line">   <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">   <span class="comment">//比如：bucketCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数</span></span><br><span class="line">   <span class="keyword">int</span>[] bucketCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> , n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">         <span class="comment">//取出每个元素的对应位的值,放入到对应的桶中</span></span><br><span class="line">         <span class="keyword">int</span> digit = arr[j] / n % <span class="number">10</span>;</span><br><span class="line">         buckets[digit][bucketCounts[digit]] = arr[j];</span><br><span class="line">         bucketCounts[digit]++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line">      <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketCounts.length; k++) &#123;</span><br><span class="line">         <span class="comment">//如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line">         <span class="keyword">if</span>(bucketCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; bucketCounts[k]; l++) &#123;</span><br><span class="line">               <span class="comment">//取出元素放入到arr</span></span><br><span class="line">               arr[index++] = buckets[k][l];</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//第i+1轮处理后，需要将每个 bucketCounts[k] = 0 ！！！！</span></span><br><span class="line">         bucketCounts[k] = <span class="number">0</span>;  </span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><blockquote>
<ol>
<li><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p>
</li>
<li><p>堆是具有以下性质的完全二叉树:每个结点的值都大于或等于其左右孩子结点的值，称为<strong>大顶堆</strong>，**注意:**没有要求结点的左孩子的值和右孩子的值的大小关系。</p>
</li>
<li><p>每个结点的值都小于或等于其左右孩子结点的值，称为<strong>小顶堆</strong></p>
</li>
<li><p>大顶堆举例说明<img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192017394.png" alt="20210805dadingdui"></p>
</li>
<li><p>大顶堆的特点：arr[ i ] &gt;= arr[ 2 * i + 1] &amp;&amp; arr[ i ] &gt;=arr[2 * i +2 ]  ;</p>
<p>小顶堆：arr[ i ] &lt;= arr[ 2 * i + 1] &amp;&amp; arr[ i ] &lt;=arr[2 * i +2 ];i对应第几个节点，从0开始</p>
</li>
<li><p>升序采用大顶堆，降序采用小顶堆</p>
</li>
</ol>
</blockquote>
<p>堆排序基本思路：</p>
<ol>
<li>将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆，最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1），从左至右，从下至上进行调整。</li>
<li>将堆页元素与末尾元素交换，将最大元素”沉”到数组末端;</li>
<li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//堆排序</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">            temp =arr[j];</span><br><span class="line">            arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;	</span><br><span class="line">            </span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);<span class="comment">//交换后重新调整为大顶堆 在交换	</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整大顶堆（仅是一次调整）</span></span><br><span class="line"><span class="comment">//1. 当前元素:i ; 左子节点： k=i*2+1 ; 右子节点：k+1 = i*2+2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时：arr[k]为arr[i]节点下较大的一个数</span></span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt;temp)&#123;<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;		<span class="comment">//i指向k 继续循环比较</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;		<span class="comment">//因为是最后一个非叶子结点 后面没有子树 直接跳出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h4><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><blockquote>
<p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用<strong>顺序存储结构</strong>，而且表中元素<strong>按关键字有序排列</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 递归实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> ((key &lt; arr[left] || key &gt; arr[right] || left &gt; right) &#123;</span><br><span class="line">       ...</span><br><span class="line">      <span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line">   <span class="keyword">if</span> (key &gt; midVal) &#123; <span class="comment">// 向右递归</span></span><br><span class="line">      <span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, key);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; midVal) &#123; <span class="comment">// 向左递归</span></span><br><span class="line">      <span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, key);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">int</span> temp = mid - <span class="number">1</span>;</span><br><span class="line">       <span class="comment">/*多值返回</span></span><br><span class="line"><span class="comment">       while(true) &#123;</span></span><br><span class="line"><span class="comment">           if (temp &lt; 0 || arr[temp] != findVal) &#123;//退出</span></span><br><span class="line"><span class="comment">               break;</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">           //否则，就temp 放入到 resIndexlist</span></span><br><span class="line"><span class="comment">           resIndexlist.add(temp);</span></span><br><span class="line"><span class="comment">           temp -= 1; //temp—1左移;temp+1右移</span></span><br><span class="line"><span class="comment">       &#125;*/</span></span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 循环实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">commonBinarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">           <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">int</span> middle = <span class="number">0</span>;			<span class="comment">//定义middle</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(key &lt; arr[low] || key &gt; arr[high] || low &gt; high)&#123;</span><br><span class="line">               <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">               middle = (low + high) / <span class="number">2</span>;         </span><br><span class="line">               <span class="keyword">if</span>(arr[middle] &gt; key)&#123;                              </span><br><span class="line">                   <span class="comment">//比关键字大则关键字在左区域</span></span><br><span class="line">                   high = middle - <span class="number">1</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle] &lt; key)&#123;</span><br><span class="line">                   <span class="comment">//比关键字小则关键字在右区域</span></span><br><span class="line">                   low = middle + <span class="number">1</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">return</span> middle;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;		<span class="comment">//最后仍然没有找到，则返回-1</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h5 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h5><blockquote>
<p>插值查找，有序表的一种查找方式。插值查找是<strong>根据查找关键字与查找表中最大最小记录关键字比较后</strong>的查找方法。插值查找<strong>基于</strong>二分查找，将查找点的选择改进为自适应选择，提高查找效率。<img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192018345.png" alt="20210726erfen"></p>
<ol>
<li>对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找,速度较快.</li>
<li>关键字分布不均匀的情况下，该方法不一定比折半查找要好</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (left &gt; right || findVal &lt; arr[<span class="number">0</span>] || findVal &gt; arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">   <span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出mid, 自适应</span></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);</span><br></pre></td></tr></table></figure>

<h5 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h5><blockquote>
<p>斐波那契数列中(上表来自维基百科)，<strong>从第三项开始，每一项都等于前两项之和</strong>：</p>
<p>F(n) = F(n - 1) + F(n - 2)        (n &gt; 2)</p>
<p>F(n) -1= [ F(n - 1) -1 ] + [ F(n - 2) - 1 ] + 1        (n &gt; 0)</p>
<p>1    1    2    3    5    8    13    21    55    76    ….</p>
<p>0    0    1    2    4    7    12    20    54    75    ….</p>
</blockquote>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192018358.png" alt="20191129110124337"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成斐波那契数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> [] Fibonacci()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> [] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">   f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//斐波那契查找</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Fibonacci_Search</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> low, high, mid;</span><br><span class="line">   <span class="keyword">int</span> n = a.length;</span><br><span class="line">   low = <span class="number">1</span>;</span><br><span class="line">   high = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> [] F = Fibonacci();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//查找数组 中 元素个数 在斐波那契数列中的位置</span></span><br><span class="line">   <span class="keyword">while</span> ( n &gt; F[k] - <span class="number">1</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      k++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将a数组扩充到最近一个斐波那契数的长度，用数组最后一个数字填充</span></span><br><span class="line">   a = Arrays.copyOf(a, F[k]);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; F[k] - <span class="number">1</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      a[i] = a[high];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//查找</span></span><br><span class="line">   <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">   &#123;</span><br><span class="line">      mid = low + F[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//向左查找</span></span><br><span class="line">      <span class="keyword">if</span> ( key &lt; a[mid] )</span><br><span class="line">      &#123;</span><br><span class="line">         high = mid - <span class="number">1</span>;</span><br><span class="line">         k = k - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//向右查找</span></span><br><span class="line">      <span class="comment">//则将F[k]-1长数组的前半部分low+F[k-1]-1(大段)作为新的递归序列，若key &gt; temp[mid]，就使用后半部分low+F[k-2]-1(小段)，如此就实现了二分。</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( key &gt; a[mid] )</span><br><span class="line">      &#123;</span><br><span class="line">         low = mid + <span class="number">1</span>;</span><br><span class="line">         k = k - <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span> ( mid &lt;= high )</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/05/19/blog-images-master/README.en/</url>
    <content><![CDATA[<h1 id="BlogImages"><a href="#BlogImages" class="headerlink" title="BlogImages"></a>BlogImages</h1><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>{<strong>When you’re done, you can delete the content in this README and update the file with details for others getting started with your repository</strong>}</p>
<h4 id="Software-Architecture"><a href="#Software-Architecture" class="headerlink" title="Software Architecture"></a>Software Architecture</h4><p>Software architecture description</p>
<h4 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h4><ol>
<li> xxxx</li>
<li> xxxx</li>
<li> xxxx</li>
</ol>
<h4 id="Instructions"><a href="#Instructions" class="headerlink" title="Instructions"></a>Instructions</h4><ol>
<li> xxxx</li>
<li> xxxx</li>
<li> xxxx</li>
</ol>
<h4 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h4><ol>
<li> Fork the repository</li>
<li> Create Feat_xxx branch</li>
<li> Commit your code</li>
<li> Create Pull Request</li>
</ol>
<h4 id="Gitee-Feature"><a href="#Gitee-Feature" class="headerlink" title="Gitee Feature"></a>Gitee Feature</h4><ol>
<li> You can use Readme_XXX.md to support different languages, such as Readme_en.md, Readme_zh.md</li>
<li> Gitee blog <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmdpdGVlLmNvbS8=">blog.gitee.com<i class="fa fa-external-link-alt"></i></span></li>
<li> Explore open source project <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZXhwbG9yZQ==">https://gitee.com/explore<i class="fa fa-external-link-alt"></i></span></li>
<li> The most valuable open source project <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZ3Zw">GVP<i class="fa fa-external-link-alt"></i></span></li>
<li> The manual of Gitee <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaGVscA==">https://gitee.com/help<i class="fa fa-external-link-alt"></i></span></li>
<li> The most popular members  <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZ2l0ZWUtc3RhcnMv">https://gitee.com/gitee-stars/<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
  </entry>
</search>
