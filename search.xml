<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ActiveMQ使用</title>
    <url>/2021/07/05/ActiveMQ/</url>
    <content><![CDATA[<h4 id="ActiveMQ介绍"><a href="#ActiveMQ介绍" class="headerlink" title="ActiveMQ介绍"></a>ActiveMQ介绍</h4><p>​     MQ是消息中间件，是一种在分布式系统中应用程序借以传递消息的媒介，常用的有ActiveMQ，RabbitMQ(erlang)，kafka。ActiveMQ是Apache下的开源项目，完全支持JMS1.1和J2EE1.4规范的JMS Provider实现。</p>
<a id="more"></a>

<p>特点：<br>1、支持多种语言编写客户端<br>2、对spring的支持，很容易和spring整合<br>3、支持多种传输协议：TCP,SSL,NIO,UDP等<br>4、支持AJAX<br>消息形式：<br>1、点对点（queue）<br>2、一对多（topic）</p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210707211328.png"></p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210707211339.png"></p>
<h4 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h4><h5 id="创建连接工厂"><a href="#创建连接工厂" class="headerlink" title="创建连接工厂"></a>创建连接工厂</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂</span></span><br><span class="line">        ActiveMQConnectionFactory activeMQConnectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;tcp://127.0.0.1:61616&quot;</span>);</span><br><span class="line">        <span class="comment">//2.通过连接工厂，获得连接并启动访问</span></span><br><span class="line">        Connection connection = activeMQConnectionFactory.createConnection();</span><br><span class="line">        connection.start();</span><br><span class="line">        <span class="comment">//3.创建会话Session(参数：事务|签收)</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>,Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//4.创建目的地(具体是队列queen还是主题topic)</span></span><br><span class="line">        Queue queue = session.createQueue(<span class="string">&quot;queue01&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.创建消息生产者</span></span><br><span class="line">MessageProducer messageProducer = session.createProducer(queue);</span><br><span class="line"><span class="comment">//6.生产消息发送到MQ队列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">    TextMessage textMessage =session.createTextMessage(<span class="string">&quot;msg--&quot;</span>+i);</span><br><span class="line">    messageProducer.send(textMessage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">messageProducer.close();</span><br><span class="line">session.close();</span><br><span class="line">connection.close();</span><br><span class="line">System.out.printf(<span class="string">&quot;******发送完成&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.创建消息消费者</span></span><br><span class="line">MessageConsumer messageConsumer = session.createConsumer(queue);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    TextMessage textMessage = (TextMessage) messageConsumer.receive();<span class="comment">//.receive(timeout)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span>!= textMessage)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;****消费者接收到消息：&quot;</span>+textMessage.getText());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="两种消费者方式"><a href="#两种消费者方式" class="headerlink" title="两种消费者方式"></a>两种消费者方式</h6><ul>
<li><p>同步阻塞方式（receive()）</p>
<p>订阅者或接收者调用MessageConsumer的receive()方法接收消息，receive方法在能够接收到消息之前(超时之前)将一直阻塞。</p>
</li>
<li><p>异步非阻塞方式（监听器onMessage()）</p>
<p>订阅者或接受者通过调用MessageConsumer的setMessgeLisener(MessageListener listener) 注册一个消息监听器，当消息到达之后，系统自动调用监听器MessageListener的onMessage(Message message)方法。</p>
</li>
</ul>
<h4 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h4><p>yml配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">activemq:</span></span><br><span class="line">      <span class="attr">broker-url:</span> <span class="string">tcp://127.0.0.1:61616</span></span><br><span class="line">      <span class="attr">user:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">jms:</span></span><br><span class="line">      <span class="attr">pub-sub-domain:</span> <span class="literal">false</span> 		<span class="comment">#false = Queue	true = topic</span></span><br></pre></td></tr></table></figure>

<p>配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJms</span>  <span class="comment">//启动消息队列（启动类）</span></span><br><span class="line"><span class="comment">//@EnableJmsScheduling    //开启定投</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myqueue&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String myQueue;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQQueue(myQueue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue_Produce</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Queue queue;<span class="comment">//destination</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息发送</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jmsMessagingTemplate.convertAndSend(queue,<span class="string">&quot;message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//间隔定投</span></span><br><span class="line">    <span class="meta">@Scheduked(fixedDelay = 3000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> produceMsgScheduled&#123;</span><br><span class="line">        jmsMessagingTemplate.convertAndSend(queue,<span class="string">&quot;message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue_Consumer</span></span>&#123;</span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;$&#123;myqueue&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者接收到消息...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTY0NDExRzdhQj9wPTQ0">https://www.bilibili.com/video/BV164411G7aB?p=44<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建与部署</title>
    <url>/2020/11/08/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="Hexo博客搭建与部署"><a href="#Hexo博客搭建与部署" class="headerlink" title="Hexo博客搭建与部署"></a>Hexo博客搭建与部署</h2><h3 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <span class="exturl" data-url="aHR0cDovL2RhcmluZ2ZpcmViYWxsLm5ldC9wcm9qZWN0cy9tYXJrZG93bi8=">Markdown<i class="fa fa-external-link-alt"></i></span>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<a id="more"></a>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h4><ul>
<li><span class="exturl" data-url="aHR0cDovL25vZGVqcy5vcmcv">Node.js<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cDovL2dpdC1zY20uY29tLw==">Git<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h4 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure>

<p>安装好之后使用$ hexo -v可查看安装成功与否,具体查看<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuLw==">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install <span class="comment">#d安装依赖</span></span></span><br></pre></td></tr></table></figure>

<p>安装完成后博客文件放在source/_posts文件夹中</p>
<h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><p>hexo项目结构安装好后，_config.yml可配置相关内容,可以选择自己喜欢的主题，可到官网或者github下载<span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy8=">NexT主题官网文档<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h4><p>Hexo 提供了快速方便的一键部署功能</p>
<p>1.首先在github创建一个和你用户名相同的仓库，后面加上.github.io，也就是xxxx.github.io</p>
<p>2.安装 hexo-deployer-git</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-deployer-git --save</span></span><br></pre></td></tr></table></figure>

<p>3.修改配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/xxx/xxx.github.io.git #仓库地址</span><br><span class="line">  branch: master #分支名</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure>

<p>4.部署</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo clean</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo generate</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo deploy		  <span class="comment">#部署</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo server         <span class="comment">#运行本地服务</span></span></span><br></pre></td></tr></table></figure>

<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>hexo部署到github上面的只是生成的静态文件,当换一台电脑时就无法更新博客了,所以在仓库中创建一个hexo分支来保存hexo的环境文件</p>
<p>1.xxx.github.io.git创建一个分支hexo,将此分支设置为默认分支</p>
<p>2.创建一个空文件夹将xxx.github.io.git通过git克隆到本地,然后将.git文件移动到hexo init 的文件下,此时相当于将hexo 文件夹与github上的hexo分支关联起来</p>
<p>3.执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add -A</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;environment&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin hexo</span></span><br></pre></td></tr></table></figure>

<p>将远程hexo分支中的静态文件替换为当前目录下的环境文件(因为.gitignore文件中忽略了静态文件,所以上传上去的只是环境文件,不会包含静态文件)</p>
<p>4.每次更新文章过后使用hexo命名更新文章,使用git命令更新环境文件,在换电脑之后只需要从git克隆下就能继续更新博客了</p>
<h4 id="部署到gitee"><a href="#部署到gitee" class="headerlink" title="部署到gitee"></a>部署到gitee</h4><p>部署到git之后会发现访问会很慢,有时候甚至直接无法访问,所以再到gitee再部署一个,因为再github已经部署过一次了,所以再gitee可以直接把github导过来</p>
<p>1.gitee再新建仓库的时候一个从github导入仓库的选项,可以直接从github将部署好的文件直接导过来</p>
<p>2.导入过来之后将仓库名改为与用户名相同</p>
<p>3.与github不同,gitee需要自己手动开启Pages服务,在仓库的服务选项选择Gitee Pages,选择部署分支mater,点击部署,成功后上面会显示已开启 Gitee Pages 服务，网站地址:<span class="exturl" data-url="aHR0cHM6Ly94eHguZ2l0LmlvLw==">https://xxx.git.io<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201108153519.png"></p>
<p>4.更新文章之后,想在gitee也同步更新,可以点击仓库名旁边的箭头,可直接从github同步到gitee</p>
<h3 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h3><p>Markdown文档中是能够存放图片路径显示图片的,上传到网络上之后可以使用图床实现,因为github访问困难,所以图床文件放在gitee</p>
<p>1.下载PicGo,安装gitee插件</p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201108153403.png"></p>
<p>2.在gitee创建库并设置Gitee插件,然后就能直接上传图片到gitee里面,使用的时候直接用图片的网络地址</p>
<p>3.gitee插件配置示例</p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210707.png"></p>
]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的安装使用</title>
    <url>/2020/11/11/Docker%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p>
<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>
<a id="more"></a>

<h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><ol>
<li><p>Docker要求CentOS系统内核版本高于3.10,查看CentOS内核版本:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uname -r</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install docker</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl start docker</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将docer设为开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> docker</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">docker search 关键字</td>
<td align="center">检索</td>
</tr>
<tr>
<td align="center">docker pull 镜像名:tag</td>
<td align="center">拉取</td>
</tr>
<tr>
<td align="center">docker images</td>
<td align="center">查询已下载的镜像</td>
</tr>
<tr>
<td align="center">docker rmi  image-id</td>
<td align="center">删除镜像</td>
</tr>
</tbody></table>
<h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">docker run –name container-name -d image-name||eg:docker run –name mytomcat -d tomcat:latest</td>
<td align="center">–name:自定义容器名||-d:后台运行||image-name:指定镜像模板</td>
</tr>
<tr>
<td align="center">docker ps</td>
<td align="center">查看运行中的容器||-a可以查看所有容器</td>
</tr>
<tr>
<td align="center">docer stop container -name/container-id</td>
<td align="center">停止容器</td>
</tr>
<tr>
<td align="center">docer start container -name/container-id</td>
<td align="center">启动容器</td>
</tr>
<tr>
<td align="center">docker rm container-id</td>
<td align="center">删除容器</td>
</tr>
<tr>
<td align="center">-p 6379:6379</td>
<td align="center">主机端口映射到容器端口</td>
</tr>
<tr>
<td align="center">docker logs container-name/container-id</td>
<td align="center">查看容器日志</td>
</tr>
<tr>
<td align="center">docker exec -it 容器ID /bin/bash</td>
<td align="center">进入容器</td>
</tr>
<tr>
<td align="center">exit/Ctrl+P+Q</td>
<td align="center">退出容器</td>
</tr>
</tbody></table>
<ul>
<li>启动MySQL</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -p 3306:3306 --name mysqlInstance e MYSQL_ROOT_PASSWORD=密码 -d mysql</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动Redis</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run --name redis -p 6379:6379 -v /docker/redis/data:/data -v /docker/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs学习</title>
    <url>/2021/07/26/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>web服务: express, koa, hapi<br>模板引擎: handlebars, ejs, jade<br>前端打包: webpak, fis,<br>任务管理: gulp<br>单元测试: karma, mocha, jasmine<br>包管理器: npm, cnpm, yarn<br>守护进程: pm2</p>
<a id="more"></a>

<h5 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h5><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> npm init </span><br></pre></td></tr></table></figure>

<h6 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 安装但不写入package.json； </span></span><br><span class="line"><span class="variable">$</span> npm install xxx</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 安装并写入package.json的&quot;dependencies&quot;中；</span></span><br><span class="line"><span class="variable">$</span> npm install xxx –S </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 安装并写入package.json的&quot;evDependencies&quot;中;</span></span><br><span class="line"><span class="variable">$</span> npm install xxx –D</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>S（等同于–save）表示项目打包时会将该依赖包一并打包；-D（等同于–save-dev）表示该依赖包仅在开发环境下使用，正式打包不会加到项目中。</p>
<h5 id="express模块"><a href="#express模块" class="headerlink" title="express模块"></a>express模块</h5><h6 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> npx express<span class="literal">-generator</span> -<span class="literal">-view</span>=ejs 项目名字</span><br></pre></td></tr></table></figure>

<h6 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> nmp i</span><br></pre></td></tr></table></figure>

<h6 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> npm <span class="built_in">start</span></span><br></pre></td></tr></table></figure>

<h6 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h6><ul>
<li><p>bin: 启动目录 里面包含了一个启动文件 www 默认监听端口是 3000 (不用)</p>
</li>
<li><p>node_modules: 所有安装的依赖模块 都在这个文件夹里面</p>
</li>
<li><p>public: 所有的前端静态资源 html css image js</p>
</li>
<li><p>routes: 放的是 路由 文件 (默认有两个)路由主要定义 url 和 资源 的映射关系 ( 一一对应关系 )主要用来接收前端发送的请求 响应数据给前端</p>
</li>
<li><p>views: 主要放置 ejs 后端模板文件</p>
</li>
<li><p>app.js: 入口文件(主文件) 总路由 (其他的路由 要由它来分配)</p>
</li>
<li><p>package.json: 包描述文件 最重要的是 依赖的模板列表 dependencies</p>
</li>
</ul>
<h6 id="app-js文件"><a href="#app-js文件" class="headerlink" title="app.js文件"></a>app.js文件</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> indexRouter = <span class="built_in">require</span>(<span class="string">&#x27;./routes/index&#x27;</span>);<span class="comment">//引入路由文件</span></span><br><span class="line"><span class="keyword">var</span> app = express(); <span class="comment">//创建服务器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置服务器模板渲染引擎</span></span><br><span class="line">app.set(<span class="string">&#x27;views&#x27;</span>, path.join(__dirname, <span class="string">&#x27;views&#x27;</span>));</span><br><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;ejs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">app.use(logger(<span class="string">&#x27;dev&#x27;</span>)); <span class="comment">//设置日为开发者模式</span></span><br><span class="line"></span><br><span class="line">app.use(express.json()); <span class="comment">//让express处理 json 数据</span></span><br><span class="line"></span><br><span class="line">app.use(express.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;)); <span class="comment">//用于接收 POSt 请求数据</span></span><br><span class="line"></span><br><span class="line">app.use(cookieParser()); <span class="comment">//处理 cookie 数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态资源设置；__dirnam代表当前文件的路径</span></span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">&#x27;public&#x27;</span>))); </span><br><span class="line"><span class="comment">//路由(API)</span></span><br><span class="line">app.use(<span class="string">&#x27;/&#x27;</span>, indexRouter);</span><br><span class="line">app.use(<span class="string">&#x27;/users&#x27;</span>, usersRouter);</span><br></pre></td></tr></table></figure>

<h5 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h5><h6 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> npm i mysql -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>

<h6 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> myConnection = mysql.createConnection(&#123;</span><br><span class="line">    host:<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    user:<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    database:<span class="string">&#x27;guoxinan&#x27;</span>,</span><br><span class="line">    port:<span class="number">3306</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">sql,option,callback</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//打开连接</span></span><br><span class="line">    myConnection.connect();</span><br><span class="line">    <span class="comment">//sql操作</span></span><br><span class="line">    myConnection.query(sql,option,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;操作数据库失败&quot;</span>,err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        callback(data);</span><br><span class="line">    &#125;);</span><br><span class="line">    myConnection.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">MYSQL：ER_NOT_SUPPORTED_AUTH_MODE:Client does not support authentication protocol</span><br></pre></td></tr></table></figure>

<p>原因:8.0mysql引入了caching_sha2_password模块作为默认身份验证插件，nodejs还没有跟进</p>
<p>解决办法:进入mysql修改密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;自己的密码&#39;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库</title>
    <url>/2021/07/08/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h4 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h4><p>在MySQL中的数据用不同的技术存储在文件（内存中），通过<code>show engines</code>来查看MySQL支持的存储引擎。</p>
<p>MySQL中常用存储引擎：InnoDB,MyISAM,MEMORY等，其中InnoDB支持事务，MyISAM,MEMORY不支持</p>
<a id="more"></a>

<h5 id="事物四大特性（ACID）"><a href="#事物四大特性（ACID）" class="headerlink" title="事物四大特性（ACID）"></a>事物四大特性（ACID）</h5><p>A (Atomicity) : 原子性 </p>
<p>要么全做，要么全不做</p>
<p>C (Consistency) : 一致性</p>
<p>一致性与原子性密切相关，要么全做要么全不做，否则就会造成数据的不一致</p>
<p>I (Isolation) : 隔离性</p>
<p>一个事务的执行不能被其他事务所干扰，比如银行汇钱两边都有操作</p>
<p>D (Durability) : 持久性</p>
<p>数据库的改变是永久的，比如要落入磁盘</p>
<h5 id="事务的使用"><a href="#事务的使用" class="headerlink" title="事务的使用"></a>事务的使用</h5><ul>
<li><p>隐式事务：事务没有明显的开启和结束标记，比如insert、update、delete语句</p>
</li>
<li><p>显式事务：事务具有明显的开启和结束标记，前提必须设置自动提交功能为禁用<code>set autocommit=0;</code></p>
</li>
</ul>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>对于同时运行的多个事务，当访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题</p>
<ul>
<li>脏读：T1读取了T2修改但未提交的数据，若T2回滚，T1读取的内容是无效的</li>
<li>不可重复读：T1读取了之后T2更新了数据，T1再读取数据不同</li>
<li>幻读：T1读取了之后T2插入了数据，T1再读取数据不同</li>
</ul>
<p>不可重复读和幻读的区别：对于前者,  只需要锁住满足条件的记录<br>对于后者,  要锁住满足条件及其相近的记录，不可重复读重点在于update和delete，而幻读的重点在于insert，所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。</p>
<h5 id="MySQL的隔离级别"><a href="#MySQL的隔离级别" class="headerlink" title="MySQL的隔离级别"></a>MySQL的隔离级别</h5><p>默认：REPEATABLE READ(可重复读)</p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/image-20210706150227711.png"></p>
<table>
<thead>
<tr>
<th align="center">作用</th>
<th align="center">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">查看当前隔离级别</td>
<td align="center"><code>select @@tx_isolation </code></td>
</tr>
<tr>
<td align="center">设置当前连接隔离级别</td>
<td align="center"><code>set transcation isolation level read committed</code></td>
</tr>
<tr>
<td align="center">设置全局隔离级别</td>
<td align="center"><code>set global transcation isolation level read committed</code></td>
</tr>
</tbody></table>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><ul>
<li><p>排他锁 ：也叫写锁 (X锁)</p>
</li>
<li><p>共享锁 ：也叫读锁 (S锁)</p>
</li>
</ul>
<h5 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h5><ul>
<li>一级封锁协议（解决丢失修改）</li>
</ul>
<p>修改时，必须加X锁</p>
<ul>
<li>二级封锁协议（解决脏读数据）</li>
</ul>
<p>读的时候，加S锁，用完就放</p>
<ul>
<li>三级封锁协议（解决不可重复读）</li>
</ul>
<p>读的时候，加S锁，直到结束</p>
<h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTJiNDExSzdadQ==">https://www.bilibili.com/video/BV12b411K7Zu<i class="fa fa-external-link-alt"></i></span> 180P</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>MySQL</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis相关使用</title>
    <url>/2020/11/13/Redis%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h4><p>Redis是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSI C编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的键值对存储数据库，其具备如下特性：</p>
<a id="more"></a>

<ul>
<li>基于内存运行，性能高效</li>
<li>支持分布式，理论上可以无限扩展</li>
<li>key-value存储系统</li>
<li>开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API</li>
</ul>
<h4 id="Nosql"><a href="#Nosql" class="headerlink" title="Nosql"></a>Nosql</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><ul>
<li>NoSQL(NoSQL = Not Only SQL )，意即”不仅仅是SQL”，泛指非关系型的数据库。</li>
<li>NoSQL不依赖业务逻辑方式存储,而以简单的key-value模式存储,因此大大的增加了数据库的扩展能力</li>
<li>不遵循SQL标准</li>
<li>不支持ACID(原子性,一致性,独立性,持久性)</li>
<li>远超SQL的性能</li>
</ul>
<h5 id="NoSQL适用场景"><a href="#NoSQL适用场景" class="headerlink" title="NoSQL适用场景"></a>NoSQL适用场景</h5><ul>
<li>对数据的高并发读写</li>
<li>海量数据的读写</li>
<li>对数据高可扩展性的</li>
</ul>
<h5 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h5><ul>
<li>需要事务支持</li>
<li>基于sql的结构化查询存储,处理复杂的关系,需要及席查询(条件查询)</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h5><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">systemctl start redis</td>
<td align="center">启动redis</td>
</tr>
<tr>
<td align="center">systemctl stop redis</td>
<td align="center">停止redis</td>
</tr>
<tr>
<td align="center">systemctl status redis</td>
<td align="center">查看redis运行状态</td>
</tr>
<tr>
<td align="center">ps ef</td>
<td align="center">grep redis</td>
</tr>
<tr>
<td align="center">redis-cli</td>
<td align="center">开启(本机)客户端</td>
</tr>
<tr>
<td align="center">redis-cli -h 127.0.0.1 -p6379</td>
<td align="center">开启客户端</td>
</tr>
</tbody></table>
<h5 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h5><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">keys *</td>
<td align="center">查询当前库的所有键</td>
</tr>
<tr>
<td align="center">exists <key></td>
<td align="center">判断某个键是否存在</td>
</tr>
<tr>
<td align="center">type <key></td>
<td align="center">查看键的类型</td>
</tr>
<tr>
<td align="center">del  <key></td>
<td align="center">删除某个键</td>
</tr>
<tr>
<td align="center">expire <key> <seconds></td>
<td align="center">为键值设置过期的时间,单位秒</td>
</tr>
<tr>
<td align="center">ttl <key></td>
<td align="center">查看还有多少秒过期,-1表示永不过期,-2表示已过期</td>
</tr>
<tr>
<td align="center">dbsize</td>
<td align="center">查看当前数据库的key的数量</td>
</tr>
<tr>
<td align="center">Flushdb</td>
<td align="center">清空当前库</td>
</tr>
<tr>
<td align="center">Flushall</td>
<td align="center">清空所有库</td>
</tr>
</tbody></table>
<h5 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h5><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">get <key></td>
<td align="center">查询对应键值</td>
</tr>
<tr>
<td align="center">set <key><value></td>
<td align="center">添加键值对</td>
</tr>
<tr>
<td align="center">append <key><value></td>
<td align="center">将value最佳到指定键值末</td>
</tr>
<tr>
<td align="center">strlen <key></td>
<td align="center">获得值的长度</td>
</tr>
<tr>
<td align="center">setnx <key><value></td>
<td align="center">只有在key不存在时设置key的值</td>
</tr>
<tr>
<td align="center">incr / decr <key></td>
<td align="center">将key中存储的数字值增1/减1(只能对数字值操作,如果为空,新增值为1/-1)</td>
</tr>
<tr>
<td align="center">incrby / decrby <key> &lt;步长&gt;</td>
<td align="center">将key中存储的数字增减,自定义步长</td>
</tr>
<tr>
<td align="center">mset<key1><value1> / mget <key1> <key2></td>
<td align="center">多个添加获取</td>
</tr>
<tr>
<td align="center">getrange <key><start><end></td>
<td align="center">获取值的范围,类似java中的substring</td>
</tr>
<tr>
<td align="center">setrange <key><start><value></td>
<td align="center">用<value>覆写<key>所存储的字符串值,从<start>开始</td>
</tr>
</tbody></table>
<p> 默认16个数据库,类似数组下标从0开始,初始默认使用0号库</p>
<p>使用 select <id> 来切换数据库</p>
<h4 id="五种数据结构"><a href="#五种数据结构" class="headerlink" title="五种数据结构"></a>五种数据结构</h4><p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201204163643.png"></p>
<h5 id="1-String-字符串类型"><a href="#1-String-字符串类型" class="headerlink" title="1.String 字符串类型"></a>1.String 字符串类型</h5><p>是redis中最基本的数据类型，一个key对应一个value。</p>
<p>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</p>
<p>使用：get 、 set 、 del 、 incr、 decr 等</p>
<p>实战场景：</p>
<ol>
<li><p>缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</p>
</li>
<li><p>计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</p>
</li>
<li><p>session：常见方案spring session + redis实现session共享</p>
</li>
</ol>
<h5 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h5><p>是一个Mapmap，指值本身又是一种键值对结构，如 value={ {field1,value1},……fieldN,valueN} }</p>
<p>使用：所有hash的命令都是 h  开头的   hget 、hset 、 hdel 等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user name1 hao</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user email1 hao@163.com</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) &quot;name1&quot;</span><br><span class="line">2) &quot;hao&quot;</span><br><span class="line">3) &quot;email1&quot;</span><br><span class="line">4) &quot;hao@163.com&quot;</span><br><span class="line">127.0.0.1:6379&gt; hget user user</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; hget user name1</span><br><span class="line">&quot;hao&quot;</span><br><span class="line">127.0.0.1:6379&gt; hset user name2 xiaohao</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user email2 xiaohao@163.com</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) &quot;name1&quot;</span><br><span class="line">2) &quot;hao&quot;</span><br><span class="line">3) &quot;email1&quot;</span><br><span class="line">4) &quot;hao@163.com&quot;</span><br><span class="line">5) &quot;name2&quot;</span><br><span class="line">6) &quot;xiaohao&quot;</span><br><span class="line">7) &quot;email2&quot;</span><br><span class="line">8) &quot;xiaohao@163.com&quot;</span><br></pre></td></tr></table></figure>

<p>实战场景：</p>
<ol>
<li>缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。</li>
</ol>
<h5 id="3-链表"><a href="#3-链表" class="headerlink" title="3.链表"></a>3.链表</h5><p>List 说白了就是链表（redis 使用双端链表实现的 List），是有序的，value可以重复，可以通过下标取出对应的value值，左右两边都能进行插入和删除数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mylist 1 2 ll ls mem</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;mem&quot;</span><br><span class="line">2) &quot;ls&quot;</span><br><span class="line">3) &quot;ll&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p>实战场景：</p>
<p>1.timeline：例如微博的时间轴，有人发布微博，用lpush加入时间轴，展示新的列表信息。</p>
<h5 id="4-Set-集合"><a href="#4-Set-集合" class="headerlink" title="4.Set  集合"></a>4.Set  集合</h5><p>集合类型也是用来保存多个字符串的元素，但和列表不同的是集合中 </p>
<ol>
<li>不允许有重复的元素</li>
<li>集合中的元素是无序的，不能通过索引下标获取元素</li>
<li>支持集合间的操作，可以取多个集合取交集、并集、差集</li>
</ol>
<p>使用：命令都是以s开头的 sset 、srem、scard、smembers、sismember</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset hao hao1 xiaohao hao</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) &quot;xiaohao&quot;</span><br><span class="line">2) &quot;hao1&quot;</span><br><span class="line">3) &quot;hao&quot;</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset hao</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>实战场景;</p>
<ol>
<li><p>标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</p>
</li>
<li><p>点赞，或点踩，收藏等，可以放到set中实现</p>
</li>
</ol>
<h5 id="5-zset-有序集合"><a href="#5-zset-有序集合" class="headerlink" title="5.zset 有序集合"></a>5.zset 有序集合</h5><p>有序集合和集合有着必然的联系，保留了集合不能有重复成员的特性，区别是，有序集合中的元素是可以排序的，它给每个元素设置一个分数，作为排序的依据。</p>
<p>使用： 有序集合的命令都是 以 z 开头  zadd 、 zrange、 zscore</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myscoreset 100 hao 90 xiaohao</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myscoreset 0 -1</span><br><span class="line">1) &quot;xiaohao&quot;</span><br><span class="line">2) &quot;hao&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myscoreset hao</span><br><span class="line">&quot;100&quot;</span><br></pre></td></tr></table></figure>

<p>实战场景：</p>
<ol>
<li>排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</li>
</ol>
<h4 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h4><h5 id="ip地址的绑定-bind"><a href="#ip地址的绑定-bind" class="headerlink" title="ip地址的绑定(bind)"></a>ip地址的绑定(bind)</h5><ul>
<li>默认情况下bind = 127.0.0.1只能接受本机访问,不写无限制接收任何ip访问(生产环境要写应用服务器的地址)</li>
<li>如果开启了protexted-mode,在没有设定bind ip 且没有设密码的情况下,只允许接收本机访问</li>
</ul>
<h5 id="tcp-backlog"><a href="#tcp-backlog" class="headerlink" title="tcp-backlog"></a>tcp-backlog</h5><ul>
<li>请求到达后至少接受进程处理前的队列</li>
<li>backlog队列总和 = 未完成三次握手队列 + 已经完成三次握手的队列</li>
<li>高并发环境tcp-backlog设置值跟超时时限内的Redis吞吐量决定</li>
</ul>
<h5 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h5><ul>
<li>一个空闲的客户端维持多少秒会关闭,0为永不关闭</li>
</ul>
<h5 id="TCP-keepalive"><a href="#TCP-keepalive" class="headerlink" title="TCP keepalive"></a>TCP keepalive</h5><ul>
<li>对访问客户端的一种心跳检测,每n秒检测一次,官方推荐为60秒</li>
</ul>
<h5 id="requirepass"><a href="#requirepass" class="headerlink" title="requirepass"></a>requirepass</h5><ul>
<li>设置永久密码</li>
</ul>
<h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><h5 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="连接Redis"><a href="#连接Redis" class="headerlink" title="连接Redis"></a>连接Redis</h5> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;xxx.xxx.xx.xx&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">jedis.ping();</span><br><span class="line">jedus.close();</span><br></pre></td></tr></table></figure>

<h4 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul>
<li><p>Redis事务是一个单独的隔离操作: 事务中的所有命令都会序列化, 按顺序的执行,事务在执行的过程中, 不iu被其他客户端发送来的命令请求所打断</p>
</li>
<li><p>Redis事务的主要作用就是串联多个命令防止别人的命令插队</p>
</li>
</ul>
<h5 id="Multi-Exec-discard"><a href="#Multi-Exec-discard" class="headerlink" title="Multi, Exec, discard"></a>Multi, Exec, discard</h5><ul>
<li>从输入Multi命令开始, 输入的命令都会依次进入命令队列中, 但不会执行, 直到输入Exec后, Redis会将之前的命令队列中的命令依次执行.</li>
<li>组队的过程中可以通过discard来放弃组队.</li>
</ul>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201115155543.png"></p>
<h5 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h5><ul>
<li>组队中某个命令如果出现了报告错误, 执行时整个的队友队列都会被取消</li>
</ul>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201115155931.png" alt="事务的错误处理"></p>
<ul>
<li>如果执行阶段某个命令报出了错误, 则只有报错的命令不会被执行, 而其他的命令都会执行,不会回滚</li>
</ul>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201115160127.png" alt="事务的错误处理"></p>
<h5 id="WATCH-监视"><a href="#WATCH-监视" class="headerlink" title="WATCH (监视)"></a>WATCH (监视)</h5><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个)key ，如果在事务执行之前这个(或这些) key被其他命令所改动，那么事务将被打断，unwatch取消监视</p>
<h4 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h4><p>Redis提供了2个不同形式的持久化方式</p>
<h5 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h5><ul>
<li><p>在指定的时间间隔内将内存中的数据集快照(Snapshot)写入磁盘，它恢复时是将快照文件直接读到内存里。</p>
</li>
<li><p>Redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能,如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p>
</li>
<li><p>RDB保存的文件在redis.conf中配置文件名称,默认为dump.rdb,保存路径也可修改</p>
</li>
<li><p>RDB的保存策略 </p>
<p>save    900    1(900秒内保存1次)</p>
</li>
</ul>
<h5 id="AOF-Append-Of-File"><a href="#AOF-Append-Of-File" class="headerlink" title="AOF(Append Of File)"></a>AOF(Append Of File)</h5><ul>
<li>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</li>
<li>AOF默认不开启, 需要在配置文件中配置  apeendonly 为 yes</li>
<li>AOF与RDB同时开启, 以AOF为准</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Session共享的实现</title>
    <url>/2020/12/01/Session%E5%85%B1%E4%BA%AB%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="Session共享"><a href="#Session共享" class="headerlink" title="Session共享"></a>Session共享</h3><p> Session 共享是指在一个浏览器访问多个 Web 服务时，服务端的 Session 数据需要共享。</p>
<a id="more"></a>

<h4 id="cookie加密的方式保存在客户端"><a href="#cookie加密的方式保存在客户端" class="headerlink" title="cookie加密的方式保存在客户端"></a>cookie加密的方式保存在客户端</h4><ul>
<li><p>优点：减轻服务器端压力</p>
</li>
<li><p>缺点：受到cookie大小限制，因为每次请求会在头部附带cookie信息，占用一定的带宽。另外，这种方式在用户禁用cookie的情况下无效。这种方式不常用。</p>
</li>
</ul>
<h4 id="服务器间同步"><a href="#服务器间同步" class="headerlink" title="服务器间同步"></a>服务器间同步</h4><p>服务器间同步比如tomcat集群：通过配置tomcat，实现session共享。每个tomcat都会在局域网中广播自己的session信息，同时监听其他tomcat广播的session，一旦自己的session发生变化，其他的tomcat能够感知到的，同时就可以同步自己的session和它一样。</p>
<ul>
<li>缺点：当集群服务器数量比较大如200台，每一台服务器的tomcat都需要广播自己的session，同时监听另外199台，此时，服务器的大量资源都用来处理session同步的事情，用户正常的访问就会受到影响。要视部署的tomcat集群数量等来定是否使用这种方式。</li>
</ul>
<h4 id="基于分布式缓存"><a href="#基于分布式缓存" class="headerlink" title="基于分布式缓存"></a>基于分布式缓存</h4><p>基于分布式缓存的session共享机制</p>
<p>使用redis取代session保存用户信息，这种方式比较常用</p>
<h3 id="SpringSession"><a href="#SpringSession" class="headerlink" title="SpringSession"></a>SpringSession</h3><p>Spring Session 是 Spring 的项目之一。Spring Session 提供了一套创建和管理 Servlet HttpSession 的方案，默认采用外置的 Redis 来存储 Session 数据，以此来解决 Session 共享的 问题。</p>
<h4 id="基本实现原理"><a href="#基本实现原理" class="headerlink" title="基本实现原理"></a>基本实现原理</h4><p>SpringSession从底层全方位”接管”了Tomcat对Session的管理</p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201201155030.png" alt="SpringSession基本实现原理"></p>
<h5 id="SessionRepositoryFilter"><a href="#SessionRepositoryFilter" class="headerlink" title="SessionRepositoryFilter"></a>SessionRepositoryFilter</h5><p>利用Filter原理,在每次请求到达目标方法之前,将原生HttpSetvletRequest / HttpSetvletResponse对象包装为SessionRepository / ResponseWrapper </p>
]]></content>
  </entry>
  <entry>
    <title>git&amp;Linux基本命令</title>
    <url>/2020/11/07/git-Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>git和Linux的一些基本命令操作</p>
<a id="more"></a>

<h5 id="git"><a href="#git" class="headerlink" title="git"></a>git</h5><h6 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Your Name&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;wrote a readme file&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff readme.txt </span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span>		$ git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard 1094a</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure>



<h6 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin https://.....($ git remote add origin git@github.com:michaelliao/learngit.git)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin(远程仓库名) master(本地分支名) master(远程分支名)  (-u首次建立关联)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@github.com:michaelliao/gitskills.git</span></span><br><span class="line">git remote rm origin</span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin  master(本地分支名) master(远程分支名)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream-to=origin/dev dev（绑定本地分支）</span></span><br></pre></td></tr></table></figure>

<h6 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dev（$ git switch -c dev）===</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev（$ git switch master）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d dev（not merge  -D）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase（直线提交历史）</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">git stash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash list</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br><span class="line"><span class="meta">$</span><span class="bash">git stash apply(恢复不删除)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick 4c805e2</span></span><br></pre></td></tr></table></figure>

<h6 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag v0.9 [f52c633]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [标签名]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show v0.9</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v0.9		删除标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin v1.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags	推送所有标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/v0.9</span></span><br></pre></td></tr></table></figure>

<h6 id="多关联"><a href="#多关联" class="headerlink" title="多关联"></a>多关联</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add github git@github.com:michaelliao/learngit.git</span><br><span class="line">git remote add gitee git@gitee.com:liaoxuefeng/learngit.git</span><br><span class="line">git push github master</span><br><span class="line">git push gitee master</span><br></pre></td></tr></table></figure>

<h6 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.co checkout</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.ci commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.br branch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><h6 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls: 列出目录	</span><br><span class="line">cd：切换目录	(Change Directory)</span><br><span class="line">pwd：显示目前的目录	(Print Working Directory)</span><br><span class="line">mkdir：创建一个新的目录	 (make directory)</span><br><span class="line">rmdir：删除一个空的目录</span><br><span class="line">cp: 复制文件或目录</span><br><span class="line">rm: 移除文件或目录</span><br><span class="line">mv: 移动文件与目录，或修改文件与目录的名称</span><br><span class="line">dhclient 自动分配地址[BOOTPROTO&#x3D;STATIC	ONBOOT&#x3D;YES	</span><br><span class="line">IPADDR&#x3D;192.168.XX.XXX	NETMASK&#x3D;255.255.255.0 	GATEWAY&#x3D;192.168.XX.X</span><br><span class="line">DNS1&#x3D;119.29.29.29]</span><br></pre></td></tr></table></figure>

<h6 id="用户-组管理"><a href="#用户-组管理" class="headerlink" title="用户/组管理"></a>用户/组管理</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd [user]	useradd [-g]  组名 [user]</span><br><span class="line">passwd [user] </span><br><span class="line">userdel [-r] [user]</span><br><span class="line">id [user]</span><br><span class="line">su [user]</span><br><span class="line"></span><br><span class="line">groupadd [group]</span><br><span class="line">groupdel [group]</span><br><span class="line">gpasswd  -d student root 将用户student从root组删除</span><br><span class="line">usermod [-g] 组名 [user]</span><br></pre></td></tr></table></figure>

<h6 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat [dir] | grep [..]</span><br><span class="line">ls -l /home |grep &quot;!-&quot;|wc -l 查看某文件夹下文件的个数</span><br><span class="line">stat [file]</span><br><span class="line"></span><br><span class="line">[ls,cat,echo...] &gt;&gt;追加</span><br><span class="line">[ls,cat,echo...] &gt;覆盖</span><br><span class="line"></span><br><span class="line">head/tail -n [num] [file]     		tail -f [file]</span><br><span class="line"></span><br><span class="line">ln -s [dir] [name] </span><br><span class="line"></span><br><span class="line">date &quot;+%Y %M %D.....&quot;</span><br><span class="line">cal</span><br><span class="line"></span><br><span class="line">find [scope] -name [name]</span><br><span class="line">find [scope] -user [user]</span><br><span class="line">find [scope] -size  [+-n]</span><br><span class="line"></span><br><span class="line">tar -zcvf [name].tar.gz [files] 打包</span><br><span class="line">tar -zxvf [files] -C [dir] 解压</span><br><span class="line"></span><br><span class="line">rpm [-qa | -qi | qf]</span><br><span class="line">rpm -e [--nodeps(强删)] [name]</span><br><span class="line">rpm -ivh		i=install  v=verbose提示  h=hash进度条</span><br></pre></td></tr></table></figure>

<h6 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown/chgrp [user/group] [file]</span><br><span class="line">chmod u=[rwx],g=[rwx],o=[rwx] [file]</span><br><span class="line">chmod u[+-][rwx],g[+-][rwx],o[+-][rwx] [file]</span><br><span class="line">chomd [777] [file]     (4=r,2=w,1=x)</span><br></pre></td></tr></table></figure>

<h6 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab [-e -l -r]  ([写入 查看 删除])</span><br><span class="line">*/1 * * * * [执行文件/脚本] </span><br></pre></td></tr></table></figure>

<h6 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h</span><br><span class="line">du -axh	文件夹占用</span><br><span class="line">lsblk -f  	查看是否已分配</span><br><span class="line">fdisk /dev/dba	分区</span><br><span class="line">mkfs -t ext4 /dev/sdb1   格式化</span><br><span class="line">mount  /dev/sdb1   /home/newdisk	挂载</span><br><span class="line">/dev/fstab  设置开机自动挂载</span><br></pre></td></tr></table></figure>

<h6 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -aux | grep ...</span><br><span class="line">ps -ef 		-e显示所有进程 -f全格式</span><br><span class="line">kill [-9] 进程号	-9强制</span><br><span class="line">killall 进程名称</span><br><span class="line">top [-d | -i | -p]	-d秒数 -i不显示闲置或僵死 -p指定进程id监控</span><br></pre></td></tr></table></figure>

<h6 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl [status | stop | start | restart | reload ]firewalld</span><br><span class="line">ll /etc/init.d/	</span><br><span class="line">netstat -anp 	-an按一定顺序 -p显示哪个在调用   查看网络服务</span><br></pre></td></tr></table></figure>

<h6 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h6><pre><code>  #!/bin/bash开头
  A=100;
  unset A ---&gt;A=
位置参数变量
$n    第n个参数
$*    整体
$@    分别
$#    参数个数
=====================</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">预定义变量</span><br><span class="line"><span class="meta">$</span><span class="bash">$	当前进程PID</span></span><br><span class="line"><span class="meta">$</span><span class="bash">!	后台运行最后一个PID</span></span><br><span class="line"><span class="meta">$</span><span class="bash">?	最后一次命名的返回状态 0√</span></span><br><span class="line">========================</span><br><span class="line"></span><br><span class="line">运算(2+3)*4</span><br><span class="line"><span class="meta">#</span><span class="bash">方式一$()</span></span><br><span class="line">RESULT1=$(((2+3)*4))</span><br><span class="line"><span class="meta">#</span><span class="bash">方式二$[]  推荐方式</span></span><br><span class="line">RESULT2=$[(2+3)*4]</span><br><span class="line"><span class="meta">#</span><span class="bash">方式三 expr</span></span><br><span class="line">................</span><br><span class="line">==========================</span><br><span class="line">条件判断</span><br><span class="line">if[ condition ] </span><br><span class="line">then</span><br><span class="line">	echo&quot;&quot;</span><br><span class="line">elif[ condirion ] </span><br><span class="line">	echo&quot;&quot;</span><br><span class="line">fi</span><br><span class="line"> -lt小于 -le小于等于  -gt大于 -ge大于等于  -eq等于 -ne不等于</span><br><span class="line">-r/-w/-x 有读/写/执行的权限</span><br><span class="line">-f文件存在并且时一个常规文件 -e文件存在 -d文件存在并是目录</span><br><span class="line">------------------------</span><br><span class="line">case $变量名 in</span><br><span class="line">&quot;值1&quot;)</span><br><span class="line">echo&quot;1&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;值2&quot;)</span><br><span class="line">echo&quot;2&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo&quot;other&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">循环</span><br><span class="line">for 变量 in 值1 值2 值3...</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done </span><br><span class="line">-------------------------</span><br><span class="line">for ((i=0;i&lt;100;i++))</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done </span><br><span class="line">--------------------------</span><br><span class="line">while[ condition ]</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done </span><br><span class="line">===============</span><br><span class="line"></span><br><span class="line">read读取控制台输入</span><br><span class="line">read -p  &quot;读取时的提示符&quot; -t指定读取时等待的时间(秒)	NUM</span><br><span class="line"></span><br><span class="line">================</span><br><span class="line">函数</span><br><span class="line">function getSum()&#123;</span><br><span class="line">	SUM=$[$n1+$n2]</span><br><span class="line">&#125;</span><br><span class="line">read -p &quot;输入n1&quot; n1</span><br><span class="line">read -p &quot;输入n2&quot; n2</span><br><span class="line"><span class="meta">#</span><span class="bash">调用</span></span><br><span class="line">getSum $n1 $n2</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>ab压力测试工具</title>
    <url>/2020/11/15/ab%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h4 id="AB工具简介"><a href="#AB工具简介" class="headerlink" title="AB工具简介"></a>AB工具简介</h4><p>ab全称为：apache bench</p>
<p>ab的原理：ab命令会创建多个并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，它既可以用来测试apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。</p>
<a id="more"></a>

<p>ab命令对发出负载的计算机要求很低，它既不会占用很高CPU，也不会占用很多内存。但却会给目标服务器造成巨大的负载，其原理类似CC攻击。自己测试使用也需要注意，否则一次上太多的负载。可能造成目标服务器资源耗完，严重时甚至导致死机。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install httpd-tools</span></span><br></pre></td></tr></table></figure>

<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-n</td>
<td align="center">请求数(测试会话中所执行的请求个数)</td>
</tr>
<tr>
<td align="center">-c</td>
<td align="center">并发数(一次产生的请求个数</td>
</tr>
<tr>
<td align="center">-t</td>
<td align="center">测试所进行的最大秒数</td>
</tr>
<tr>
<td align="center">-p</td>
<td align="center">指定含有请求数据的文件</td>
</tr>
<tr>
<td align="center">-T</td>
<td align="center">请求数据所使用的Content-type头信息</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">……</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud-netflix使用</title>
    <url>/2020/11/23/spring-cloud-netflix%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="SpringCloud简介"><a href="#SpringCloud简介" class="headerlink" title="SpringCloud简介"></a>SpringCloud简介</h4><p>springCloud是基于SpringBoot的一整套实现微服务的框架。他提供了微服务开发所需的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等组件。</p>
<a id="more"></a>

<h4 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h4><p>Eureka: 服务注册和发现组件<br>Ribbon: 负载均衡<br>Feign: 远程接口的声明式调用<br>Hystrix: 服务的熔断,降级,监控<br><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201120150542.png"></p>
<h5 id="Eureka-注册"><a href="#Eureka-注册" class="headerlink" title="Eureka(注册)"></a>Eureka(注册)</h5><p>服务端配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span>     <span class="comment">#配置当前Eureka服务的主机地址</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span>     <span class="comment">#当前服务本身就是注册中心,不用注册自己</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span>           <span class="comment">#不用从注册中心取回信息</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;/$&#123;server.port&#125;/eureka</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span><span class="comment">//开启服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaMainType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaMainType.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>客户端配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:5000/eureka</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">xxx</span></span><br></pre></td></tr></table></figure>

<h5 id="Ribbon-负载均衡"><a href="#Ribbon-负载均衡" class="headerlink" title="Ribbon(负载均衡)"></a>Ribbon(负载均衡)</h5><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//让RestTemplate具有负载均衡的功能,通过Ribbon访问provider集群</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Feign-声明式调用"><a href="#Feign-声明式调用" class="headerlink" title="Feign(声明式调用)"></a>Feign(声明式调用)</h5><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Feigin依赖有Ribbon, 不需要配置Ribbon</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201120150725105.png" alt="Feign(声明式调用)"></p>
<p>@FeignClient注解</p>
<p>value:</p>
<ul>
<li>表示当前接口和一个Provider对应,注解中value属性指定要用的Provider的微服务名称</li>
<li>要求@RequestMapping注解映射的地址一致</li>
<li>要求方法声明一致</li>
<li>用来获取请求参数的@RequstParam, @PathVariable, @RequestBody不能省略, 两边一致</li>
</ul>
<p>fallbackFactory:</p>
<ul>
<li>指定Provider不可用时提供的备用方案的工厂类型</li>
</ul>
<p>@EnableFeignClients</p>
<ul>
<li>启用Feign客户端功能</li>
</ul>
<h5 id="Hystrix-熔断-降级-监控"><a href="#Hystrix-熔断-降级-监控" class="headerlink" title="Hystrix(熔断,降级,监控)"></a>Hystrix(熔断,降级,监控)</h5><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="熔断-Provider"><a href="#熔断-Provider" class="headerlink" title="熔断(Provider)"></a>熔断(Provider)</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定当前方法出问题时调用的方法</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;MethodName)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br></pre></td></tr></table></figure>

<h6 id="降级-Consumer"><a href="#降级-Consumer" class="headerlink" title="降级(Consumer)"></a>降级(Consumer)</h6><ul>
<li>实现Consumer端服务降级功能</li>
<li>实现FallbackFactory接口要传入@FeignClient标记的接口类型</li>
<li>在create()方法中返回@FeignClient注解标记的接口类型的对象,当Provider调用失败后,会执行这个对象对应的方法</li>
<li>使用@Component将当前对象加入IOC容器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFallBackFactory</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">EmployeeRemoteService</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EmployeeRemoteService <span class="title">create</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmployeeRemoteService() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            .....</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启用</p>
<p>在Consumer的配置文件中启用</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h6 id="监控-Provier"><a href="#监控-Provier" class="headerlink" title="监控(Provier)"></a>监控(Provier)</h6><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">hystrix.stream</span></span><br></pre></td></tr></table></figure>

<p>启动类上加@EnableHystrixDashboard注解启动仪表盘功能</p>
<h5 id="Zuul-网关"><a href="#Zuul-网关" class="headerlink" title="Zuul(网关)"></a>Zuul(网关)</h5><p>添加依赖并使用@EnableZuulProxy开启</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>访问: <span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMTp6dXVs56uv5Y+j">http://127.0.0.1:zuul端口<i class="fa fa-external-link-alt"></i></span> / 微服务名称 / 具体功能地址</p>
<p><strong>ZuulFilter过滤类</strong></p>
<p><code>shouldFilter</code>：返回一个boolean类型来判断该过滤器是否要执行，所以通过此函数可实现过滤器的开关。</p>
<p><code>filterType</code>：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：</p>
<ul>
<li><code>pre</code>：可以在请求被路由之前调用</li>
<li><code>route</code>：在路由请求时候被调用</li>
<li><code>post</code>：在route和error过滤器之后被调用</li>
<li><code>error</code>：处理请求时发生错误时被调用</li>
</ul>
<p><code>filterOrder</code>：通过int值来定义过滤器的执行顺序</p>
<p><code>run</code>：过滤器的具体实现功能。</p>
<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><h6 id="fallback-method-wasn’t-found"><a href="#fallback-method-wasn’t-found" class="headerlink" title="fallback method wasn’t found"></a>fallback method wasn’t found</h6><p> 备用方法 和 原方法 的参数类型，个数不同造成的</p>
<h6 id="Unable-to-connect-to-Command-Metric-Stream"><a href="#Unable-to-connect-to-Command-Metric-Stream" class="headerlink" title="Unable to connect to Command Metric Stream."></a>Unable to connect to Command Metric Stream.</h6><p>dashboard无法显示,控制台显示<span class="exturl" data-url="aHR0cDovL3h4eC54eHgueHg6eHh4L2h5c3RyaXguc3RyZWFt">http://xxx.xxx.xx:xxx/hystrix.stream<i class="fa fa-external-link-alt"></i></span> is not in the allowed list of proxy host names.  If it should be allowed add it to hystrix.dashboard.proxyStreamAllowList. </p>
<p>解决: 配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">dashboard:</span></span><br><span class="line">    <span class="attr">proxy-stream-allow-list:</span> <span class="string">&quot;localhost&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SpringSecurity进行权限控制</title>
    <url>/2020/11/09/%E4%BD%BF%E7%94%A8SpringSecurity%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h3 id="spring-security-简介"><a href="#spring-security-简介" class="headerlink" title="spring security 简介"></a>spring security 简介</h3><p>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它是用于保护基于Spring的应用程序的实际标准。</p>
<p>Spring Security是一个框架，致力于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring Security的真正强大之处在于可以轻松扩展以满足自定义要求</p>
<a id="more"></a>

<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201109124625.png" alt="SpringSecurity的执行流程"></p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201109163442.png"></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="配置xml"><a href="#配置xml" class="headerlink" title="配置xml"></a>配置xml</h4><p>SpringSecurity使用的是过滤器Filter而不是拦截器Interceptor,意味着SpringSecurity能够管理的不仅仅是SpringMVC中的handler请求,还包含Web应用中的所有请求,包括静态资源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFileterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFileterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>filter-name中的名字必须是springSecurityFileterChain才能加载到ioc容器中的Filter</p>
<h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringSecurity 对 Web 应用进行权限管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- SpringSecurity 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- SpringSecurity 标签库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-taglibs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>创建配置类,继承WebSecurityConfigurerAdapter 并重写configure方法,并加入到IOC容器(Spring ioc拦截Service和Mapper,SpringMvc ioc 拦截请求,加在Springmvc时会发生No bean named ‘springSecurityFilterChain’ available错误)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppSecurity</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@EnableWebMvcSecurity注解：在Spring 4.0中已弃用。</p>
<p>WebSecurityConfigurerAdapter类：可以通过重载该类的三个configure()方法来制定Web安全的细节。</p>
<h5 id="configure-WebSecurity-："><a href="#configure-WebSecurity-：" class="headerlink" title="configure(WebSecurity)："></a>configure(WebSecurity)：</h5><p>通过重载该方法，可配置Spring Security的Filter链。</p>
<h5 id="拦截配置-HttpSecurity-："><a href="#拦截配置-HttpSecurity-：" class="headerlink" title="拦截配置(HttpSecurity)："></a>拦截配置(HttpSecurity)：</h5><p>通过重载该方法，可配置如何通过拦截器保护请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeRequests()	<span class="comment">//对请求进行授权</span></span><br><span class="line">            <span class="comment">//访问&quot;/&quot;和&quot;/home&quot;路径的请求都允许</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">            .permitAll()</span><br><span class="line">            <span class="comment">//而其他的请求都需要认证</span></span><br><span class="line">            .anyRequest()</span><br><span class="line">            .authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            <span class="comment">//修改Spring Security默认的登陆界面</span></span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginPage(<span class="string">&quot;/to/login/page.html&quot;</span>)</span><br><span class="line">            .loginProcessingUrl(<span class="string">&quot;/do/login.html&quot;</span>)</span><br><span class="line">            .permitAll()			<span class="comment">//无条件访问</span></span><br><span class="line">            .antMathers(url)		<span class="comment">//对url设置访问要求</span></span><br><span class="line">            .hasRole()				<span class="comment">//要求用户具备的角色</span></span><br><span class="line">            .usernameParameter(<span class="string">&quot;loginAcct&quot;</span>)</span><br><span class="line">            .passwordParameter(<span class="string">&quot;userPwd&quot;</span>)</span><br><span class="line">            .defaultSuccessUrl(<span class="string">&quot;/to/main/page.html&quot;</span>)</span><br><span class="line">            .and()</span><br><span class="line">            .logout()	</span><br><span class="line">            .logoutUrl(<span class="string">&quot;/do/logout.html&quot;</span>)</span><br><span class="line">            .exceptionHandling()	<span class="comment">//指定异常处理器</span></span><br><span class="line"><span class="comment">//            .accessDeniedPage(&quot;/to/error/page.html&quot;)	//访问被拒时去的页面</span></span><br><span class="line">            .accessDeniedHandler(<span class="keyword">new</span> AccessDeniedHandler()) <span class="comment">//定制异常处理</span></span><br><span class="line">			.rememberMe()   <span class="comment">//默认参数remember-me(cookie)</span></span><br><span class="line">	</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td>access(String)</td>
<td align="left">如果给定的SpEL表达式计算结果为true，就允许访问</td>
</tr>
<tr>
<td>anonymous()</td>
<td align="left">允许匿名用户访问</td>
</tr>
<tr>
<td>authenticated()</td>
<td align="left">允许认证过的用户访问</td>
</tr>
<tr>
<td>denyAll()</td>
<td align="left">无条件拒绝所有访问</td>
</tr>
<tr>
<td>fullyAuthenticated()</td>
<td align="left">如果用户是完整认证的话（不是通过Remember-me功能认证的），就允许访问</td>
</tr>
<tr>
<td>hasAnyAuthority(String…)</td>
<td align="left">如果用户具备给定权限中的某一个的话，就允许访问</td>
</tr>
<tr>
<td>hasAnyRole(String…)</td>
<td align="left">如果用户具备给定角色中的某一个的话，就允许访问</td>
</tr>
<tr>
<td><strong>hasAuthority(String)</strong></td>
<td align="left"><strong>如果用户具备给定权限的话，就允许访问</strong></td>
</tr>
<tr>
<td>hasIpAddress(String)</td>
<td align="left">如果请求来自给定IP地址的话，就允许访问</td>
</tr>
<tr>
<td><strong>hasRole(String)</strong></td>
<td align="left"><strong>如果用户具备给定角色的话，就允许访问</strong></td>
</tr>
<tr>
<td>not()</td>
<td align="left">对其他访问方法的结果求反</td>
</tr>
<tr>
<td>permitAll()</td>
<td align="left">无条件允许访问</td>
</tr>
<tr>
<td>rememberMe()</td>
<td align="left">如果用户是通过Remember-me功能认证的，就允许访问</td>
</tr>
<tr>
<td>usernameParameter()</td>
<td align="left">定制登录账号请求参数名</td>
</tr>
<tr>
<td>passwordParameter()</td>
<td align="left">定制登录密码请求参数名</td>
</tr>
<tr>
<td>defaultSuccessUrl()</td>
<td align="left">登录成功后去往的页面</td>
</tr>
<tr>
<td>loginProcessingUrl()</td>
<td align="left">登录放行</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>安全表达式</th>
<th>计算结果</th>
</tr>
</thead>
<tbody><tr>
<td>authentication</td>
<td>用户认证对象</td>
</tr>
<tr>
<td>denyAll</td>
<td>结果始终为false</td>
</tr>
<tr>
<td>hasAnyRole(list of roles)</td>
<td>如果用户被授权指定的任意权限，结果为true</td>
</tr>
<tr>
<td>hasRole(role)</td>
<td>如果用户被授予了指定的权限，结果 为true</td>
</tr>
<tr>
<td>hasIpAddress(IP Adress)</td>
<td>用户地址</td>
</tr>
<tr>
<td>isAnonymous()</td>
<td>是否为匿名用户</td>
</tr>
<tr>
<td>isAuthenticated()</td>
<td>不是匿名用户</td>
</tr>
<tr>
<td>isFullyAuthenticated</td>
<td>不是匿名也不是remember-me认证</td>
</tr>
<tr>
<td>isRemberMe()</td>
<td>remember-me认证</td>
</tr>
<tr>
<td>permitAll</td>
<td>始终true</td>
</tr>
<tr>
<td>principal</td>
<td>用户主要信息对象</td>
</tr>
</tbody></table>
<h5 id="用户权限配置-AuthenticationManagerBuilder-："><a href="#用户权限配置-AuthenticationManagerBuilder-：" class="headerlink" title="用户权限配置(AuthenticationManagerBuilder)："></a>用户权限配置(AuthenticationManagerBuilder)：</h5><p>通过重载该方法，可配置user-detail（用户详细信息）服务。 </p>
<h6 id="在内存中装配角色-权限信息"><a href="#在内存中装配角色-权限信息" class="headerlink" title="在内存中装配角色,权限信息"></a>在内存中装配角色,权限信息</h6><p>没有角色和权限的用户无法登录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       auth.inMemoryAuthentication()</span><br><span class="line">           .passwordEncoder(<span class="keyword">new</span> BCryptPasswordEncoder())</span><br><span class="line">           .withUser(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">           .password(<span class="keyword">new</span> BCryptPasswordEncoder().encode(<span class="string">&quot;123123&quot;</span>))</span><br><span class="line">           .roles(<span class="string">&quot;ADMIN&quot;</span>)	<span class="comment">//设置角色</span></span><br><span class="line">           .and()</span><br><span class="line">           .withUser(<span class="string">&quot;qwe&quot;</span>)</span><br><span class="line">           .password(<span class="keyword">new</span> BCryptPasswordEncoder().encode(<span class="string">&quot;123123&quot;</span>))</span><br><span class="line">           .authorities(<span class="string">&quot;UPDATE&quot;</span>);	<span class="comment">//设置权限</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><em>注意:SpringSecurity会在角色字符串前面加”ROLE”前缀,从数据库查询得到的用户信息,角色信息,权限信息需要之际手动组装,组装时同样要在角色字符串前面加”ROLE_”</em></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">accountExpired(boolean)</td>
<td align="left">定义账号是否已经过期</td>
</tr>
<tr>
<td align="left">accountLocked(boolean)</td>
<td align="left">定义账号是否已经锁定</td>
</tr>
<tr>
<td align="left">and()</td>
<td align="left">用来连接配置</td>
</tr>
<tr>
<td align="left">authorities(GrantedAuthority…)</td>
<td align="left">授予某个用户一项或多项权限</td>
</tr>
<tr>
<td align="left">authorities(List)</td>
<td align="left">授予某个用户一项或多项权限</td>
</tr>
<tr>
<td align="left">authorities(String…)</td>
<td align="left">授予某个用户一项或多项权限</td>
</tr>
<tr>
<td align="left">credentialsExpired(boolean)</td>
<td align="left">定义凭证是否已经过期</td>
</tr>
<tr>
<td align="left">disabled(boolean)</td>
<td align="left">定义账号是否已被禁用</td>
</tr>
<tr>
<td align="left">password(String)</td>
<td align="left">定义用户的密码</td>
</tr>
<tr>
<td align="left">roles(String…)</td>
<td align="left">授予某个用户一项或多项角色</td>
</tr>
<tr>
<td align="left">inMemoryAuthentication()</td>
<td align="left">在内存中完成账号密码检测</td>
</tr>
<tr>
<td align="left">withUser()</td>
<td align="left">定义账号</td>
</tr>
</tbody></table>
<h6 id="根据表单提交的用户名从数据库查询User对象-并装配角色-权限信息"><a href="#根据表单提交的用户名从数据库查询User对象-并装配角色-权限信息" class="headerlink" title="根据表单提交的用户名从数据库查询User对象,并装配角色,权限信息"></a>根据表单提交的用户名从数据库查询User对象,并装配角色,权限信息</h6><p>思路:</p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201110162503.png" alt="根据表单提交的用户名从数据库查询User对象,并装配角色,权限信息"></p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201110162818.png"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//1.数据库查询admin对象</span></span><br><span class="line">        Admin admin = AdminMapper.select....byName();</span><br><span class="line">        <span class="comment">//2.给admin设置角色权限信息</span></span><br><span class="line">        List&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> ArrayList&lt;GrantedAuthority&gt;();</span><br><span class="line">        authorities.add(<span class="keyword">new</span> SimpleGrantedAuthority(<span class="string">&quot;ROLE_ADMIN&quot;</span>));</span><br><span class="line">        authorities.add(<span class="keyword">new</span> SimpleGrantedAuthority(<span class="string">&quot;UPDATE&quot;</span>));</span><br><span class="line">        <span class="comment">//3.把admin对象和authorities封装到UserDetails中</span></span><br><span class="line">        String password = admin.getPassword();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(username,password,authorities);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>	</span><br><span class="line">MyUserDetailsService myUserDetailsService;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       auth.userDetailsService(myUserDetailsService)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><em>SpringSecurity处理完登录操作之后把登录成功的User对象以principal(主体)属性名存入了UsernamePasswordAuthenticationToken对象</em></p>
<p>在页面使用时:</p>
<p>1.引入SpringSecurity标签库</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">&quot;security&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;http://www.springframework.org/security/tags&quot;</span> %&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.获取(UsernamePasswordAuthenticationToken会擦除密码)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security:authentication</span> <span class="attr">property</span>=<span class="string">&quot;principal.original.username&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="使用注解配分角色-权限信息"><a href="#使用注解配分角色-权限信息" class="headerlink" title="使用注解配分角色,权限信息"></a>使用注解配分角色,权限信息</h6><p>1.在配置类启用全局方法权限控制,并设置prePostEnabled=true,保证@PreAuthority,@PostAuthority,@PreFilter,@PostFilter生效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> configure........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在需要加权限验证的方法上加@PreAuthorize</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;name&#x27;)&quot;)</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/role/get/role.json&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ResultEntity&lt;PageInfo&lt;Role&gt;&gt; getPageInfo() &#123;</span><br><span class="line">       .........</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="csrf"><a href="#csrf" class="headerlink" title="csrf"></a>csrf</h5><p>用来生成token防止跨站请求伪造,需要在表单添加</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;_csrf.parameterName&#125;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者配置HttpSecurity禁用否则会发生403错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.csrf()</span><br><span class="line">	.disable();</span><br></pre></td></tr></table></figure>

<h4 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h4><p> 在configure(AuthenticationManagerBuilder auth) 中使用PasswordEncoder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>	</span><br><span class="line">MyUserDetailsService myUserDetailsService;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> BCryptPasswordEncoder <span class="title">getPasswordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       auth.userDetailsService(myUserDetailsService)</span><br><span class="line">           .passwordEncoder(getPasswordEncoder());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>自定义加密方式可继承PasswordEncoder,重写encode(),matches()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPasswordEncoder</span> <span class="keyword">implements</span> <span class="title">PasswordEncoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(CharSequence charSequence)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加密密码</span></span><br><span class="line">        <span class="keyword">return</span> MyEncoder(charSequence);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence charSequence, String encodedPassword)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加密明文密码</span></span><br><span class="line">        String formPassword = MyEncoder(charSequence);</span><br><span class="line">        <span class="comment">//数据库密码</span></span><br><span class="line">        String databasePassword = encodedPassword;</span><br><span class="line">        <span class="comment">//比较</span></span><br><span class="line">        <span class="keyword">return</span> Objects.equals(formPassword,databasePassword);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><h5 id="No-bean-named-‘springSecurityFilterChain’-available"><a href="#No-bean-named-‘springSecurityFilterChain’-available" class="headerlink" title="No bean named ‘springSecurityFilterChain’ available:"></a>No bean named ‘springSecurityFilterChain’ available:</h5><p>当SpringSecurity配置类添加到SpringMvc Ioc中时,会抛出找不到pspringSecurityFilterChain异常</p>
<h6 id="三大组件启动顺序"><a href="#三大组件启动顺序" class="headerlink" title="三大组件启动顺序:"></a>三大组件启动顺序:</h6><p>首先:ContextLoaderListener初始化,创建Spring的IOC容器</p>
<p>其次:DelegatingFilterProxy初始化,查找IOC容器,查找bean</p>
<p>最后:DispatherServlet初始化,创建SpringMVC的IOC容器</p>
<h6 id="Filter查找IOC容器然后找Bean的工作机制"><a href="#Filter查找IOC容器然后找Bean的工作机制" class="headerlink" title="Filter查找IOC容器然后找Bean的工作机制"></a>Filter查找IOC容器然后找Bean的工作机制</h6><p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20201110111808.png"></p>
<h6 id="解决方案一-把两个ioc容器合二为一"><a href="#解决方案一-把两个ioc容器合二为一" class="headerlink" title="解决方案一:把两个ioc容器合二为一"></a>解决方案一:把两个ioc容器合二为一</h6><p>不使用ContextLoaderListener,让Dispater加载所有Spring配置文件,但是会破环现有程序结构</p>
<h6 id="解决方案二-改源码"><a href="#解决方案二-改源码" class="headerlink" title="解决方案二:改源码"></a>解决方案二:改源码</h6><p>修改DelegatingFilterProxy类的initFilterBean(),doFilter()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.delegateMonitor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.delegate == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If no target bean name specified, use filter name.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.targetBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.targetBeanName = getFilterName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Fetch Spring root application context and initialize the delegate early,</span></span><br><span class="line">            <span class="comment">// if possible. If the root application context will be started after this</span></span><br><span class="line">            <span class="comment">// filter proxy, we&#x27;ll have to resort to lazy initialization.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*注释掉</span></span><br><span class="line"><span class="comment">                WebApplicationContext wac = findWebApplicationContext();</span></span><br><span class="line"><span class="comment">                if (wac != null) &#123;</span></span><br><span class="line"><span class="comment">                    this.delegate = initDelegate(wac);</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">	<span class="comment">// Lazily initialize the delegate if necessary.</span></span><br><span class="line">	Filter delegateToUse = <span class="keyword">this</span>.delegate;</span><br><span class="line">	<span class="keyword">if</span> (delegateToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.delegateMonitor) &#123;</span><br><span class="line">			delegateToUse = <span class="keyword">this</span>.delegate;</span><br><span class="line">			<span class="keyword">if</span> (delegateToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">//把原来查找IOC容器的代码注释掉,按需要重新编写</span></span><br><span class="line">				<span class="comment">//WebApplicationContext wac = findWebApplicationContext();</span></span><br><span class="line">                   <span class="comment">//1.获取ServletContext对象</span></span><br><span class="line">                   ServletContext sc = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">                   <span class="comment">//2.拼接SpingMvc将Ioc容器存入ServletContext域的时候使用的属性名</span></span><br><span class="line">                   String servletName = <span class="string">&quot;springDispatherServlet&quot;</span>;</span><br><span class="line">                   String attrName = FrameworkServlet.SERVLET_CONTEXT_PREFIX+servletName;</span><br><span class="line">                   <span class="comment">//3.根据attrName从ServletCOntext域中获取IOC容器对象</span></span><br><span class="line">                   WebApplicationContext wac = (WebApplicationContext)sc.getAttribute(attrName)</span><br><span class="line">				<span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No WebApplicationContext found: &quot;</span> +</span><br><span class="line">							<span class="string">&quot;no ContextLoaderListener or DispatcherServlet registered?&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				delegateToUse = initDelegate(wac);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.delegate = delegateToUse;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Cannot-pass-a-pull-GrantedAuthorrity-collection"><a href="#Cannot-pass-a-pull-GrantedAuthorrity-collection" class="headerlink" title="Cannot pass a pull GrantedAuthorrity collection:"></a>Cannot pass a pull GrantedAuthorrity collection:</h5><p>没有设置roles()或者authorities方法导致的</p>
<h5 id="Spring-Security-登陆报错："><a href="#Spring-Security-登陆报错：" class="headerlink" title="Spring Security 登陆报错："></a>Spring Security 登陆报错：</h5><p>There is no PasswordEncoder mapped for the id “null”:</p>
<p>必须设置密码的加密方式</p>
<p>5.0以后对于密码的管理有些变化,现如今Spring Security中密码的存储格式是“{id}…………”。前面的id是加密方式，id可以是bcrypt、sha256等，后面跟着的是加密后的密码。也就是说，程序拿到传过来的密码的时候，会首先查找被“{”和“}”包括起来的id，来确定后面的密码是被怎么样加密的，如果找不到就认为id是null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">auth.passwordEncoder(<span class="keyword">new</span> BCryptPasswordEncoder())</span><br><span class="line">    .password(<span class="keyword">new</span> BCryptPasswordEncoder().encode(<span class="string">&quot;123123&quot;</span>))</span><br></pre></td></tr></table></figure>

<h5 id="PreAuthorize-无法拦截："><a href="#PreAuthorize-无法拦截：" class="headerlink" title="@PreAuthorize()无法拦截："></a>@PreAuthorize()无法拦截：</h5><p>在使用@PreAuthorize()做拦截时,如果同时也设置了@EnableGlobalMethodSecurity(prePostEnabled = true),还是无法拦截,可能时因为在扫描SpringSecurity时是使用Spring扫描,而拦截注解加在了请求上,将注解加在Service文件或者是Mapper文件即可,反之亦然</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2021/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构包括：线性结构和非线性结构</p>
<a id="more"></a>

<ul>
<li><p>线性结构</p>
<ol>
<li>线性结构作为最常用的数据结构，其特点是数据元素之间存在<strong>一对一的线性关系</strong>（eg: int a[] =0 ）</li>
<li>线性结构有两种不同的存储结构，即<strong>顺序存储结构(数组)**和</strong>链式存储结构（链表）**</li>
<li>顺序存储的线性表称为<strong>顺序表</strong>，顺序表中存储的元素是连续的；链式存储的线性表称为<strong>链表</strong>，链表中存储的元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息</li>
<li>常见的线性结构：数组、队列、链表和栈</li>
</ol>
</li>
<li><p>非线性结构</p>
<p>非线性结构包括：二位数组、多维数组、广义表、树结构、图结构</p>
</li>
</ul>
<h4 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h4><p>当一个数组中大部分元素为0，或者同一个值得数组时，可以使用稀疏数组来保存该数组。</p>
<p>二维数组转稀疏数组：</p>
<ol>
<li>遍历二维数组，得到有效数据sum</li>
<li>根据sum创建稀疏数组<code>sparseArr int[sum+1][3]</code>，第一行记录数组一共有几行，几列，有多少个不同的值</li>
<li>将二维数组的有效数据存入到稀疏数组</li>
</ol>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li>队列是一个有序列表，可以用<strong>数组</strong>或<strong>链表</strong>来实现</li>
<li>遵循先进先出</li>
<li>数组模拟队列示意图</li>
</ul>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/%E6%97%A0%E6%A0%87%E9%A2%98.png"></p>
<ul>
<li><p>数组队列：其中maxSize是该队列的最大容量，front及rear分别记录队列前后端的下标，front 会随着数据<strong>输出</strong>而改变，而rear则是随着数据<strong>输入</strong>而改变。</p>
<p>将尾指针往后移: <code>rear+1</code>，当<code>front == rear</code> 【空】</p>
<p>若尾指针rear小于队列的最大下标<code>maxSize-1</code>，则将数据存入rear所指的数组元素中，否则无法存入数据。<code>rear == maxSize-1</code>[队列满]</p>
</li>
<li><p>环形队列：front和rear初始值为0，当队列满时：<code>(rear+1)%maxSize==front</code>队列中有效数据：<code>(rear+maxSize-front)%maxSize</code></p>
</li>
</ul>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><ul>
<li>链表是以节点的方式来存储</li>
<li>每个节点包含data域，next域：指向下一个节点</li>
<li>链表是有序的列表，但在内存中不一定是连续存储</li>
<li>链表分带头节点的和不带头结点的链表，根据实际需求确定</li>
</ul>
<p><strong><em>单链表面试题:</em></strong></p>
<ol>
<li>求单链表中节点的个数</li>
<li>查找单链表综中的倒数第K个节点【新浪】</li>
<li>单链表的反转【腾讯】</li>
<li>从尾到头打印单链表【百度】</li>
</ol>
<h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><ul>
<li>单项链表查找的方向只能是一个方向，而双向链表可以向前或者向后查找</li>
<li>单向链表不能自我删除，需要靠辅助节点，而双向链表可以自我删除(1)<code>temp.pre.next=temp.next</code>(2)<code>temp.next.pre=temp.pre</code></li>
</ul>
<h5 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h5><h6 id="约瑟夫问题："><a href="#约瑟夫问题：" class="headerlink" title="约瑟夫问题："></a><strong><em>约瑟夫问题：</em></strong></h6><p>n = 5，即有5个人；k=1，从第一个人开始报数；m = 2，数2下</p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/202107yueshefu.png"></p>
<ol>
<li>需求创建一个辅助指针(变量) helper ,事先应该指向环形链表的最后这个节点.</li>
<li>先让first和helper移动k-1次</li>
<li>报数时，让first和helper指针同时的移动m -1次</li>
<li>将first指向的小孩节点出圈<br>first= first.next<br>helper.next =first<br>原来first指向的节点就没有任何引用，就会被回牧</li>
</ol>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>树的存储方式能提高数据<strong>存储</strong>，<strong>读取</strong>的效率，比如利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。</p>
<h5 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T)<span class="comment">//如果当前节点不为空</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T-&gt;data);    <span class="comment">//输出当前节点的值 上中下决定前中后</span></span><br><span class="line">      PreOrderTraverse(T-&gt;Left); <span class="comment">//再调用自己到左节点</span></span><br><span class="line">      PreOrderTraverse(T-&gt;Right);<span class="comment">//最后到右节点</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树查找"><a href="#二叉树查找" class="headerlink" title="二叉树查找"></a>二叉树查找</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DLR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点 上中下决定前中后</span></span><br><span class="line">	<span class="comment">// 左子树递归</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.left.DLR();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 右子树递归</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.right.DLR();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="节点删除"><a href="#节点删除" class="headerlink" title="节点删除"></a>节点删除</h5><ol>
<li>因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.</li>
<li>如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</li>
<li>如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right=null ;并且就返回(结束递归删除)</li>
<li>如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</li>
<li> 如果第4步也没有删除结点，则应当向右子树进行递归删除.</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果只有一个root结点, 这里立即判断root是不是就是要删除结点</span></span><br><span class="line">			<span class="keyword">if</span>(root.getNo() == no) &#123;</span><br><span class="line">				root = <span class="keyword">null</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//递归删除</span></span><br><span class="line">				root.delNode(no);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;空树，不能删除~&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//递归删除结点</span></span><br><span class="line">    <span class="comment">//1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line">    <span class="comment">//2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        */</span><br><span class="line">       <span class="comment">//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line">          <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line">          <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4.我们就需要向左子树进行递归删除</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//5.则应当向右子树进行递归删除</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="顺序存储二叉树"><a href="#顺序存储二叉树" class="headerlink" title="顺序存储二叉树"></a>顺序存储二叉树</h5><ol>
<li>顺序二叉树通常只考虑完全二叉树</li>
<li>第n个元素的左子节点为 2*n +1</li>
<li>第n个元素的右子节点为 2*n +2</li>
<li>第n个元素的父子节点为 (n-1)/2</li>
<li>n：表示二叉树中的第几个元素（0开始编号）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序存储二叉树遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//如果数组为空，或者 arr.length = 0</span></span><br><span class="line">   <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;数组为空，不能按照二叉树的前序遍历&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//输出当前这个元素</span></span><br><span class="line">   System.out.println(arr[index]); </span><br><span class="line">   <span class="comment">//向左递归遍历</span></span><br><span class="line">   <span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length) &#123;</span><br><span class="line">      preOrder(<span class="number">2</span> * index + <span class="number">1</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//向右递归遍历</span></span><br><span class="line">   <span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">2</span>) &lt; arr.length) &#123;</span><br><span class="line">      preOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h5><ol>
<li>n个结点的二叉链表中含有n+1【公式2n-(n-1)=n+1】个<strong>空指针域</strong>。利用二叉链表中的空指针域，<strong>存放指向该结点</strong>在某种遍历次序下（前中后序）的<strong>前驱和后继结点</strong>的指针(这种附加的指针称为”线索”)</li>
<li>这种加上了线索的二叉链表称为<strong>线索链表</strong>，相应的二叉树称为<strong>线索二叉树</strong>(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种</li>
<li>一个结点的前一个结点，称为前驱结点</li>
<li>一个结点的后一个结点，称为后继结点</li>
</ol>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210803xianshuo.png"></p>
<p>说明：当线索化二叉树后，Node节点的属性left和right，有如下情况:</p>
<ol>
<li>left指向的是左子树，也可能是指向的前驱节点，比如节点left指向的左子树,而⑩节点的 left指向的就是前驱节点.</li>
<li>right指向的是右子树，也可能是指向后继节点，比如①节点right指向的是右子树，而⑩节点的right指向的是后继节点.</li>
<li>为了区分left，right的指向，节点类中添加leftType，rightType。如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点，rightType同理 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果node==null, 不能线索化</span></span><br><span class="line">       <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//(一)递归线索化左子树</span></span><br><span class="line">       threadedNodes(node.getLeft());</span><br><span class="line">       <span class="comment">//(二)线索化当前结点</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//处理当前结点的前驱结点</span></span><br><span class="line">       <span class="keyword">if</span>(node.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//让当前结点的左指针指向前驱结点 </span></span><br><span class="line">          node.setLeft(pre); </span><br><span class="line">          <span class="comment">//修改当前结点的左指针的类型,指向前驱结点</span></span><br><span class="line">          node.setLeftType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//处理后继结点</span></span><br><span class="line">       <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//让前驱结点的右指针指向当前结点</span></span><br><span class="line">          pre.setRight(node);</span><br><span class="line">          <span class="comment">//修改前驱结点的右指针类型</span></span><br><span class="line">          pre.setRightType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点</span></span><br><span class="line">       pre = node;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//(三)递归线索化右子树</span></span><br><span class="line">       threadedNodes(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线索化二叉树遍历</p>
<blockquote>
<p>因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//遍历线索化二叉树的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个变量，存储当前遍历的结点，从root开始</span></span><br><span class="line">        HeroNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//循环的找到leftType == 1的结点，</span></span><br><span class="line">            <span class="comment">//后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化</span></span><br><span class="line">            <span class="comment">//处理后的有效结点</span></span><br><span class="line">            <span class="keyword">while</span>(node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打印当前这个结点</span></span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="comment">//如果当前结点的右指针指向的是后继结点,就一直输出</span></span><br><span class="line">            <span class="keyword">while</span>(node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//获取到当前结点的后继结点</span></span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//替换这个遍历的结点</span></span><br><span class="line">            node = node.getRight();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h5><p>二叉排序树：BST(Binary Sort(Search) Tree),对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。<img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210812paixusu.png"></p>
<p><strong>添加节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//判断传入的结点的值，和当前子树的根结点的值关系</span></span><br><span class="line">   <span class="keyword">if</span>(node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">      <span class="comment">//如果当前结点左子结点为null</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.left = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//递归的向左子树添加</span></span><br><span class="line">         <span class="keyword">this</span>.left.add(node);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//添加的结点的值大于 当前结点的值</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.right = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//递归的向右子树添加</span></span><br><span class="line">         <span class="keyword">this</span>.right.add(node);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除节点</strong></p>
<p>第一种情况：删除叶子节点思路</p>
<ol>
<li>需求先去找到要删除的结点targetNode</li>
<li>找到targetNode的父结点parent</li>
<li>确定targetNode是parent的左子结点还是右子结点</li>
<li>根据前面的情况来对应删除左子结点parent.left = null右子结点parent.right = null;</li>
</ol>
<p>第二种情况：删除只有一颗子树的节点</p>
<p>​    ….</p>
<ol start="4">
<li><p>判断targetNode下面是左子结点还是右子结点</p>
<p>（1）左：</p>
<ul>
<li>如果targetNode是parent的左子结点parent.left = targetNode.left;<ul>
<li>如果targetNode是 parent的右子结点parent.right = targetNode.left;</li>
</ul>
</li>
</ul>
<p>（2）右：</p>
<ul>
<li>如果 targetNode是parent的左子结点parent.left = targetNode.right;<ul>
<li>如果argetNode是parent的右子结点parent.right = targetNode.right</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>第三种情况：删除有两颗子树的节点</p>
<p>​    …</p>
<ol start="3">
<li>从targetNode 的右子树找到最小的结点(或者左子树最大的结点)</li>
<li>用一个临时变量，将最小结点的值保存</li>
<li>删除该最小结点，令targetNode等于该节点 targetNode.value = temp</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">      Node targetNode = search(value);</span><br><span class="line">      <span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line">      <span class="keyword">if</span>(targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点</span></span><br><span class="line">      <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">         root = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">      Node parent = searchParent(value);</span><br><span class="line">      <span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line">      <span class="keyword">if</span>(targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的节点*</span></span><br><span class="line">         <span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">         targetNode.value = minVal;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 删除只有一颗子树的结点</span></span><br><span class="line">          ...</span><br><span class="line">         <span class="keyword">if</span>(targetNode.left != <span class="keyword">null</span>) &#123;<span class="comment">//如果要删除的结点有左子结点</span></span><br><span class="line">			...</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果要删除的结点有右子结点 </span></span><br><span class="line">            ...</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node target = node;</span><br><span class="line">    <span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line">    <span class="keyword">while</span>(target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target = target.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这时 target就指向了最小结点 删除最小结点</span></span><br><span class="line">    delNode(target.value);</span><br><span class="line">    <span class="keyword">return</span> target.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h5><blockquote>
<ol>
<li>平衡二叉树也叫平衡二叉搜索树(Self-balancing binary search tree）又被称为AVL树，可以保证查询效率较高。</li>
<li>具有以下特点:它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。</li>
</ol>
</blockquote>
<p><strong>单旋转</strong>（左旋：当右子树的高度 - 左子树的高度 &gt; 1）</p>
<ol>
<li>创建一个新的节点，令其值等于当前<strong>根节点</strong>的值</li>
<li>把新节点的左子树指向当前节点的左子树  newNode.left = left</li>
<li>把新节点的右子树指向当前节点的<strong>右子树的左子树</strong>  newNode.right =right.left</li>
<li>把当前节点的<strong>值换</strong>为右子节点的值 value=right.value</li>
<li>把当前节点的右子树指向成<strong>右子树的右子树</strong> right=right.right</li>
<li>把当前节点的左子树指向新节点 left=newNode </li>
</ol>
<p>注：右旋将所有left和right对换</p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/202100812zuoxuan.png"></p>
<p><strong>双旋转</strong></p>
<p>当符合右旋转的条件时，如果它的<strong>左子树的右子树</strong>高度大于它的<strong>右子树</strong>高度，先对左子树进行左旋转，再对当前节点进行右旋转</p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210813shuangxuan.png"></p>
<h4 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a>多叉树</h4><h5 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h5><blockquote>
<ol>
<li>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</li>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</li>
<li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.)，2-3树是由二节点和三节点构成的树。</li>
<li>当按照规则插入一个数到某个节点时，不能满足上面三个要求,就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满定上面3个条件。</li>
<li>对于三节点的子树的值大小仍然遵守<strong>二叉排序树</strong>的规则</li>
</ol>
</blockquote>
<h5 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h5><blockquote>
<ol>
<li>B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4</li>
<li>B-树的搜索，从根结点开始,对结点内的关键字（有序）序列进**行二分查找,**如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li>
<li>关键字集合分布在整颗树中，即叶子节点和非叶子节点都存放数据-<br> 搜索有可能在非叶子结点结束</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找</li>
</ol>
<img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/1347265816_7366.jpg" style="zoom: 80%;" />
</blockquote>
<h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><blockquote>
<ol>
<li>B+树是B树的变体，也是多路B+树的搜索与B树也基本相同，区别是B树只有达到叶子结点才命中(树可以在非叶子结点合中)，其性能也等价于在关键字全集做一次二分查找</li>
<li>所有<strong>关键字都出现在叶了结点的链表中</strong>(即数据只能在叶子节点【也叫稠密索引】)，且链表中的关键字数据)恰好是有序的。</li>
<li>不可能在非叶子结点命中</li>
<li>非叶子结点相当于是叶子结点的索引(稀疏索引叶子结点相当子是存储(关键字)数据的数据层</li>
<li>更适合文件索引系统</li>
<li>B树和B+树各有自己的应用场景,不能说B+树完全比B树好，反之亦然.</li>
</ol>
<img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/1347265821_7407.jpg" style="zoom:80%;" />
</blockquote>
<h5 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h5><blockquote>
<p>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</p>
<ol>
<li>B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。</li>
<li>从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高</li>
</ol>
<img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/1347265826_6256.jpg" style="zoom:80%;" />
</blockquote>
<h4 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h4><blockquote>
<ol>
<li><p>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为<strong>路径</strong>。通路中分支的数目称为<strong>路径长度</strong>。若规定根结点的层数为1，则从根结点到第L层结点的<strong>路径长度为L-1</strong></p>
</li>
<li><p>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为<strong>该结点的权</strong>。</p>
<p>结点的带权路径长度为：从根结点到该结点之间的<strong>路径长度</strong>与该结点的<strong>权</strong>的<strong>乘积</strong></p>
</li>
<li><p>树的带权路径长度：树的带权路径长度规定为<strong>所有叶子结点的带权路径长度之和</strong>，记为WPL(weighted path length) ，<strong>权值越大的结点离根结点越近</strong>的二叉树才是<strong>最优二叉树</strong>（赫夫曼树）</p>
</li>
<li><p>WPL最小的就是赫夫曼树</p>
</li>
<li><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210812heufman.png" style="zoom:50%;" />
</li>
</ol>
</blockquote>
<p>构成赫夫曼树的步骤：</p>
<ol>
<li>从小到大进行排序,将每一个数据，每个数据都是一个节点，每个节点可以看成是—颗最简单的二叉树</li>
<li>取出根节点权值最小的两颗二叉树</li>
<li>组成一颗新的二叉树,该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</li>
<li>再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步为了操作方便</span></span><br><span class="line">    <span class="comment">// 1. 遍历 arr 数组</span></span><br><span class="line">    <span class="comment">// 2. 将arr的每个元素构成成一个Node</span></span><br><span class="line">    <span class="comment">// 3. 将Node 放入到ArrayList中</span></span><br><span class="line">    List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">        nodes.add(<span class="keyword">new</span> Node(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序 从小到大 </span></span><br><span class="line">        Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;nodes =&quot;</span> + nodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出根节点权值最小的两颗二叉树 </span></span><br><span class="line">        <span class="comment">//(1) 取出权值最小的结点（二叉树）</span></span><br><span class="line">        Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//(2) 取出权值第二小的结点（二叉树）</span></span><br><span class="line">        Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(3)构建一颗新的二叉树</span></span><br><span class="line">        Node parent = <span class="keyword">new</span> Node(leftNode.value + rightNode.value);</span><br><span class="line">        parent.left = leftNode;</span><br><span class="line">        parent.right = rightNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(4)从ArrayList删除处理过的二叉树</span></span><br><span class="line">        nodes.remove(leftNode);</span><br><span class="line">        nodes.remove(rightNode);</span><br><span class="line">        <span class="comment">//(5)将parent加入到nodes</span></span><br><span class="line">        nodes.add(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回哈夫曼树的root结点</span></span><br><span class="line">    <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h5><blockquote>
<ol>
<li>赫夫曼编码也翻译为哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式,属于一种程序算法</li>
<li>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</li>
<li>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%~90%之间</li>
<li>赫夫曼码是<strong>可变字长</strong>编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Node类,待数据和权值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;  </span>&#123;</span><br><span class="line">   Byte data; <span class="comment">// 存放数据(字符)本身，比如&#x27;a&#x27; =&gt; 97 &#x27; &#x27; =&gt; 32</span></span><br><span class="line">   <span class="keyword">int</span> weight; <span class="comment">//权值, 表示字符出现的次数</span></span><br><span class="line">   Node left;<span class="comment">//</span></span><br><span class="line">   Node right;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Byte data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">      <span class="keyword">this</span>.weight = weight;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 从小到大排序</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.weight - o.weight;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字节数组转为Node集合以构建赫夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getNodes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历 bytes , 统计 每一个byte出现的次数-&gt;map[key,value]</span></span><br><span class="line">    Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">        Integer count = counts.get(b);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123; <span class="comment">// Map还没有这个字符数据,第一次</span></span><br><span class="line">            counts.put(b, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把每一个键值对转成一个Node 对象，并加入到nodes集合</span></span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Byte, Integer&gt; entry: counts.entrySet()) &#123;</span><br><span class="line">        nodes.add(<span class="keyword">new</span> Node(entry.getKey(), entry.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建赫夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span></span>&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将赫夫曼树所有叶子节点转为赫夫曼编码</span></span><br><span class="line"><span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;Byte,String&gt;();</span><br><span class="line"><span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">    StringBuilder stringBuilder2 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line">    <span class="comment">//将code 加入到 stringBuilder2</span></span><br><span class="line">    stringBuilder2.append(code);</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123; <span class="comment">//如果node == null不处理</span></span><br><span class="line">        <span class="comment">//判断当前node 是叶子结点还是非叶子结点</span></span><br><span class="line">        <span class="keyword">if</span>(node.data == <span class="keyword">null</span>) &#123; <span class="comment">//非叶子结点</span></span><br><span class="line">            <span class="comment">//递归处理</span></span><br><span class="line">            <span class="comment">//向左递归</span></span><br><span class="line">            getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder2);</span><br><span class="line">            <span class="comment">//向右递归</span></span><br><span class="line">            getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//说明是一个叶子结点</span></span><br><span class="line">            <span class="comment">//就表示找到某个叶子结点的最后</span></span><br><span class="line">            huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将赫夫曼编码转为字节数组  每8位转为一个byte  (byte)Integer.parseInt(str,2)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">		<span class="comment">//1.利用 huffmanCodes 将  bytes 转成  赫夫曼编码对应的字符串</span></span><br><span class="line">		StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//遍历bytes 数组 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">byte</span> b: bytes) &#123;</span><br><span class="line">			stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="comment">//一句话 </span></span><br><span class="line">		<span class="keyword">int</span> len = (stringBuilder.length() + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">		<span class="comment">//创建 存储压缩后的 byte数组</span></span><br><span class="line">		<span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//记录是第几个byte</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123; <span class="comment">//因为是每8位对应一个byte,所以步长 +8</span></span><br><span class="line">				String strByte;</span><br><span class="line">				<span class="keyword">if</span>(i+<span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">					strByte = stringBuilder.substring(i);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">				&#125;	</span><br><span class="line">				<span class="comment">//将strByte 转成一个byte,放入到 huffmanCodeBytes</span></span><br><span class="line">				huffmanCodeBytes[index] = (<span class="keyword">byte</span>)Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">				index++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="赫夫曼解码"><a href="#赫夫曼解码" class="headerlink" title="赫夫曼解码"></a>赫夫曼解码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 字节数组转二进制的字符串</span><br><span class="line">   <span class="number">2.</span> 将赫夫曼编码表key-value进行调换</span><br><span class="line">   <span class="number">3.</span> 将二进制根据编码表进行解码</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; stringBuilder.length(); ) &#123;</span><br><span class="line">           <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// 小的计数器</span></span><br><span class="line">           <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">               <span class="comment">//1010100010111...</span></span><br><span class="line">               <span class="comment">//递增的取出 key 1 </span></span><br><span class="line">               String key = stringBuilder.substring(i, i+count);<span class="comment">//i 不动，让count移动，指定匹配到一个字符</span></span><br><span class="line">               </span><br><span class="line">               <span class="keyword">if</span>(map.containsKey(key))&#123;<span class="comment">//匹配到</span></span><br><span class="line">                   flag = <span class="keyword">false</span>;</span><br><span class="line">                   list.add(map.get(key));<span class="comment">//添加到list</span></span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;					<span class="comment">//没有匹配到</span></span><br><span class="line">                    count++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           i += count;<span class="comment">//i 直接移动到 count	</span></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br></pre></td></tr></table></figure>

<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><blockquote>
<p>图(Graph)是由顶点和连接顶点的边构成的离散结构。在计算机科学中，图是最灵活的数据结构之一，很多问题都可以使用图模型进行建模求解。</p>
<p>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。结点也可以称为顶点。</p>
<p>当需要表示多对多的关系时，就用到了图</p>
</blockquote>
<p>图的表示方式有两种：</p>
<ol>
<li>二维数组表示（邻接矩阵）</li>
<li>链表表示（邻接表）</li>
</ol>
<p><strong>邻接矩阵</strong></p>
<p>1.邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1….n个点。（1表示能直接连接，0表示不能直接连接）<img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/5448614122959.png"></p>
<p><strong>邻接表</strong></p>
<ol>
<li>邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失.</li>
<li>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由<strong>数组+链表</strong>组成</li>
</ol>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/2846984564685.png"></p>
<p>​    说明：标号为0的结点的相关联的结点为1 2 3 4</p>
<h5 id="图的创建-邻接矩阵"><a href="#图的创建-邻接矩阵" class="headerlink" title="图的创建(邻接矩阵)"></a>图的创建(<strong>邻接矩阵</strong>)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList; <span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges; <span class="comment">//存储图对应的邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges; <span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="comment">//定义给数组boolean[], 记录某个结点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> ArrayList&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span> </span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> v1 表示点的下标即使第几个顶点(几行几列)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> weight 权值（是否连接） </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="图遍历"><a href="#图遍历" class="headerlink" title="图遍历"></a>图遍历</h5><blockquote>
<p>所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略:(1)深度优先遍历    (2)广度优先遍历</p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210814dfs.png"></p>
</blockquote>
<p><strong>深度优先搜索DFS(Depth First Search)</strong></p>
<p>基本思想：</p>
<ol>
<li>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点，可以这样理解:每次都在访问完当前结点后首先访问<strong>当前结点的第一个邻接结点</strong>。</li>
<li>这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。</li>
<li>深度优先搜索是一个递归的过程</li>
</ol>
<p>实现步骤：</p>
<ol>
<li>访问初始结点v，并标记结点v为已访问。</li>
<li>查找结点v的第一个邻接结点w。</li>
<li>若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。</li>
<li>若w未被访间，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123)</li>
<li>若w已被访间，查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</li>
</ol>
<p><strong>广度优先搜索BFS(Broad First Search)</strong> </p>
<p>基本思想：</p>
<p>类似于一个分层搜索的过程，广度优先遍历需要使用一个<strong>队列</strong>以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</p>
<p>实现步骤：</p>
<ol>
<li><p>访问初始结点v并标记结点v为已访问。</p>
</li>
<li><p>结点v入队列</p>
</li>
<li><p>当队列非空时，继续执行，否则算法结束。</p>
</li>
<li><p>出队列，取得队头结点u。</p>
</li>
<li><p>查找结点u的第一个邻接结点w。</p>
</li>
<li><p>若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：</p>
<p>6.1 若结点w尚未被访问，则访问结点w并标记为已访问。</p>
<p>6.2 结点w入队列</p>
<p>6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</p>
</li>
</ol>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul>
<li>栈的英文为(stack)，是一个**先入后出(**FILO-First In Last Out)的有序列表。</li>
<li>栈(stack)是限制线性表中元素的插入和删除<strong>只能在线性表的同一端</strong>进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为<strong>栈顶</strong>(Top)，另一端为固定的一端，称为<strong>栈底</strong>(Bottom)。</li>
<li>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而<br>删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</li>
</ul>
<h5 id="实现栈的思路分析："><a href="#实现栈的思路分析：" class="headerlink" title="实现栈的思路分析："></a><strong><em>实现栈的思路分析：</em></strong></h5><ol>
<li>使用数组来模拟栈</li>
<li>定义一个top来表示栈顶,初始化为-1</li>
<li>入栈的操作，当有数据加入到栈时，<code>top++; stack[topl= data;</code></li>
<li>出栈的操作,<code>int value =stack[top];top--;returnvalue</code></li>
</ol>
<h5 id="使用栈完成表达式的计算界路："><a href="#使用栈完成表达式的计算界路：" class="headerlink" title="使用栈完成表达式的计算界路："></a><strong><em>使用栈完成表达式的计算界路：</em></strong></h5><p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210711zhan.png"></p>
<ol>
<li>通过一个index值（索引，来遍历表达式）</li>
<li>如果我们发现是一个数字,就直接入数栈</li>
<li>如果发现扫描到是一个符号,就分如下情况<ol>
<li>如果发现当前的符号核为空，就直接入栈</li>
<li>如果符号栈有操作符，就进行比较,如果<strong>当前的操作符的优先级小于或者等于</strong>栈中的操作符，就需要从数栈中pop出两个数在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈，如果<strong>当前的操作符的优先级大于</strong>栈中的操作符,就直接入符号栈.</li>
<li>当表达式扫描完毕,就顺序的从数栈和符号栈中pop出相应的数和符号，并运行.</li>
<li>最后在数栈只有一个数字,就是表达式的结果</li>
</ol>
</li>
<li>问题：加减顺序出错</li>
</ol>
<h5 id="中缀表达式转换为后缀表达式（逆波兰式）"><a href="#中缀表达式转换为后缀表达式（逆波兰式）" class="headerlink" title="中缀表达式转换为后缀表达式（逆波兰式）:"></a><strong><em>中缀表达式转换为后缀表达式（逆波兰式）:</em></strong></h5><ol>
<li>初始化两个栈:运算符栈s1和储存中间结果的栈s2;</li>
<li>从左至右扫描中缀表达式;</li>
<li>遇到操作数时，将其压s2;</li>
<li><strong>遇到运算符时</strong>，比较其与s1栈顶运算符的优先级:<ol>
<li>如果s1为空，或栈顶运算符为左括号“(“，则直接将此运算符入栈;</li>
<li>否则，若优先级比栈顶运算符的高，也将运算符压入s1;</li>
<li>否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算<br>符相比较;</li>
</ol>
</li>
<li><strong>遇到括号时</strong>:<ol>
<li>如果是左括号“(“，则直接压入s1</li>
<li>如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</li>
</ol>
</li>
<li>重复步骤2至5，直到表达式的最右边</li>
<li>将s1中剩余的运算符依次弹出并压入s2</li>
<li>依次弹出s2中的元素并输出，结果的<strong>逆序</strong>即为中缀表达式对应的后缀表达式</li>
</ol>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><blockquote>
<p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。HashTable的方法是同步的，即是线程安全的。</p>
</blockquote>
<p>HashTable和HaspMap区别：</p>
<ol>
<li>HaspMap的方法不是同步的，不是线程安全的的。</li>
<li>HashTable中不允许有null键和null值，HashMap中允许出现一个null键，可以存在一个或者多个键的值都为null,因此，在HashMap中，我们不能使用get()方法来查询键 对应的值，应该使用containskey()方法。</li>
<li>HashTable是直接使用对象的hashCode。HashMap是重新计算hash值。</li>
<li>HashTable和HashMap的底层实现的数组和初始大小和扩容方式。HashTable初始大小为11，并且每次扩容都为：2<em>old+1。HashMap的默认大小为16，并且一 定是2的指数，每次扩容都为old</em>2。</li>
</ol>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。</p>
<p>递归需要遵守规则：</p>
<ol>
<li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li>
<li>方法的局部变量是独立的，不会相互影响,比如n变量</li>
<li>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.</li>
<li>递归必须向退出递归的条件逼近，否则就是无限递归,出现<strong>StackOverflowError</strong></li>
<li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果<br>返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</li>
</ol>
<h5 id="八皇后问题："><a href="#八皇后问题：" class="headerlink" title="八皇后问题："></a><em>八皇后问题：</em></h5><p>八皇后问题，是一个古老而著名的问题，<strong>是回溯算法的典型案例</strong>。即:任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p>
<p><strong>算法思路分析：</strong></p>
<ol>
<li>第一个皇后先放第一行第一列</li>
<li>第二个皇后放在第二行第一列、然后判断是否冲突，如果不冲突，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</li>
<li>继续第三个皇后，还是第一列、第二列…….直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</li>
<li>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</li>
<li>然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4的步骤</li>
</ol>
<p>说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题.<code>arr[8]= &#123;0 ,4,7,5,2,6,1,3&#125;</code>//对应arr下标表示第几行，即第几个皇后，<code>arr[i]=val </code>, val表示第i+1个皇后，放在第i+1行的第val+1列</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol>
<li></li>
</ol>
<blockquote>
<p>时间频度：<br>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</p>
<p>时间复杂度:</p>
<p>常见的算法时间复杂度由小到大依次为:O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n^2)&lt;O(n^3)&lt;O(n^k)&lt;O(2^n)，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低<br>从图中可见，我们应该尽可能避免使用指数阶的算法</p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210712shijianfzd.png"></p>
</blockquote>
<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><blockquote>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210723suanfa.png"><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210712paxu.png"></p>
</blockquote>
<ol>
<li>相关术语解释:<ol>
<li>**稳定 **: 如果a原本在b前面，而a=b，排序之后a仍然在b的前面;</li>
<li>**不稳定 **: 如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面;</li>
<li><strong>内排序</strong> : 所有排序操作都在内存中完成</li>
<li><strong>外排序</strong> : 由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行;</li>
<li><strong>n</strong> : 数据规模</li>
<li>**k **: “桶”的个数</li>
<li><strong>in-place</strong> : 不占用额外内存</li>
<li><strong>out-place</strong> : 占用额外内存</li>
</ol>
</li>
</ol>
<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><blockquote>
<p>冒泡排序(Bubble Sorting）的基本思想是:通讨对待排序序列从前向后(从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。</p>
<p>优化：因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序 时间复杂度O(n^2)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr. length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j +<span class="number">1</span> ]&#123;</span><br><span class="line">            ...<span class="comment">//交换</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//没有交换说明后面的元素已经有序，就直接break</span></span><br><span class="line">	<span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><blockquote>
<p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序 时间复杂度O(n^2)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> minIndex = i;</span><br><span class="line">    <span class="comment">// 找出最小值得元素下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">            minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//与最小的元素交换位置</span></span><br><span class="line">    <span class="keyword">if</span>(minIndex != i)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[index];</span><br><span class="line">        arr[minIndex] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><blockquote>
<p>插入排序(InsertionSort)一般也被称为直接插入排序。</p>
<p>对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增 1 的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; temp; j--) &#123;</span><br><span class="line">        arr[j] = arr[j - <span class="number">1</span>];	<span class="comment">//原数往后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = temp;	<span class="comment">//插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><blockquote>
<p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为<strong>缩小增量排序</strong>，同时该算法是冲破O(n^2）的第一批算法之一。希尔排序有<strong>交换法</strong>和<strong>移动法</strong>，交换法较慢。</p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210719xierpaixu.png"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>;gap&gt;<span class="number">0</span>;gap /= <span class="number">2</span>)&#123; <span class="comment">//gap：增量  7   3   1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++)&#123; </span><br><span class="line">        <span class="comment">//i:代表即将插入的元素角标，作为每一组比较数据的最后一个元素角标 </span></span><br><span class="line">        <span class="comment">//j:代表与i同一组的数组元素角标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i-gap; j&gt;=<span class="number">0</span>; j-=gap)&#123; <span class="comment">//在此处-gap 为了避免下面数组角标越界</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;<span class="comment">// j+gap 代表即将插入的元素所在的角标</span></span><br><span class="line">                <span class="comment">//符合条件，插入元素（交换位置）</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + gap];</span><br><span class="line">                arr[j + gap] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//移动法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>;gap&gt;<span class="number">0</span>;gap /= <span class="number">2</span>)&#123; </span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++)&#123; </span><br><span class="line">       <span class="keyword">int</span> j;</span><br><span class="line">       <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">       <span class="keyword">for</span> (j = i; j-gap &gt; <span class="number">0</span> &amp;&amp; arr[j - gap] &gt; temp; j-=gap) &#123;</span><br><span class="line">           arr[j] = arr[j - gap];	<span class="comment">//原数往后移</span></span><br><span class="line">       &#125;</span><br><span class="line">       arr[j] = temp;	<span class="comment">//插入</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><blockquote>
<p>快速排序（Quicksort)是对冒泡排序的一种改进。基本思想是:通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,pivot,temp;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i=left;</span><br><span class="line">    j=right;</span><br><span class="line">    <span class="comment">//pivot是基准位</span></span><br><span class="line">    pivot = arr[left];</span><br><span class="line">    <span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">        <span class="comment">//先看右边，依次往左找出小于基准的数</span></span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt;= pivot &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再看左边，依次往右递增找出大于基准的数</span></span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt;= pivot &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果满足条件则交换</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;j) &#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后将基准 与 i和j相遇位置的数字交换，此时i==j</span></span><br><span class="line">    arr[left] = arr[i];</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    <span class="comment">//递归调用左半数组</span></span><br><span class="line">    quickSort(arr, left, i-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//递归调用右半数组</span></span><br><span class="line">    quickSort(arr, i+<span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><blockquote>
<p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治(divide-and-conquer〉策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在-起，即分而治之)。</p>
<p><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210722fenzhi.png"><img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210722fen.png"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] tmp)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;				<span class="comment">//缓存数组个数</span></span><br><span class="line">   <span class="keyword">int</span> j = left,k = mid+<span class="number">1</span>;  <span class="comment">//左边序列和右边序列起始索引</span></span><br><span class="line">   <span class="keyword">while</span>(j &lt;= mid &amp;&amp; k &lt;= right)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &lt; arr[k])&#123;</span><br><span class="line">         tmp[i++] = arr[j++];</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         tmp[i++] = arr[k++];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若左、右边序列还有剩余，则将其全部拷贝进tmp[]中</span></span><br><span class="line">   <span class="keyword">while</span>(j &lt;= mid)&#123;</span><br><span class="line">      tmp[i++] = arr[j++];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(k &lt;= right)&#123;</span><br><span class="line">      tmp[i++] = arr[k++];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将temp数组中的元素拷贝到arr</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;i;t++)&#123;	</span><br><span class="line">      arr[left+t] = tmp[t];	</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] tmp)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">      mergeSort(arr,left,mid,tmp); <span class="comment">//对左边序列进行归并排序</span></span><br><span class="line">      mergeSort(arr,mid+<span class="number">1</span>,right,tmp);  <span class="comment">//对右边序列进行归并排序</span></span><br><span class="line">      merge(arr,left,mid,right,tmp);    <span class="comment">//合并两个有序序列</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h5><blockquote>
<p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。    基数排序是使用空间换时间的经典算法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基数排序方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//得到数组中最大的数的位数</span></span><br><span class="line">   <span class="keyword">int</span> max = arr[<span class="number">0</span>]; </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">         max = arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> maxLength = (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span></span><br><span class="line">   <span class="comment">//1. 二维数组包含10个一维数组</span></span><br><span class="line">   <span class="comment">//2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span></span><br><span class="line">   <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">   <span class="comment">//比如：bucketCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数</span></span><br><span class="line">   <span class="keyword">int</span>[] bucketCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> , n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">         <span class="comment">//取出每个元素的对应位的值,放入到对应的桶中</span></span><br><span class="line">         <span class="keyword">int</span> digit = arr[j] / n % <span class="number">10</span>;</span><br><span class="line">         buckets[digit][bucketCounts[digit]] = arr[j];</span><br><span class="line">         bucketCounts[digit]++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line">      <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketCounts.length; k++) &#123;</span><br><span class="line">         <span class="comment">//如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line">         <span class="keyword">if</span>(bucketCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; bucketCounts[k]; l++) &#123;</span><br><span class="line">               <span class="comment">//取出元素放入到arr</span></span><br><span class="line">               arr[index++] = buckets[k][l];</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//第i+1轮处理后，需要将每个 bucketCounts[k] = 0 ！！！！</span></span><br><span class="line">         bucketCounts[k] = <span class="number">0</span>;  </span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><blockquote>
<ol>
<li><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p>
</li>
<li><p>堆是具有以下性质的完全二叉树:每个结点的值都大于或等于其左右孩子结点的值，称为<strong>大顶堆</strong>，**注意:**没有要求结点的左孩子的值和右孩子的值的大小关系。</p>
</li>
<li><p>每个结点的值都小于或等于其左右孩子结点的值，称为<strong>小顶堆</strong></p>
</li>
<li><p>大顶堆举例说明<img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210805dadingdui.png"></p>
</li>
<li><p>大顶堆的特点：arr[ i ] &gt;= arr[ 2 * i + 1] &amp;&amp; arr[ i ] &gt;=arr[2 * i +2 ]  ;</p>
<p>小顶堆：arr[ i ] &lt;= arr[ 2 * i + 1] &amp;&amp; arr[ i ] &lt;=arr[2 * i +2 ];i对应第几个节点，从0开始</p>
</li>
<li><p>升序采用大顶堆，降序采用小顶堆</p>
</li>
</ol>
</blockquote>
<p>堆排序基本思路：</p>
<ol>
<li>将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆，最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1），从左至右，从下至上进行调整。</li>
<li>将堆页元素与末尾元素交换，将最大元素”沉”到数组末端;</li>
<li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//堆排序</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">            temp =arr[j];</span><br><span class="line">            arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;	</span><br><span class="line">            </span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);<span class="comment">//交换后重新调整为大顶堆 在交换	</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整大顶堆（仅是一次调整）</span></span><br><span class="line"><span class="comment">//1. 当前元素:i ; 左子节点： k=i*2+1 ; 右子节点：k+1 = i*2+2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时：arr[k]为arr[i]节点下较大的一个数</span></span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt;temp)&#123;<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;		<span class="comment">//i指向k 继续循环比较</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;		<span class="comment">//因为是最后一个非叶子结点 后面没有子树 直接跳出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h4><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><blockquote>
<p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用<strong>顺序存储结构</strong>，而且表中元素<strong>按关键字有序排列</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> ((key &lt; arr[left] || key &gt; arr[right] || left &gt; right) &#123;</span><br><span class="line">       ...</span><br><span class="line">      <span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line">   <span class="keyword">if</span> (key &gt; midVal) &#123; <span class="comment">// 向右递归</span></span><br><span class="line">      <span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, key);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; midVal) &#123; <span class="comment">// 向左递归</span></span><br><span class="line">      <span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, key);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">int</span> temp = mid - <span class="number">1</span>;</span><br><span class="line">       <span class="comment">/*多值返回</span></span><br><span class="line"><span class="comment">       while(true) &#123;</span></span><br><span class="line"><span class="comment">           if (temp &lt; 0 || arr[temp] != findVal) &#123;//退出</span></span><br><span class="line"><span class="comment">               break;</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">           //否则，就temp 放入到 resIndexlist</span></span><br><span class="line"><span class="comment">           resIndexlist.add(temp);</span></span><br><span class="line"><span class="comment">           temp -= 1; //temp—1左移;temp+1右移</span></span><br><span class="line"><span class="comment">       &#125;*/</span></span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h5 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h5><blockquote>
<p>插值查找，有序表的一种查找方式。插值查找是<strong>根据查找关键字与查找表中最大最小记录关键字比较后</strong>的查找方法。插值查找<strong>基于</strong>二分查找，将查找点的选择改进为自适应选择，提高查找效率。<img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20210726erfen.png" style="zoom: 50%;" /></p>
<ol>
<li>对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找,速度较快.</li>
<li>关键字分布不均匀的情况下，该方法不一定比折半查找要好</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (left &gt; right || findVal &lt; arr[<span class="number">0</span>] || findVal &gt; arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">   <span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出mid, 自适应</span></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);</span><br></pre></td></tr></table></figure>

<h5 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h5><blockquote>
<p>斐波那契数列中(上表来自维基百科)，<strong>从第三项开始，每一项都等于前两项之和</strong>：</p>
<p>F(n) = F(n - 1) + F(n - 2)        (n &gt; 2)</p>
<p>F(n) -1= [ F(n - 1) -1 ] + [ F(n - 2) - 1 ] + 1        (n &gt; 0)</p>
<p>1    1    2    3    5    8    13    21    55    76    ….</p>
<p>0    0    1    2    4    7    12    20    54    75    ….</p>
</blockquote>
<img src="https://gitee.com/LazyC-99/blog-images/raw/master/img/20191129110124337.png" style="zoom: 80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成斐波那契数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> [] Fibonacci()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> [] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">   f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//斐波那契查找</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Fibonacci_Search</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> low, high, mid;</span><br><span class="line">   <span class="keyword">int</span> n = a.length;</span><br><span class="line">   low = <span class="number">1</span>;</span><br><span class="line">   high = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> [] F = Fibonacci();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//查找数组 中 元素个数 在斐波那契数列中的位置</span></span><br><span class="line">   <span class="keyword">while</span> ( n &gt; F[k] - <span class="number">1</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      k++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将a数组扩充到最近一个斐波那契数的长度，用数组最后一个数字填充</span></span><br><span class="line">   a = Arrays.copyOf(a, F[k]);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; F[k] - <span class="number">1</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      a[i] = a[high];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//查找</span></span><br><span class="line">   <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">   &#123;</span><br><span class="line">      mid = low + F[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//向左查找</span></span><br><span class="line">      <span class="keyword">if</span> ( key &lt; a[mid] )</span><br><span class="line">      &#123;</span><br><span class="line">         high = mid - <span class="number">1</span>;</span><br><span class="line">         k = k - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//向右查找</span></span><br><span class="line">      <span class="comment">//则将F[k]-1长数组的前半部分low+F[k-1]-1(大段)作为新的递归序列，若key &gt; temp[mid]，就使用后半部分low+F[k-2]-1(小段)，如此就实现了二分。</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( key &gt; a[mid] )</span><br><span class="line">      &#123;</span><br><span class="line">         low = mid + <span class="number">1</span>;</span><br><span class="line">         k = k - <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span> ( mid &lt;= high )</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>151P  </p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
