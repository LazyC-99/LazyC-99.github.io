<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="数据结构包括：线性结构和非线性结构">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="http://example.com/2021/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="LazyC-99">
<meta property="og:description" content="数据结构包括：线性结构和非线性结构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192021255.png">
<meta property="og:image" content="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192021531.png">
<meta property="og:image" content="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192021470.png">
<meta property="og:image" content="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192022933.png">
<meta property="og:image" content="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192022932.png">
<meta property="og:image" content="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192022217.png">
<meta property="og:image" content="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192023648.jpg">
<meta property="og:image" content="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192023159.jpg">
<meta property="og:image" content="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192024504.jpg">
<meta property="og:image" content="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192024500.png">
<meta property="og:image" content="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192025999.png">
<meta property="og:image" content="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192024017.png">
<meta property="og:image" content="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192025443.png">
<meta property="og:image" content="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192025065.png">
<meta property="article:published_time" content="2021-08-17T13:47:57.000Z">
<meta property="article:modified_time" content="2022-06-23T13:38:56.030Z">
<meta property="article:author" content="LazyC-99">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192021255.png">

<link rel="canonical" href="http://example.com/2021/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构与算法 | LazyC-99</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1754dd488b86cf701e1f9cbc3e330b03";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LazyC-99</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="LazyC-99">
      <meta itemprop="description" content="Human sorrows and joys are not interlinked, I just think they are noisy.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LazyC-99">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构与算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-17 21:47:57" itemprop="dateCreated datePublished" datetime="2021-08-17T21:47:57+08:00">2021-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 21:38:56" itemprop="dateModified" datetime="2022-06-23T21:38:56+08:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>数据结构包括：线性结构和非线性结构</p>
<a id="more"></a>

<ul>
<li><p>线性结构</p>
<ol>
<li>线性结构作为最常用的数据结构，其特点是数据元素之间存在<strong>一对一的线性关系</strong>（eg: int a[] =0 ）</li>
<li>线性结构有两种不同的存储结构，即<strong>顺序存储结构(数组)**和</strong>链式存储结构（链表）**</li>
<li>顺序存储的线性表称为<strong>顺序表</strong>，顺序表中存储的元素是连续的；链式存储的线性表称为<strong>链表</strong>，链表中存储的元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息</li>
<li>常见的线性结构：数组、队列、链表和栈</li>
</ol>
</li>
<li><p>非线性结构</p>
<p>非线性结构包括：二位数组、多维数组、广义表、树结构、图结构</p>
</li>
</ul>
<h4 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h4><p>当一个数组中大部分元素为0，或者同一个值得数组时，可以使用稀疏数组来保存该数组。</p>
<p>二维数组转稀疏数组：</p>
<ol>
<li>遍历二维数组，得到有效数据sum</li>
<li>根据sum创建稀疏数组<code>sparseArr int[sum+1][3]</code>，第一行记录数组一共有几行，几列，有多少个不同的值</li>
<li>将二维数组的有效数据存入到稀疏数组</li>
</ol>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li>队列是一个有序列表，可以用<strong>数组</strong>或<strong>链表</strong>来实现</li>
<li>遵循先进先出</li>
<li>数组模拟队列示意图</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192021255.png"></p>
<ul>
<li><p>数组队列：其中maxSize是该队列的最大容量，front及rear分别记录队列前后端的下标，front 会随着数据<strong>输出</strong>而改变，而rear则是随着数据<strong>输入</strong>而改变。</p>
<p>将尾指针往后移: <code>rear+1</code>，当<code>front == rear</code> 【空】</p>
<p>若尾指针rear小于队列的最大下标<code>maxSize-1</code>，则将数据存入rear所指的数组元素中，否则无法存入数据。<code>rear == maxSize-1</code>[队列满]</p>
</li>
<li><p>环形队列：front和rear初始值为0，当队列满时：<code>(rear+1)%maxSize==front</code>队列中有效数据：<code>(rear+maxSize-front)%maxSize</code></p>
</li>
</ul>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><ul>
<li>链表是以节点的方式来存储</li>
<li>每个节点包含data域，next域：指向下一个节点</li>
<li>链表是有序的列表，但在内存中不一定是连续存储</li>
<li>链表分带头节点的和不带头结点的链表，根据实际需求确定</li>
</ul>
<p><strong><em>单链表面试题:</em></strong></p>
<ol>
<li>求单链表中节点的个数</li>
<li>查找单链表综中的倒数第K个节点【新浪】</li>
<li>单链表的反转【腾讯】</li>
<li>从尾到头打印单链表【百度】</li>
</ol>
<h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><ul>
<li>单项链表查找的方向只能是一个方向，而双向链表可以向前或者向后查找</li>
<li>单向链表不能自我删除，需要靠辅助节点，而双向链表可以自我删除(1)<code>temp.pre.next=temp.next</code>(2)<code>temp.next.pre=temp.pre</code></li>
</ul>
<h5 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h5><h6 id="约瑟夫问题："><a href="#约瑟夫问题：" class="headerlink" title="约瑟夫问题："></a><strong><em>约瑟夫问题：</em></strong></h6><p>n = 5，即有5个人；k=1，从第一个人开始报数；m = 2，数2下</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192021531.png" alt="202107yueshefu"></p>
<ol>
<li>需求创建一个辅助指针(变量) helper ,事先应该指向环形链表的最后这个节点.</li>
<li>先让first和helper移动k-1次</li>
<li>报数时，让first和helper指针同时的移动m -1次</li>
<li>将first指向的小孩节点出圈<br>first= first.next<br>helper.next =first<br>原来first指向的节点就没有任何引用，就会被回牧</li>
</ol>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>树的存储方式能提高数据<strong>存储</strong>，<strong>读取</strong>的效率，比如利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。</p>
<h5 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T)<span class="comment">//如果当前节点不为空</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,T-&gt;data);    <span class="comment">//输出当前节点的值 上中下决定前中后</span></span><br><span class="line">      PreOrderTraverse(T-&gt;Left); <span class="comment">//再调用自己到左节点</span></span><br><span class="line">      PreOrderTraverse(T-&gt;Right);<span class="comment">//最后到右节点</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历(深度优先算法)</span></span><br><span class="line"><span class="comment"> * 利用栈实现循环先序遍历二叉树</span></span><br><span class="line"><span class="comment"> * 这种实现类似于图的深度优先遍历（DFS）</span></span><br><span class="line"><span class="comment"> * 维护一个栈，将根节点入栈，然后只要栈不为空，出栈并访问，接着依次将访问节点的右节点、左节点入栈。</span></span><br><span class="line"><span class="comment"> * 这种方式应该是对先序遍历的一种特殊实现（看上去简单明了），但是不具备很好的扩展性，在中序和后序方式中不适用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param root 树根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderStack_1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="built_in">stack</span>.push(root);</span><br><span class="line">    TreeNode currentNode;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">        currentNode = <span class="built_in">stack</span>.pop();</span><br><span class="line">        System.out.print(currentNode.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (currentNode.right != null) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(currentNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode.left != null) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(currentNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 层序遍历(广度优先算法)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">treeIteratorByLevel</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="built_in">queue</span>.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">        TreeNode temp = <span class="built_in">queue</span>.poll();</span><br><span class="line">        System.out.println(temp.value);</span><br><span class="line">        <span class="keyword">if</span> (temp.left != null) &#123;</span><br><span class="line">            <span class="built_in">queue</span>.add(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.right != null) &#123;</span><br><span class="line">            <span class="built_in">queue</span>.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树查找"><a href="#二叉树查找" class="headerlink" title="二叉树查找"></a>二叉树查找</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DLR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点 上中下决定前中后</span></span><br><span class="line">	<span class="comment">// 左子树递归</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.left.DLR();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 右子树递归</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.right.DLR();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="节点删除"><a href="#节点删除" class="headerlink" title="节点删除"></a>节点删除</h5><ol>
<li>因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.</li>
<li>如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</li>
<li>如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right=null ;并且就返回(结束递归删除)</li>
<li>如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</li>
<li> 如果第4步也没有删除结点，则应当向右子树进行递归删除.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果只有一个root结点, 这里立即判断root是不是就是要删除结点</span></span><br><span class="line">			<span class="keyword">if</span>(root.getNo() == no) &#123;</span><br><span class="line">				root = <span class="keyword">null</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//递归删除</span></span><br><span class="line">				root.delNode(no);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;空树，不能删除~&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//递归删除结点</span></span><br><span class="line">    <span class="comment">//1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line">    <span class="comment">//2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        */</span><br><span class="line">       <span class="comment">//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line">          <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line">          <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4.我们就需要向左子树进行递归删除</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//5.则应当向右子树进行递归删除</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="顺序存储二叉树"><a href="#顺序存储二叉树" class="headerlink" title="顺序存储二叉树"></a>顺序存储二叉树</h5><ol>
<li>顺序二叉树通常只考虑完全二叉树</li>
<li>第n个元素的左子节点为 2*n +1</li>
<li>第n个元素的右子节点为 2*n +2</li>
<li>第n个元素的父子节点为 (n-1)/2</li>
<li>n：表示二叉树中的第几个元素（0开始编号）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序存储二叉树遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//如果数组为空，或者 arr.length = 0</span></span><br><span class="line">   <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;数组为空，不能按照二叉树的前序遍历&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//输出当前这个元素</span></span><br><span class="line">   System.out.println(arr[index]); </span><br><span class="line">   <span class="comment">//向左递归遍历</span></span><br><span class="line">   <span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length) &#123;</span><br><span class="line">      preOrder(<span class="number">2</span> * index + <span class="number">1</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//向右递归遍历</span></span><br><span class="line">   <span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">2</span>) &lt; arr.length) &#123;</span><br><span class="line">      preOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h5><ol>
<li>n个结点的二叉链表中含有n+1【公式2n-(n-1)=n+1】个<strong>空指针域</strong>。利用二叉链表中的空指针域，<strong>存放指向该结点</strong>在某种遍历次序下（前中后序）的<strong>前驱和后继结点</strong>的指针(这种附加的指针称为”线索”)</li>
<li>这种加上了线索的二叉链表称为<strong>线索链表</strong>，相应的二叉树称为<strong>线索二叉树</strong>(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种</li>
<li>一个结点的前一个结点，称为前驱结点</li>
<li>一个结点的后一个结点，称为后继结点</li>
</ol>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192021470.png" alt="20210803xianshuo"></p>
<p>说明：当线索化二叉树后，Node节点的属性left和right，有如下情况:</p>
<ol>
<li>left指向的是左子树，也可能是指向的前驱节点，比如节点left指向的左子树,而⑩节点的 left指向的就是前驱节点.</li>
<li>right指向的是右子树，也可能是指向后继节点，比如①节点right指向的是右子树，而⑩节点的right指向的是后继节点.</li>
<li>为了区分left，right的指向，节点类中添加leftType，rightType。如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点，rightType同理 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果node==null, 不能线索化</span></span><br><span class="line">       <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//(一)递归线索化左子树</span></span><br><span class="line">       threadedNodes(node.getLeft());</span><br><span class="line">       <span class="comment">//(二)线索化当前结点</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//处理当前结点的前驱结点</span></span><br><span class="line">       <span class="keyword">if</span>(node.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//让当前结点的左指针指向前驱结点 </span></span><br><span class="line">          node.setLeft(pre); </span><br><span class="line">          <span class="comment">//修改当前结点的左指针的类型,指向前驱结点</span></span><br><span class="line">          node.setLeftType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//处理后继结点</span></span><br><span class="line">       <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//让前驱结点的右指针指向当前结点</span></span><br><span class="line">          pre.setRight(node);</span><br><span class="line">          <span class="comment">//修改前驱结点的右指针类型</span></span><br><span class="line">          pre.setRightType(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点</span></span><br><span class="line">       pre = node;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//(三)递归线索化右子树</span></span><br><span class="line">       threadedNodes(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线索化二叉树遍历</p>
<blockquote>
<p>因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//遍历线索化二叉树的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个变量，存储当前遍历的结点，从root开始</span></span><br><span class="line">        HeroNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//循环的找到leftType == 1的结点，</span></span><br><span class="line">            <span class="comment">//后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化</span></span><br><span class="line">            <span class="comment">//处理后的有效结点</span></span><br><span class="line">            <span class="keyword">while</span>(node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打印当前这个结点</span></span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="comment">//如果当前结点的右指针指向的是后继结点,就一直输出</span></span><br><span class="line">            <span class="keyword">while</span>(node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//获取到当前结点的后继结点</span></span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//替换这个遍历的结点</span></span><br><span class="line">            node = node.getRight();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h5><p>二叉排序树：BST(Binary Sort(Search) Tree),对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。<img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192022933.png" alt="20210812paixusu"></p>
<p><strong>添加节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//判断传入的结点的值，和当前子树的根结点的值关系</span></span><br><span class="line">   <span class="keyword">if</span>(node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">      <span class="comment">//如果当前结点左子结点为null</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.left = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//递归的向左子树添加</span></span><br><span class="line">         <span class="keyword">this</span>.left.add(node);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//添加的结点的值大于 当前结点的值</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.right = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//递归的向右子树添加</span></span><br><span class="line">         <span class="keyword">this</span>.right.add(node);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除节点</strong></p>
<p>第一种情况：删除叶子节点思路</p>
<ol>
<li>需求先去找到要删除的结点targetNode</li>
<li>找到targetNode的父结点parent</li>
<li>确定targetNode是parent的左子结点还是右子结点</li>
<li>根据前面的情况来对应删除左子结点parent.left = null右子结点parent.right = null;</li>
</ol>
<p>第二种情况：删除只有一颗子树的节点</p>
<p>​    ….</p>
<ol start="4">
<li><p>判断targetNode下面是左子结点还是右子结点</p>
<p>（1）左：</p>
<ul>
<li>如果targetNode是parent的左子结点parent.left = targetNode.left;<ul>
<li>如果targetNode是 parent的右子结点parent.right = targetNode.left;</li>
</ul>
</li>
</ul>
<p>（2）右：</p>
<ul>
<li>如果 targetNode是parent的左子结点parent.left = targetNode.right;<ul>
<li>如果argetNode是parent的右子结点parent.right = targetNode.right</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>第三种情况：删除有两颗子树的节点</p>
<p>​    …</p>
<ol start="3">
<li>从targetNode 的右子树找到最小的结点(或者左子树最大的结点)</li>
<li>用一个临时变量，将最小结点的值保存</li>
<li>删除该最小结点，令targetNode等于该节点 targetNode.value = temp</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">      Node targetNode = search(value);</span><br><span class="line">      <span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line">      <span class="keyword">if</span>(targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点</span></span><br><span class="line">      <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">         root = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">      Node parent = searchParent(value);</span><br><span class="line">      <span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line">      <span class="keyword">if</span>(targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的节点*</span></span><br><span class="line">         <span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">         targetNode.value = minVal;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 删除只有一颗子树的结点</span></span><br><span class="line">          ...</span><br><span class="line">         <span class="keyword">if</span>(targetNode.left != <span class="keyword">null</span>) &#123;<span class="comment">//如果要删除的结点有左子结点</span></span><br><span class="line">			...</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果要删除的结点有右子结点 </span></span><br><span class="line">            ...</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node target = node;</span><br><span class="line">    <span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line">    <span class="keyword">while</span>(target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target = target.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这时 target就指向了最小结点 删除最小结点</span></span><br><span class="line">    delNode(target.value);</span><br><span class="line">    <span class="keyword">return</span> target.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h5><blockquote>
<ol>
<li>平衡二叉树也叫平衡二叉搜索树(Self-balancing binary search tree）又被称为AVL树，可以保证查询效率较高。</li>
<li>具有以下特点:它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。</li>
</ol>
</blockquote>
<p><strong>单旋转</strong>（左旋：当右子树的高度 - 左子树的高度 &gt; 1）</p>
<ol>
<li>创建一个新的节点，令其值等于当前<strong>根节点</strong>的值</li>
<li>把新节点的左子树指向当前节点的左子树  newNode.left = left</li>
<li>把新节点的右子树指向当前节点的<strong>右子树的左子树</strong>  newNode.right =right.left</li>
<li>把当前节点的<strong>值换</strong>为右子节点的值 value=right.value</li>
<li>把当前节点的右子树指向成<strong>右子树的右子树</strong> right=right.right</li>
<li>把当前节点的左子树指向新节点 left=newNode </li>
</ol>
<p>注：右旋将所有left和right对换</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192022932.png" alt="202100812zuoxuan"></p>
<p><strong>双旋转</strong></p>
<p>当符合右旋转的条件时，如果它的<strong>左子树的右子树</strong>高度大于它的<strong>右子树</strong>高度，先对左子树进行左旋转，再对当前节点进行右旋转</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192022217.png" alt="20210813shuangxuan"></p>
<h4 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a>多叉树</h4><h5 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h5><blockquote>
<ol>
<li>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</li>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</li>
<li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.)，2-3树是由二节点和三节点构成的树。</li>
<li>当按照规则插入一个数到某个节点时，不能满足上面三个要求,就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满定上面3个条件。</li>
<li>对于三节点的子树的值大小仍然遵守<strong>二叉排序树</strong>的规则</li>
</ol>
</blockquote>
<h5 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h5><blockquote>
<ol>
<li>B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4</li>
<li>B-树的搜索，从根结点开始,对结点内的关键字（有序）序列进**行二分查找,**如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li>
<li>关键字集合分布在整颗树中，即叶子节点和非叶子节点都存放数据-<br> 搜索有可能在非叶子结点结束</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找</li>
</ol>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192023648.jpg" alt="1347265816_7366"></p>
</blockquote>
<h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><blockquote>
<ol>
<li>B+树是B树的变体，也是多路B+树的搜索与B树也基本相同，区别是B树只有达到叶子结点才命中(树可以在非叶子结点合中)，其性能也等价于在关键字全集做一次二分查找</li>
<li>所有<strong>关键字都出现在叶了结点的链表中</strong>(即数据只能在叶子节点【也叫稠密索引】)，且链表中的关键字数据)恰好是有序的。</li>
<li>不可能在非叶子结点命中</li>
<li>非叶子结点相当于是叶子结点的索引(稀疏索引叶子结点相当子是存储(关键字)数据的数据层</li>
<li>更适合文件索引系统</li>
<li>B树和B+树各有自己的应用场景,不能说B+树完全比B树好，反之亦然.</li>
</ol>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192023159.jpg" alt="1347265821_7407"></p>
</blockquote>
<h5 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h5><blockquote>
<p>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</p>
<ol>
<li>B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。</li>
<li>从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高</li>
</ol>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192024504.jpg" alt="1347265826_6256"></p>
</blockquote>
<h4 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h4><blockquote>
<ol>
<li><p>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为<strong>路径</strong>。通路中分支的数目称为<strong>路径长度</strong>。若规定根结点的层数为1，则从根结点到第L层结点的<strong>路径长度为L-1</strong></p>
</li>
<li><p>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为<strong>该结点的权</strong>。</p>
<p>结点的带权路径长度为：从根结点到该结点之间的<strong>路径长度</strong>与该结点的<strong>权</strong>的<strong>乘积</strong></p>
</li>
<li><p>树的带权路径长度：树的带权路径长度规定为<strong>所有叶子结点的带权路径长度之和</strong>，记为WPL(weighted path length) ，<strong>权值越大的结点离根结点越近</strong>的二叉树才是<strong>最优二叉树</strong>（赫夫曼树）</p>
</li>
<li><p>WPL最小的就是赫夫曼树</p>
</li>
<li><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192024500.png" alt="20210812heufman" style="zoom:50%;" />
</li>
</ol>
</blockquote>
<p>构成赫夫曼树的步骤：</p>
<ol>
<li>从小到大进行排序,将每一个数据，每个数据都是一个节点，每个节点可以看成是—颗最简单的二叉树</li>
<li>取出根节点权值最小的两颗二叉树</li>
<li>组成一颗新的二叉树,该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</li>
<li>再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步为了操作方便</span></span><br><span class="line">    <span class="comment">// 1. 遍历 arr 数组</span></span><br><span class="line">    <span class="comment">// 2. 将arr的每个元素构成成一个Node</span></span><br><span class="line">    <span class="comment">// 3. 将Node 放入到ArrayList中</span></span><br><span class="line">    List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">        nodes.add(<span class="keyword">new</span> Node(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序 从小到大 </span></span><br><span class="line">        Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;nodes =&quot;</span> + nodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出根节点权值最小的两颗二叉树 </span></span><br><span class="line">        <span class="comment">//(1) 取出权值最小的结点（二叉树）</span></span><br><span class="line">        Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//(2) 取出权值第二小的结点（二叉树）</span></span><br><span class="line">        Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(3)构建一颗新的二叉树</span></span><br><span class="line">        Node parent = <span class="keyword">new</span> Node(leftNode.value + rightNode.value);</span><br><span class="line">        parent.left = leftNode;</span><br><span class="line">        parent.right = rightNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(4)从ArrayList删除处理过的二叉树</span></span><br><span class="line">        nodes.remove(leftNode);</span><br><span class="line">        nodes.remove(rightNode);</span><br><span class="line">        <span class="comment">//(5)将parent加入到nodes</span></span><br><span class="line">        nodes.add(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回哈夫曼树的root结点</span></span><br><span class="line">    <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h5><blockquote>
<ol>
<li>赫夫曼编码也翻译为哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式,属于一种程序算法</li>
<li>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</li>
<li>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%~90%之间</li>
<li>赫夫曼码是<strong>可变字长</strong>编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Node类,待数据和权值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;  </span>&#123;</span><br><span class="line">   Byte data; <span class="comment">// 存放数据(字符)本身，比如&#x27;a&#x27; =&gt; 97 &#x27; &#x27; =&gt; 32</span></span><br><span class="line">   <span class="keyword">int</span> weight; <span class="comment">//权值, 表示字符出现的次数</span></span><br><span class="line">   Node left;<span class="comment">//</span></span><br><span class="line">   Node right;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Byte data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">      <span class="keyword">this</span>.weight = weight;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 从小到大排序</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.weight - o.weight;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字节数组转为Node集合以构建赫夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getNodes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历 bytes , 统计 每一个byte出现的次数-&gt;map[key,value]</span></span><br><span class="line">    Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">        Integer count = counts.get(b);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123; <span class="comment">// Map还没有这个字符数据,第一次</span></span><br><span class="line">            counts.put(b, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把每一个键值对转成一个Node 对象，并加入到nodes集合</span></span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Byte, Integer&gt; entry: counts.entrySet()) &#123;</span><br><span class="line">        nodes.add(<span class="keyword">new</span> Node(entry.getKey(), entry.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建赫夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span></span>&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将赫夫曼树所有叶子节点转为赫夫曼编码</span></span><br><span class="line"><span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;Byte,String&gt;();</span><br><span class="line"><span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">    StringBuilder stringBuilder2 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line">    <span class="comment">//将code 加入到 stringBuilder2</span></span><br><span class="line">    stringBuilder2.append(code);</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123; <span class="comment">//如果node == null不处理</span></span><br><span class="line">        <span class="comment">//判断当前node 是叶子结点还是非叶子结点</span></span><br><span class="line">        <span class="keyword">if</span>(node.data == <span class="keyword">null</span>) &#123; <span class="comment">//非叶子结点</span></span><br><span class="line">            <span class="comment">//递归处理</span></span><br><span class="line">            <span class="comment">//向左递归</span></span><br><span class="line">            getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder2);</span><br><span class="line">            <span class="comment">//向右递归</span></span><br><span class="line">            getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//说明是一个叶子结点</span></span><br><span class="line">            <span class="comment">//就表示找到某个叶子结点的最后</span></span><br><span class="line">            huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将赫夫曼编码转为字节数组  每8位转为一个byte  (byte)Integer.parseInt(str,2)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">		<span class="comment">//1.利用 huffmanCodes 将  bytes 转成  赫夫曼编码对应的字符串</span></span><br><span class="line">		StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//遍历bytes 数组 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">byte</span> b: bytes) &#123;</span><br><span class="line">			stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="comment">//一句话 </span></span><br><span class="line">		<span class="keyword">int</span> len = (stringBuilder.length() + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">		<span class="comment">//创建 存储压缩后的 byte数组</span></span><br><span class="line">		<span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//记录是第几个byte</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123; <span class="comment">//因为是每8位对应一个byte,所以步长 +8</span></span><br><span class="line">				String strByte;</span><br><span class="line">				<span class="keyword">if</span>(i+<span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">					strByte = stringBuilder.substring(i);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">				&#125;	</span><br><span class="line">				<span class="comment">//将strByte 转成一个byte,放入到 huffmanCodeBytes</span></span><br><span class="line">				huffmanCodeBytes[index] = (<span class="keyword">byte</span>)Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">				index++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="赫夫曼解码"><a href="#赫夫曼解码" class="headerlink" title="赫夫曼解码"></a>赫夫曼解码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 字节数组转二进制的字符串</span><br><span class="line">   <span class="number">2.</span> 将赫夫曼编码表key-value进行调换</span><br><span class="line">   <span class="number">3.</span> 将二进制根据编码表进行解码</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; stringBuilder.length(); ) &#123;</span><br><span class="line">           <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// 小的计数器</span></span><br><span class="line">           <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">               <span class="comment">//1010100010111...</span></span><br><span class="line">               <span class="comment">//递增的取出 key 1 </span></span><br><span class="line">               String key = stringBuilder.substring(i, i+count);<span class="comment">//i 不动，让count移动，指定匹配到一个字符</span></span><br><span class="line">               </span><br><span class="line">               <span class="keyword">if</span>(map.containsKey(key))&#123;<span class="comment">//匹配到</span></span><br><span class="line">                   flag = <span class="keyword">false</span>;</span><br><span class="line">                   list.add(map.get(key));<span class="comment">//添加到list</span></span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;					<span class="comment">//没有匹配到</span></span><br><span class="line">                    count++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           i += count;<span class="comment">//i 直接移动到 count	</span></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br></pre></td></tr></table></figure>

<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><blockquote>
<p>图(Graph)是由顶点和连接顶点的边构成的离散结构。在计算机科学中，图是最灵活的数据结构之一，很多问题都可以使用图模型进行建模求解。</p>
<p>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。结点也可以称为顶点。</p>
<p>当需要表示多对多的关系时，就用到了图</p>
</blockquote>
<p>图的表示方式有两种：</p>
<ol>
<li>二维数组表示（邻接矩阵）</li>
<li>链表表示（邻接表）</li>
</ol>
<p><strong>邻接矩阵</strong></p>
<p>1.邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1….n个点。（1表示能直接连接，0表示不能直接连接）<img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192025999.png" alt="5448614122959"></p>
<p><strong>邻接表</strong></p>
<ol>
<li>邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失.</li>
<li>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由<strong>数组+链表</strong>组成</li>
</ol>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192024017.png" alt="2846984564685"></p>
<p>​    说明：标号为0的结点的相关联的结点为1 2 3 4</p>
<h5 id="图的创建-邻接矩阵"><a href="#图的创建-邻接矩阵" class="headerlink" title="图的创建(邻接矩阵)"></a>图的创建(<strong>邻接矩阵</strong>)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList; <span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges; <span class="comment">//存储图对应的邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges; <span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="comment">//定义给数组boolean[], 记录某个结点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> ArrayList&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span> </span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> v1 表示点的下标即使第几个顶点(几行几列)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> weight 权值（是否连接） </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="图遍历"><a href="#图遍历" class="headerlink" title="图遍历"></a>图遍历</h5><blockquote>
<p>所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略:(1)深度优先遍历    (2)广度优先遍历</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192025443.png" alt="20210814dfs"></p>
</blockquote>
<p><strong>深度优先搜索DFS(Depth First Search)</strong></p>
<p>基本思想：</p>
<ol>
<li>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点，可以这样理解:每次都在访问完当前结点后首先访问<strong>当前结点的第一个邻接结点</strong>。</li>
<li>这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。</li>
<li>深度优先搜索是一个递归的过程</li>
</ol>
<p>实现步骤：</p>
<ol>
<li>访问初始结点v，并标记结点v为已访问。</li>
<li>查找结点v的第一个邻接结点w。</li>
<li>若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。</li>
<li>若w未被访间，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123)</li>
<li>若w已被访间，查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</li>
</ol>
<p><strong>广度优先搜索BFS(Broad First Search)</strong> </p>
<p>基本思想：</p>
<p>类似于一个分层搜索的过程，广度优先遍历需要使用一个<strong>队列</strong>以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</p>
<p>实现步骤：</p>
<ol>
<li><p>访问初始结点v并标记结点v为已访问。</p>
</li>
<li><p>结点v入队列</p>
</li>
<li><p>当队列非空时，继续执行，否则算法结束。</p>
</li>
<li><p>出队列，取得队头结点u。</p>
</li>
<li><p>查找结点u的第一个邻接结点w。</p>
</li>
<li><p>若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：</p>
<p>6.1 若结点w尚未被访问，则访问结点w并标记为已访问。</p>
<p>6.2 结点w入队列</p>
<p>6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</p>
</li>
</ol>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul>
<li>栈的英文为(stack)，是一个**先入后出(**FILO-First In Last Out)的有序列表。</li>
<li>栈(stack)是限制线性表中元素的插入和删除<strong>只能在线性表的同一端</strong>进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为<strong>栈顶</strong>(Top)，另一端为固定的一端，称为<strong>栈底</strong>(Bottom)。</li>
<li>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而<br>删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</li>
</ul>
<h5 id="实现栈的思路分析："><a href="#实现栈的思路分析：" class="headerlink" title="实现栈的思路分析："></a><strong><em>实现栈的思路分析：</em></strong></h5><ol>
<li>使用数组来模拟栈</li>
<li>定义一个top来表示栈顶,初始化为-1</li>
<li>入栈的操作，当有数据加入到栈时，<code>top++; stack[topl= data;</code></li>
<li>出栈的操作,<code>int value =stack[top];top--;returnvalue</code></li>
</ol>
<h5 id="使用栈完成表达式的计算界路："><a href="#使用栈完成表达式的计算界路：" class="headerlink" title="使用栈完成表达式的计算界路："></a><strong><em>使用栈完成表达式的计算界路：</em></strong></h5><p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205192025065.png" alt="20210711zhan"></p>
<ol>
<li>通过一个index值（索引，来遍历表达式）</li>
<li>如果我们发现是一个数字,就直接入数栈</li>
<li>如果发现扫描到是一个符号,就分如下情况<ol>
<li>如果发现当前的符号核为空，就直接入栈</li>
<li>如果符号栈有操作符，就进行比较,如果<strong>当前的操作符的优先级小于或者等于</strong>栈中的操作符，就需要从数栈中pop出两个数在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈，如果<strong>当前的操作符的优先级大于</strong>栈中的操作符,就直接入符号栈.</li>
<li>当表达式扫描完毕,就顺序的从数栈和符号栈中pop出相应的数和符号，并运行.</li>
<li>最后在数栈只有一个数字,就是表达式的结果</li>
</ol>
</li>
<li>问题：加减顺序出错</li>
</ol>
<h5 id="中缀表达式转换为后缀表达式（逆波兰式）"><a href="#中缀表达式转换为后缀表达式（逆波兰式）" class="headerlink" title="中缀表达式转换为后缀表达式（逆波兰式）:"></a><strong><em>中缀表达式转换为后缀表达式（逆波兰式）:</em></strong></h5><ol>
<li>初始化两个栈:运算符栈s1和储存中间结果的栈s2;</li>
<li>从左至右扫描中缀表达式;</li>
<li>遇到操作数时，将其压s2;</li>
<li><strong>遇到运算符时</strong>，比较其与s1栈顶运算符的优先级:<ol>
<li>如果s1为空，或栈顶运算符为左括号“(“，则直接将此运算符入栈;</li>
<li>否则，若优先级比栈顶运算符的高，也将运算符压入s1;</li>
<li>否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算<br>符相比较;</li>
</ol>
</li>
<li><strong>遇到括号时</strong>:<ol>
<li>如果是左括号“(“，则直接压入s1</li>
<li>如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</li>
</ol>
</li>
<li>重复步骤2至5，直到表达式的最右边</li>
<li>将s1中剩余的运算符依次弹出并压入s2</li>
<li>依次弹出s2中的元素并输出，结果的<strong>逆序</strong>即为中缀表达式对应的后缀表达式</li>
</ol>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><blockquote>
<p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。HashTable的方法是同步的，即是线程安全的。</p>
</blockquote>
<p>HashTable和HaspMap区别：</p>
<ol>
<li>HaspMap的方法不是同步的，不是线程安全的的。</li>
<li>HashTable中不允许有null键和null值，HashMap中允许出现一个null键，可以存在一个或者多个键的值都为null,因此，在HashMap中，我们不能使用get()方法来查询键 对应的值，应该使用containskey()方法。</li>
<li>HashTable是直接使用对象的hashCode。HashMap是重新计算hash值。</li>
<li>HashTable和HashMap的底层实现的数组和初始大小和扩容方式。HashTable初始大小为11，并且每次扩容都为：2<em>old+1。HashMap的默认大小为16，并且一 定是2的指数，每次扩容都为old</em>2。</li>
</ol>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。</p>
<p>递归需要遵守规则：</p>
<ol>
<li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li>
<li>方法的局部变量是独立的，不会相互影响,比如n变量</li>
<li>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.</li>
<li>递归必须向退出递归的条件逼近，否则就是无限递归,出现<strong>StackOverflowError</strong></li>
<li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果<br>返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</li>
</ol>
<h5 id="八皇后问题："><a href="#八皇后问题：" class="headerlink" title="八皇后问题："></a><em>八皇后问题：</em></h5><p>八皇后问题，是一个古老而著名的问题，<strong>是回溯算法的典型案例</strong>。即:任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p>
<p><strong>算法思路分析：</strong></p>
<ol>
<li>第一个皇后先放第一行第一列</li>
<li>第二个皇后放在第二行第一列、然后判断是否冲突，如果不冲突，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</li>
<li>继续第三个皇后，还是第一列、第二列…….直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</li>
<li>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</li>
<li>然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4的步骤</li>
</ol>
<p>说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题.<code>arr[8]= &#123;0 ,4,7,5,2,6,1,3&#125;</code>//对应arr下标表示第几行，即第几个皇后，<code>arr[i]=val </code>, val表示第i+1个皇后，放在第i+1行的第val+1列</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/uploads/wechatpay.png" alt="LazyC-99 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/uploads/alipay.jpg" alt="LazyC-99 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="fa fa-tag"></i> 数据结构</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/26/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="Nodejs学习">
      <i class="fa fa-chevron-left"></i> Nodejs学习
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/08/30/%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/" rel="next" title="十大常用算法">
      十大常用算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84"><span class="nav-number">1.</span> <span class="nav-text">稀疏数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">2.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">3.1.</span> <span class="nav-text">单链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">3.2.</span> <span class="nav-text">双向链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-number">3.3.</span> <span class="nav-text">环形链表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">3.3.1.</span> <span class="nav-text">约瑟夫问题：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="nav-number">4.1.</span> <span class="nav-text">二叉树遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE"><span class="nav-number">4.2.</span> <span class="nav-text">二叉树查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4"><span class="nav-number">4.3.</span> <span class="nav-text">节点删除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.4.</span> <span class="nav-text">顺序存储二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.5.</span> <span class="nav-text">线索化二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="nav-number">4.6.</span> <span class="nav-text">二叉排序树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.7.</span> <span class="nav-text">平衡二叉树</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%8F%89%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">多叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3%E6%A0%91"><span class="nav-number">5.1.</span> <span class="nav-text">2-3树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B%E6%A0%91"><span class="nav-number">5.2.</span> <span class="nav-text">B树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-%E6%A0%91"><span class="nav-number">5.3.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-%E6%A0%91-1"><span class="nav-number">5.4.</span> <span class="nav-text">B*树</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">6.</span> <span class="nav-text">赫夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-number">6.1.</span> <span class="nav-text">赫夫曼编码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E8%A7%A3%E7%A0%81"><span class="nav-number">6.2.</span> <span class="nav-text">赫夫曼解码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">7.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%88%9B%E5%BB%BA-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-number">7.1.</span> <span class="nav-text">图的创建(邻接矩阵)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%BE%E9%81%8D%E5%8E%86"><span class="nav-number">7.2.</span> <span class="nav-text">图遍历</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">8.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%9A%84%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%EF%BC%9A"><span class="nav-number">8.1.</span> <span class="nav-text">实现栈的思路分析：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%8C%E6%88%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E7%95%8C%E8%B7%AF%EF%BC%9A"><span class="nav-number">8.2.</span> <span class="nav-text">使用栈完成表达式的计算界路：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F%EF%BC%89"><span class="nav-number">8.3.</span> <span class="nav-text">中缀表达式转换为后缀表达式（逆波兰式）:</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">9.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">10.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">10.1.</span> <span class="nav-text">八皇后问题：</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LazyC-99"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">LazyC-99</p>
  <div class="site-description" itemprop="description">Human sorrows and joys are not interlinked, I just think they are noisy.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xhenlDLTk5" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LazyC-99"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fab fa-blogger"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LazyC-99</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">109k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:39</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
