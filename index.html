<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Human sorrows and joys are not interlinked, I just think they are noisy.">
<meta property="og:type" content="website">
<meta property="og:title" content="LazyC-99">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="LazyC-99">
<meta property="og:description" content="Human sorrows and joys are not interlinked, I just think they are noisy.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LazyC-99">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>LazyC-99</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1754dd488b86cf701e1f9cbc3e330b03";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LazyC-99</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="LazyC-99">
      <meta itemprop="description" content="Human sorrows and joys are not interlinked, I just think they are noisy.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LazyC-99">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ/" class="post-title-link" itemprop="url">消息队列MQ</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-06 15:50:02 / 修改时间：18:19:27" itemprop="dateCreated datePublished" datetime="2023-02-06T15:50:02+08:00">2023-02-06</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h1><blockquote>
<p> MQ是消息中间件，是一种在分布式系统中应用程序借以传递消息的媒介，常用的有ActiveMQ，RabbitMQ(erlang)，kafka。</p>
<p>使用场景:  异步处理、应用解耦、流量控制 </p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/02/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/14/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="LazyC-99">
      <meta itemprop="description" content="Human sorrows and joys are not interlinked, I just think they are noisy.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LazyC-99">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/14/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">区块链学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-14 11:42:51 / 修改时间：11:45:01" itemprop="dateCreated datePublished" datetime="2022-11-14T11:42:51+08:00">2022-11-14</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>172</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以太坊、Hyperledger Fabric 和 Corda 的对比</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/640" alt="img"></p>
<ol>
<li>Corda 的用例来自于金融服务行业，这也是 Corda 可见的主要应用领域。</li>
<li>Fabric 设计提供一种模块化、可扩展的架构，可用于从银行、医疗保健到供应链等各个行业。以太坊表现出完全独立于任何特定的应用领域。</li>
<li>与 Fabric 相比，以太坊并未突出模块化，而重在为各种交易和应用提供一个通用平台。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/08/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="LazyC-99">
      <meta itemprop="description" content="Human sorrows and joys are not interlinked, I just think they are noisy.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LazyC-99">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/08/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="post-title-link" itemprop="url">JVM虚拟机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-08 15:19:52" itemprop="dateCreated datePublished" datetime="2022-08-08T15:19:52+08:00">2022-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-07 15:19:47" itemprop="dateModified" datetime="2023-02-07T15:19:47+08:00">2023-02-07</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-内存与垃圾回收篇"><a href="#1-内存与垃圾回收篇" class="headerlink" title="1: 内存与垃圾回收篇"></a>1: 内存与垃圾回收篇</h1><h2 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h2><blockquote>
<img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220903135907749.png" alt="image-20220903135907749" style="zoom:200%;" />
</blockquote>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220820205156098.png" alt="image-20220820205156098"></p>
<h3 id="JVM架构模型"><a href="#JVM架构模型" class="headerlink" title="JVM架构模型"></a>JVM架构模型</h3><ul>
<li>基于栈的指令集架构: 跨平台性、指令集小、指令多;执行性能比寄存器差</li>
<li>基于寄存器的指令集架构: </li>
</ul>
<h3 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h3><ul>
<li>启动 : Java虚拟机的启动是通过引导类加载器(bootstrap class loader)创建个初始类(initial class)来完成的</li>
<li>执行: 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟<br>机的进程。</li>
<li>退出: </li>
</ul>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><blockquote>
<p>灰色的为单独线程私有的，红色的为多个线程共享的。即:<br>每个线程: 独立包括程序计数器、栈、本地栈。<br>线程间共享: 堆、堆外内存（永久代或元空间、代码缓存）</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220906095355477.png" alt="image-20220906095355477"></p>
</blockquote>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote>
<p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法(C/C++实现的方法)的调用。</p>
</blockquote>
<ul>
<li>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</li>
</ul>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h3><ul>
<li>PC寄存器用来存储指向下一条指令的地址，</li>
<li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li>
<li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址;或者，如果是在执行native方法，则是未指定值（undefned) 。</li>
</ul>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><blockquote>
<p>Java虚拟机栈（Java virtual Machine stack)，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(stack Frame） ，对应着一次次的Java方法调用。是线程私有的</p>
<p>可以使用参数-Xss选项来设置线程的最大栈空间</p>
</blockquote>
<p><strong>内部结构</strong></p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220916220020359.png" alt="image-20220916220020359"></p>
<ul>
<li><p>局部变量表(Local Variables)</p>
<ul>
<li>定义为一个数字数组，主要用于<strong>存储方法参数</strong>和定义在方法体内的<strong>局部变量</strong></li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据交全问题</li>
<li>局部变量表所需的容量大小是在编译期确定下来的</li>
<li>局部变量表中的变量也是**重要的垃圾回收根节点(GCRoots)**，只要被局部变量表中接或间接引用的对象都不会被回收。</li>
</ul>
</li>
<li><p>操作数栈(Operand Stack)</p>
<ul>
<li>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储]间。</li>
<li>在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop).</li>
</ul>
</li>
<li><p>动态链接(Dynamic Linking)—旨向运行时常量池的方法引用)</p>
<ul>
<li>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中<strong>该栈帧所属方法的引用</strong>。为了支持当前方法的代码能够实现动态链接( Dynamic Linking) 。</li>
</ul>
</li>
<li><p>方法返回地址(Return Address)</p>
<ul>
<li>存放调用该方法的pc寄存器的值。</li>
<li>在方法退出后会返回到<strong>该方法被调用的位置</strong>。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li>
</ul>
</li>
</ul>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><blockquote>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220921154304304.png" alt="image-20220921154304304"></p>
<ol>
<li>-Xms 起始内存, -Xmx 最大内存</li>
<li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</li>
<li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。大小可调节</li>
<li>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(ThreadLocal Allocation Buffer,TLAB)。</li>
</ol>
</blockquote>
<p><strong>年轻代与老年代</strong></p>
<ul>
<li><p>各分区比例</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220923162007757.png" alt="image-20220923162007757"></p>
</li>
</ul>
<p><strong>Minor GC, Major GC, Full GC</strong></p>
<p>JVM在进行GC时，并非每次都对上面三个内存区域(新生代、老年代、方法区)一起回收的，大部分时候回收的都是指新生代。</p>
<ul>
<li><p>部分收集: 不是完整收集整个Java堆的垃圾收集。其中又分为:</p>
<ul>
<li><p>新生代收集(Minor Gc / Young GC): 只是新生代的垃圾收集</p>
</li>
<li><p>老年代收集(Major Gc / Old GC): 只是老年代的垃圾收集。<strong>很多时候Major Gc会和Full Gc混淆使用，需要具体分辨是老年代回收还是整堆回收。</strong></p>
</li>
<li><p>混合收集(Mixed GC): 收集整个新生代以及部分老年代的垃圾收集。目前,只有G1 GC会有这种行为</p>
</li>
</ul>
</li>
<li><p>整堆收集（Full GC): 收集整个java堆和方法区的垃圾收集。</p>
</li>
</ul>
<p><strong>内存分配策略</strong></p>
<ul>
<li>优先分配到Eden</li>
<li>大对象直接分配到老年代</li>
<li>动态对象年龄判断: 如果survivor区中相同年龄的所有对象大小的总和大于survivor空间的一半，可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li>
<li>空间分配担保   Xx:HandlePromotionFailure</li>
<li>标量替换: 存储在栈</li>
</ul>
<p><strong>TLAB</strong></p>
<ul>
<li>对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域。</li>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote>
<p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误: java.lang.outofMemoryError:</p>
</blockquote>
<ul>
<li>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</li>
</ul>
<p><strong>运行时常量池</strong></p>
<ul>
<li>常量池表（Constant Pool Table）是class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</li>
</ul>
<p><strong>垃圾回收</strong></p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p><strong>标记阶段</strong></p>
<ul>
<li><p>引用计数法</p>
<ul>
<li>引用计数算法(Reference Counting)比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</li>
<li>引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li>
</ul>
</li>
<li><p>可达性分析算法</p>
<ul>
<li>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效<strong>地解决在引用计数算法中循环引用的问题</strong>，防止内存泄漏的发生。</li>
<li>…..</li>
<li>由于finalize ()方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态</strong>。<ul>
<li>可触及的:从根节点开始，可以到达这个对象。</li>
<li>可复活的:对象的所有引用都被释放，但是对象有可能在finalize ( )中复活。</li>
<li>不可触及的:对象的finalize ( )被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>清除阶段</strong></p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221015131311740.png" alt="image-20221015131311740"></p>
<ul>
<li><p>标记-清除算法(Mark - Sweep)</p>
<blockquote>
<p>当堆中的有效内存空间(available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world)I，然后进行两项工作，第一项则是标记，第二项则是清除。</p>
</blockquote>
<ul>
<li>标记:Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</li>
<li>清除:Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</li>
</ul>
</li>
<li><p>复制算法(Copying)</p>
<blockquote>
<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<p>适合: 垃圾较多</p>
</blockquote>
</li>
<li><p>标记-压缩算法(Mark - Compact)</p>
<blockquote>
<p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩(Mark-Sweep-Compact)算法。</p>
</blockquote>
<ul>
<li>第一阶段和标记-清除算法一样,从根节点开始标记所有被引用对象</li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</li>
<li>清理边界外所有的空间。</li>
</ul>
</li>
</ul>
<p><strong>分代收集算法</strong></p>
<p><strong>增量收集算法</strong></p>
<ul>
<li>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</li>
<li>增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</li>
<li>但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</li>
</ul>
<p><strong>分区算法</strong></p>
<ul>
<li>分代算法将按照对象的生命周期长短划分成两个部分分区算法将整个堆空间划分成连续的不同小区间。</li>
<li>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。 </li>
</ul>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><blockquote>
<p>不同的垃圾回收器概述</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023142302706.png" alt="image-20221023142302706"></p>
<p>不同的垃圾回收器组合关系</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023142431767.png" alt="image-20221023142431767"></p>
</blockquote>
<p><strong>Serial回收器: 串行回收</strong>   使用:-XX:+UseserialGC</p>
<ul>
<li><p>serial 收集器<strong>采用复制算法</strong>、串行回收和”Stop-The-World”机制方式执行内存回收。</p>
</li>
<li><p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial Old收集器同样也采用了串行回收和”Stop The World”机制，只不过内存回收算法使用的是<strong>标记-压缩算法</strong>。</p>
</li>
<li><p>这个收集器是一个单线程的收集器，它只会使用一个CPU或一条收集线程去完成垃圾收集工作，在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束( Stop The world)</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023143724508.png" alt="image-20221023143724508"></p>
</li>
</ul>
<p><strong>ParNew回收器: 并行回收</strong> 使用:-XX:+UseSerialGC</p>
<ul>
<li><p>ParNew收集器是Serial收集器的多线程版本。1.9过时</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023144243494.png" alt="image-20221023144243494"></p>
</li>
</ul>
<p><strong>Parallel回收器: 吞吐量优先</strong> (Java8默认)</p>
<ul>
<li><p>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个<strong>可控制的吞吐量</strong>（Throughput），它也被称为吞吐量优先的垃圾收集器。</p>
</li>
<li><p>自适应调节策略也是Parallel scavenge与ParNew一个重要区别。</p>
</li>
<li><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
</li>
<li><p>Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。</p>
</li>
<li><p>Parallel old收集器采用了标记-压缩算法，但同样也是基于并行回收和”Stop-the-world”机制。</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023145102489.png" alt="image-20221023145102489"></p>
</li>
<li><p>参数配置:</p>
<ul>
<li>-XX:ParallelGCThreads : 设置年轻代并行收集器的线程数</li>
<li>-XX:MaxGCPauseMillis设置垃圾收集器最大停顿时间(即STw的时间)。单位是毫秒。(慎用)</li>
<li>-XX:GCTimeRatio 垃圾收集时间占总时间的比例(= 1 / (N ＋ 1))用于衡量吞吐量的大小。</li>
<li>-XX:+UseAdaptivesizePolicy设置Parallel scavenge收集器具有自适应调节策略</li>
</ul>
</li>
</ul>
<p>**CMS回收器: 低延迟 ** Java14 G1代替</p>
<ul>
<li><p>在JDK 1.5时期，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器</p>
</li>
<li><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。</p>
</li>
<li><p>CMS的垃圾收集算法采用标记-清除算法，并且也会”Stop-The-World”</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221023150902769.png" alt="image-20221023150902769"></p>
<p><strong>CMS整个过程分为4个主要阶段:</strong></p>
</li>
<li><p>初始标记（Initial-Mark）阶段: 这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p>
</li>
<li><p>并发标记（Concurrent-Mark）阶段: 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>
</li>
<li><p>重新标记（Remark）阶段: 为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p>
</li>
<li><p>并发清除(Concurrent-Sweep）阶段: 此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</p>
<p><strong>弊端:</strong></p>
</li>
</ul>
<ol>
<li>会产生内存碎片</li>
<li>CMS收集器对CPU资源非常敏感。</li>
<li>CMS收集器无法处理浮动垃圾</li>
</ol>
<p><strong>G1回收器(Garbage First)</strong> JDK7启用  JDK9后默认</p>
<ul>
<li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域(Region)（物理上不连续的）。使用不同的Region来表示Eden、幸存者o区，幸存者1区，老年代等。</li>
<li>G1 cc有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1跟踪各个 Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region)，所以我们给c1一个名字:垃圾优先（Garbage First） 。</li>
</ul>
<p>​    <strong>G1回收器的特点(优势)</strong></p>
<ul>
<li><p>并行与并发</p>
<ul>
<li>并行性: G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STw</li>
<li>并发性: G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
</li>
<li><p>分代收集</p>
<ul>
<li>将堆空间分为若干个区域(Region）,这些区域中包含了逻辑上的年轻代和老年代。</li>
<li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代;</li>
</ul>
</li>
<li><p>空间整和</p>
<ul>
<li>CMS: “标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</li>
<li>内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩(Mark-Compact)算法，两种算法都可以<strong>避免内存碎片</strong>。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>
</ul>
</li>
<li><p>可预测的停顿时间模型 ( 即: 软实时 soft real-time)</p>
<p>这是G1相对于CMS 的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒,</p>
<ul>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1跟踪各个 Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li>
<li>相比于CMS GC，G1未必能做到cMs在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
</li>
</ul>
<p>​    <strong>G1垃圾回收环节</strong></p>
<ul>
<li><p>年轻代GC(Young GC)</p>
</li>
<li><p>老年代并发标记过程(Concurrent Marking)</p>
</li>
<li><p>混合回收(Mixed GC)</p>
</li>
<li><p>（如果需要，单线程、独占式、高强度的Full Gc还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。)</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221024172622661.png" alt="image-20221024172622661"></p>
</li>
</ul>
<h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><ul>
<li>导出日志: -Xlogs/gc.log</li>
</ul>
<h1 id="2-字节码与类加载篇"><a href="#2-字节码与类加载篇" class="headerlink" title="2: 字节码与类加载篇"></a>2: 字节码与类加载篇</h1><h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
<th>长度</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u4</td>
<td>magic</td>
<td>魔术, 识别Class文件格式</td>
<td>4个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>副版本号(小版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>majot_version</td>
<td>主版本号(大版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>常量池计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>常量池表</td>
<td>n个字节</td>
<td>constant_pool_count-1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标识</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>父类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>接口计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>接口索引集合</td>
<td>2个字节</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>field_count</td>
<td>字段计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>字段表</td>
<td>n个字节</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>方法计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>方法表</td>
<td>n个字节</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性表</td>
<td>n个字节</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<h2 id="字节码指令集与解析"><a href="#字节码指令集与解析" class="headerlink" title="字节码指令集与解析"></a>字节码指令集与解析</h2><ul>
<li>加载与存储指令</li>
<li>算术指令</li>
<li>类型转换指令</li>
<li>对象的创建与访问指令</li>
<li>方法调用与返回指令<ul>
<li>invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java语言中<strong>最常见的方法分派方式</strong>。</li>
<li>invokeinterface指令用于<strong>调用接口方法</strong>，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。</li>
<li>invokespecial指令用于调用一些需要特殊处理的实例方法，包括<strong>实例初始化方法（构造器</strong>）、<strong>私有方法和父类方法</strong>。这些方法都是<strong>静态类型绑定</strong>的，不会在调用时进行动态派发。</li>
<li>invokestatic指令用于调用命名类中的<strong>类方法（static方法）</strong>。这是静态绑定的。</li>
<li>invokedynamic:调用动态绑定的方法，这个是JDK 1.7后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行核方法。前面4条调用指令的分派逻辑都固化在java 虚拟机内部，而<br>invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
</li>
<li>操作数栈管理指令</li>
<li>控制转移指令</li>
<li>异常处理指令</li>
<li>同步控制指令</li>
</ul>
<h2 id="类的加载过程详解"><a href="#类的加载过程详解" class="headerlink" title="类的加载过程详解"></a>类的加载过程详解</h2><blockquote>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220904152928052.png" alt="image-20220904152928052"></p>
</blockquote>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><strong>Loading(加载)</strong></p>
<p>Java类在JVM内存中加载一个快照，JVM将从字节码文件中解析出的<strong>常量池、类字段、类方法</strong>等信息存储到内存中，并在内存中构建出Java类的原型——类模板对象。</p>
<p>1．通过一个类的全限定名获取定义此类的二进制字节流<br>2．将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>3．在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
<p><strong>Linking(链接)</strong></p>
<ul>
<li><p>验证: 主要包括四种验证，文件格式验证，语义验证，字节码验证，符号引用验证。</p>
<p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20221101144858320.png" alt="image-20221101144858320"></p>
</li>
<li><p>准备: </p>
<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值</li>
<li>这里不包含用final修饰的static，因为<strong>final在编译的时候就会分配了</strong>，准备阶段会显式初始化;</li>
<li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li>
</ul>
</li>
<li><p>解析: 解析动作主要针对类或接口、字段、类方法  、接口方法、方法类型等。</p>
</li>
</ul>
<p><strong>Initialization(初始化)</strong></p>
<ul>
<li>初始化阶段就是执行类构造器方法<clinit>()的过程。</li>
<li>此方法不需定义，是javac编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态代码块中的语句</strong>合并而来。</li>
<li>主动使用&amp;被动使用 </li>
</ul>
<p><strong>Using(使用)</strong> </p>
<p><strong>Unloading(卸载)</strong></p>
<h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><blockquote>
<p>官方JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义加载器(User-Defined ClassLoader)。</p>
</blockquote>
<ul>
<li>启动类加载器（引导类加载器Bootstrap ClassLoader）<ul>
<li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li>
<li>用来加载Java的核心库, java. , javax. sun. 下的类</li>
<li>并不继承自java.lang.ClassLoader, 没有父加载器</li>
</ul>
</li>
<li>扩展类加载器 ( Extension ClassLoader )<ul>
<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li>
<li>派生于ClassLoader</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。</li>
</ul>
</li>
<li>应用程序类加载器（系统类加载器，AppclassLoader)<ul>
<li>它负责加载环境变量clsspath或系统属性java.class.path指定路径下的类库</li>
<li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载 </li>
</ul>
</li>
<li>用户自定义加载类<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄漏</li>
</ul>
</li>
</ul>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><blockquote>
<p>Java虚拟机对class文件采用的是按需加载的方式，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p>
</blockquote>
<p><strong>工作原理</strong></p>
<ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归请求最终将到达顶层的启动类加载器</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载</li>
</ol>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220906093247195.png" alt="image-20220906093247195"></p>
<p><strong>优势</strong></p>
<ul>
<li>避免类的重复加载</li>
<li>防止核心API被随意篡改</li>
</ul>
<h1 id="3-性能监控与调优篇"><a href="#3-性能监控与调优篇" class="headerlink" title="3: 性能监控与调优篇"></a>3: 性能监控与调优篇</h1><h2 id="JVM监控及诊断工具"><a href="#JVM监控及诊断工具" class="headerlink" title="JVM监控及诊断工具"></a>JVM监控及诊断工具</h2><p><strong>命令行工具</strong></p>
<ul>
<li>jps: 查看正在运行的Java进程</li>
<li>jstat: 查看JVM统计信息</li>
<li>jinfo: 实时查看和修改JVM配置参数</li>
<li>jmap: 导出内存映像文件</li>
<li>jhat: JDK自带堆分析工具</li>
<li>jstack: 追踪JVM中线程快照</li>
<li>jcmd: 多功能命令行工具</li>
<li>jstatd: 远程主机信息收集</li>
</ul>
<p><strong>GUI篇</strong></p>
<ul>
<li>jConsole</li>
<li>Visual VM</li>
<li>ecplise MAT</li>
<li>JProfiler</li>
<li>Arthas</li>
<li>Java Mission Control</li>
<li>Btrace</li>
<li>Flame Graphs</li>
</ul>
<p><strong>内存泄漏的8种情况</strong></p>
<ol>
<li>静态集合类</li>
<li>单例模式</li>
<li>内部类持有外部类</li>
<li>各种连接，如数据库连接、网络连接和IO连接等</li>
<li>变量不合理的作用域</li>
<li>改变哈希值</li>
<li>缓存泄漏</li>
<li>监听器和回调</li>
</ol>
<h2 id="JVM运行时参数"><a href="#JVM运行时参数" class="headerlink" title="JVM运行时参数"></a>JVM运行时参数</h2><p>分析GC日志</p>
<p>OOM常见场景及解决方案</p>
<p>性能优化案例</p>
<p>375/381P</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/02/Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="LazyC-99">
      <meta itemprop="description" content="Human sorrows and joys are not interlinked, I just think they are noisy.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LazyC-99">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/02/Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/" class="post-title-link" itemprop="url">Netty网络通讯</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-02 16:03:23" itemprop="dateCreated datePublished" datetime="2022-08-02T16:03:23+08:00">2022-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-31 22:11:45" itemprop="dateModified" datetime="2023-01-31T22:11:45+08:00">2023-01-31</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Netty网络通讯"><a href="#Netty网络通讯" class="headerlink" title="Netty网络通讯"></a>Netty网络通讯</h2><h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><ul>
<li><p>BIO(传统阻塞IO): 服务器实现模式为一个连接一个线程</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220802163623607.png" alt="image-20220802163623607"></p>
</li>
<li><p>NIO(同步非阻塞IO): 面向缓冲区(块)编程，服务器实现模式为一个线程处理多个请求(连接),请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理</p>
</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220802163844851.png" alt="image-20220802163844851"></p>
<ol>
<li>每个channel都会对应一个Bufer</li>
<li>Selector 对对应一个线程，一个线程对应多个channel(连接)</li>
<li>该图反应了有三个channel注册到该selector </li>
<li>程序切换到哪个channel是有事件决定的,Event是一个重要的概念</li>
<li>Selector会根据不同的事件，在各个通道上切换</li>
<li>Buffer就是一个内存块,底层是有一个数组</li>
<li>数据的读取写入是通过Buffer，BIO中要么是输入流，或者是输出流，不能双向，NIO的Buffer是可以读也可以写，需要flip()方法切换</li>
<li>channel是双向的，可以返回底层操作系统的情况，比如Linux，底层的操作系统通道就是双向的.</li>
</ol>
<h3 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区(Buffer)"></a>缓冲区(Buffer)</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Capacity</td>
<td>容量:即可以容纳的最大数据量;在缓吊区创建时被设并且不能改变</td>
</tr>
<tr>
<td>Limit</td>
<td>表示缓冲区的当前终点，不能对缓冲区超过极限的位置迸行读写操作。且极限是可修改的</td>
</tr>
<tr>
<td>Position</td>
<td>位置,下一个要被读或写的元素的索引,每次读亨缓冲区数据时都会改变改值,为下茨读写作准备</td>
</tr>
<tr>
<td>Mark</td>
<td>标记</td>
</tr>
</tbody></table>
<p>NIO还提供了MappedByteBuffer，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由NIO来完成</p>
<h3 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h3><ol>
<li><p>NIO的通道类似于流，但有些区别如下:</p>
<ul>
<li><p>通道可以同时进行读写，而流只能读或者只能写·通道可以实现异步读写数据</p>
</li>
<li><p>通道可以从缓冲读数据，也可以写数据到缓冲</p>
</li>
</ul>
</li>
<li><p>Channel在NIO中是一个接口</p>
</li>
<li><p>常用Channel类有: FileChannel, DatagramChannel, ServerSocketChannel, SocketChannnel</p>
</li>
<li><p>FileChannel用于文件数据读写, DatagramChannel 用于UDP的数据读写, ServerSocketChannel, SocketChannnel用于TCP的数据读写</p>
</li>
</ol>
<ul>
<li><p>文件读写</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220805163842676.png" alt="image-20220805163842676"></p>
</li>
<li><p>文件复制</p>
</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20220805163939115.png" alt="image-20220805163939115"></p>
<ol start="5">
<li>NIO还支持通过多个Buffer(即 Buffer数组)完成读写操作，即Scattering 和 Gathering<ul>
<li>Scattering : 将数据写入到buffer时，可以采用buffer数组，依次写入</li>
<li>Gathering : 从buffer读取数据时，可以采用buffer数组，依次读</li>
</ul>
</li>
</ol>
<h3 id="选择器-Selector"><a href="#选择器-Selector" class="headerlink" title="选择器(Selector)"></a>选择器(Selector)</h3><ol>
<li>Selector能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。实现一个单线程管理多个通道，也就是管理多个连接和请求。</li>
<li>只有在 连接/通道 真正有读写事件发生时，才会进行读写，大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程, 避免了多线程之间的上下文切换导致的开销</li>
<li></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/19/blog-images-master/README.en/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="LazyC-99">
      <meta itemprop="description" content="Human sorrows and joys are not interlinked, I just think they are noisy.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LazyC-99">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/19/blog-images-master/README.en/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-19 20:08:41" itemprop="dateCreated datePublished" datetime="2022-05-19T20:08:41+08:00">2022-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-11 08:51:29" itemprop="dateModified" datetime="2021-09-11T08:51:29+08:00">2021-09-11</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>608</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="BlogImages"><a href="#BlogImages" class="headerlink" title="BlogImages"></a>BlogImages</h1><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>{<strong>When you’re done, you can delete the content in this README and update the file with details for others getting started with your repository</strong>}</p>
<h4 id="Software-Architecture"><a href="#Software-Architecture" class="headerlink" title="Software Architecture"></a>Software Architecture</h4><p>Software architecture description</p>
<h4 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h4><ol>
<li> xxxx</li>
<li> xxxx</li>
<li> xxxx</li>
</ol>
<h4 id="Instructions"><a href="#Instructions" class="headerlink" title="Instructions"></a>Instructions</h4><ol>
<li> xxxx</li>
<li> xxxx</li>
<li> xxxx</li>
</ol>
<h4 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h4><ol>
<li> Fork the repository</li>
<li> Create Feat_xxx branch</li>
<li> Commit your code</li>
<li> Create Pull Request</li>
</ol>
<h4 id="Gitee-Feature"><a href="#Gitee-Feature" class="headerlink" title="Gitee Feature"></a>Gitee Feature</h4><ol>
<li> You can use Readme_XXX.md to support different languages, such as Readme_en.md, Readme_zh.md</li>
<li> Gitee blog <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmdpdGVlLmNvbS8=">blog.gitee.com<i class="fa fa-external-link-alt"></i></span></li>
<li> Explore open source project <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZXhwbG9yZQ==">https://gitee.com/explore<i class="fa fa-external-link-alt"></i></span></li>
<li> The most valuable open source project <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZ3Zw">GVP<i class="fa fa-external-link-alt"></i></span></li>
<li> The manual of Gitee <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaGVscA==">https://gitee.com/help<i class="fa fa-external-link-alt"></i></span></li>
<li> The most popular members  <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZ2l0ZWUtc3RhcnMv">https://gitee.com/gitee-stars/<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/19/blog-images-master/README/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="LazyC-99">
      <meta itemprop="description" content="Human sorrows and joys are not interlinked, I just think they are noisy.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LazyC-99">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/19/blog-images-master/README/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-19 20:08:41" itemprop="dateCreated datePublished" datetime="2022-05-19T20:08:41+08:00">2022-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-11 08:51:29" itemprop="dateModified" datetime="2021-09-11T08:51:29+08:00">2021-09-11</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>507</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="BlogImages"><a href="#BlogImages" class="headerlink" title="BlogImages"></a>BlogImages</h1><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>{<strong>以下是 Gitee 平台说明，您可以替换此简介</strong><br>Gitee 是 OSCHINA 推出的基于 Git 的代码托管平台（同时支持 SVN）。专为开发者提供稳定、高效、安全的云端软件开发协作平台<br>无论是个人、团队、或是企业，都能够用 Gitee 实现代码托管、项目管理、协作开发。企业项目请看 <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZW50ZXJwcmlzZXM=">https://gitee.com/enterprises<i class="fa fa-external-link-alt"></i></span>}</p>
<h4 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h4><p>软件架构说明</p>
<h4 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h4><ol>
<li> xxxx</li>
<li> xxxx</li>
<li> xxxx</li>
</ol>
<h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><ol>
<li> xxxx</li>
<li> xxxx</li>
<li> xxxx</li>
</ol>
<h4 id="参与贡献"><a href="#参与贡献" class="headerlink" title="参与贡献"></a>参与贡献</h4><ol>
<li> Fork 本仓库</li>
<li> 新建 Feat_xxx 分支</li>
<li> 提交代码</li>
<li> 新建 Pull Request</li>
</ol>
<h4 id="特技"><a href="#特技" class="headerlink" title="特技"></a>特技</h4><ol>
<li> 使用 Readme_XXX.md 来支持不同的语言，例如 Readme_en.md, Readme_zh.md</li>
<li> Gitee 官方博客 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmdpdGVlLmNvbS8=">blog.gitee.com<i class="fa fa-external-link-alt"></i></span></li>
<li> 你可以 <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZXhwbG9yZQ==">https://gitee.com/explore<i class="fa fa-external-link-alt"></i></span> 这个地址来了解 Gitee 上的优秀开源项目</li>
<li> <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZ3Zw">GVP<i class="fa fa-external-link-alt"></i></span> 全称是 Gitee 最有价值开源项目，是综合评定出的优秀开源项目</li>
<li> Gitee 官方提供的使用手册 <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaGVscA==">https://gitee.com/help<i class="fa fa-external-link-alt"></i></span></li>
<li> Gitee 封面人物是一档用来展示 Gitee 会员风采的栏目 <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZ2l0ZWUtc3RhcnMv">https://gitee.com/gitee-stars/<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/08/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="LazyC-99">
      <meta itemprop="description" content="Human sorrows and joys are not interlinked, I just think they are noisy.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LazyC-99">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/08/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">JUC并发编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-08 10:52:44" itemprop="dateCreated datePublished" datetime="2022-05-08T10:52:44+08:00">2022-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-31 22:12:29" itemprop="dateModified" datetime="2023-01-31T22:12:29+08:00">2023-01-31</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h1><ol>
<li><p>继承Thread类    重写run()方法    启动: <code>new MyThread().start()</code></p>
</li>
<li><p>实现Runnable接口    重写run()方法     启动: <code>new Thread(new MyThread()).start()</code></p>
</li>
<li><p>实现Callable接口     重写call()方法    启动: <code>new Thread( new FutureTask( new MyThread() ) )</code></p>
</li>
<li><p>使用线程池 new ThreadPoolExecutor() ( 主要使用 )</p>
<p> <strong>7大核心参数</strong></p>
<ul>
<li>corePoolSize:核心池大小</li>
<li>maximumPoolSize:最大线程数</li>
<li>keepAliveTime:线程没有任务时最多保持的时间</li>
<li>keepAliveTime:超时时间单位</li>
<li>BlockingQueue<Runnable>: 阻塞队列</li>
<li>ThreadFactory: 线程工厂,创建线程</li>
<li>RejectedExecutionHandler: 拒绝策略 4种</li>
</ul>
<p> <strong>具体使用</strong></p>
<ul>
<li><p>一池N线程: Executors.newFixedThreadPool()</p>
</li>
<li><p>一池一线程: Executors.newSingleThreadExecutor()</p>
</li>
<li><p>根据需求扩容: Executors.newCachedThreadPool()</p>
</li>
</ul>
<p> <strong>拒绝策略(超过最大线程和阻塞队列)：</strong></p>
<ul>
<li><p>(默认)ThreadPoolExecutor.AbortPolicy(): 直接抛出RejectedExecutionException异常阻止系统正常运行</p>
</li>
<li><p>ThreadPoolExecutor.CallerRunsPolicy(): “调用者运行“一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量.</p>
</li>
<li><p>ThreadPoolExecutor.DiscardOldestPolicy(): 抛弃队列中等待最久的任务，然后把当前任务加人队列中尝试再次提交当前任务。</p>
</li>
<li><p>ThreadPoolExecutor.DiscardPolicy(): 该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。</p>
</li>
</ul>
<p> <strong>自定义线程池:</strong> </p>
<p> ​    阿里巴巴开发手册强制线程池不允许使用Executors去创建</p>
<ul>
<li><p>FixedThreadPool 和 SingleThreadPool:</p>
<p>允许请求队列长度为Integer.MAX_VALUE,可能堆积大量的请求</p>
</li>
<li><p>CachedThreadPool和 ScheduledThreadPool</p>
<p>允许创建线程数量为Integer.MAX_VALUE,可能堆积大量的线程</p>
</li>
</ul>
</li>
</ol>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><ul>
<li><p>FutureTask缺点</p>
<ul>
<li>get()方法在Future计算完成之前会一直阻塞</li>
<li>轮询方式isDone(), 消耗cpu资源</li>
</ul>
</li>
<li><p>CompletableFuture优化</p>
<ul>
<li><p>CompletableFuture提供了一种观察者模式类似的机制，可以让任务执待完成后通知监听的一方。</p>
</li>
<li><p>CompletableFuture.runAsync(<Runnable>): 无返回值</p>
</li>
<li><p>CompletableFuture.supplyAsync(<Runnable>): 有返回值</p>
</li>
<li><p>whenComplete(): 完成后的感知</p>
</li>
<li><p>exceptionally():</p>
</li>
<li><p>handle(): 完成后的处理</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>thenCombie(): 组合两个future,获取两个future的返回结果，有返回值</p>
</li>
<li><p>thenAcceptBoth(): 组合两个future，获取两个future任务的返回结果，然后处理任务，没有返回值。</p>
</li>
<li><p>runAfterBoth(): 组合两个future，不获取future的结果，两个future处理完任务后，处理该任务。</p>
</li>
</ul>
<ul>
<li><p>applyIToEither:两个任务有一个执行完成，获取返回值，处理任务并有新的返回值。</p>
</li>
<li><p>acceptEither:两个任务有一个执行完成，获取返回值，处理任务，没有新的返回值。</p>
</li>
<li><p>runAfterEither:两个任务有一个执行完成，不获取future的结果，处理任务，也没有返回值。</p>
</li>
</ul>
<ul>
<li>allof(): 组合多任务</li>
</ul>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>Thread类中:</p>
<ul>
<li>start()∶启动当前线程;调用当前线程的run()</li>
</ul>
<ul>
<li>run()∶通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</li>
</ul>
<ul>
<li><p>yield()∶释放当前cpu的执行权,礼让线程，暂停线程 直接进入就绪状态 不是阻塞状态</p>
</li>
<li><p>join():在线程中调用线程b的join(),此时线程a就进入阻塞状态，直到线程a完全执行完以后，线程a结束阻塞状态。</p>
</li>
<li><p>sleep(long millitime):让当前线程睡眠指定的millitime毫秒, 当前线程是阻塞状态。</p>
</li>
<li><p>stop(): 已过时。当执行此方法时，强制结束当前线程。</p>
</li>
</ul>
<ul>
<li>setPriority(int p): 设置线程优先级</li>
<li>setDaemon(true): 把一个用户线程编程守护线程</li>
<li>getName()∶获取当前线程的名字</li>
<li>currentThread()∶静态方法，返回执行当前代码的线程</li>
<li>isAlive()∶判断当前线程是否存活</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li>新建: 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li>
<li>就绪: 处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源</li>
<li>运行: 当就绪的线程被调度并获得CPU资源时,便进入运行状态，run()方法定义了线程的操作和功能</li>
<li>阻塞: 在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU并临时中止自己的执行，进入阻塞状态</li>
<li>死亡: 线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/202205081748754.png" alt="image-20220508174831651"></p>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><ul>
<li>wait() || await(): 执行此方法,当前线程就会进入阻塞状态,并释放锁</li>
<li>notify() || singal(): 执行此方法,就会唤醒被wait()的一个线程.如果有多个,就唤醒优先级较高的那个</li>
<li>notifyAll() || singalAll(): 执行此方法,就会唤醒所有被wait()的线程</li>
</ul>
<p>说明:</p>
<ol>
<li>wait(),notify(),notifyAll()三个方法必须使用在同步代码块或同步方法中</li>
<li>wait(),notify(),notifyAll()三个方法的调用者必须是同步代码块或同步方法中的监视器</li>
</ol>
<p>虚假唤醒:</p>
<p>多个线程通信时, wait() 应该放在while循环里, 不然可能出现虚假唤醒(因为wait()在哪里睡哪里醒)</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>当执行monitor enterl时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。</p>
<p>在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。</p>
<p>当执行monitor exit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</p>
<table>
<thead>
<tr>
<th>ObjectMonitor.hpp关键属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>_owner</td>
<td>指向持有ObjectMonitor对象的线程</td>
</tr>
<tr>
<td>_WaitSet</td>
<td>存放处于wait状态的线程队列</td>
</tr>
<tr>
<td>_EntryList</td>
<td>存放处于等待锁block状态的线程队列</td>
</tr>
<tr>
<td>_recursions</td>
<td>锁的重入次数</td>
</tr>
<tr>
<td>_count</td>
<td>用来记录该线程获取锁的次数</td>
</tr>
</tbody></table>
<ul>
<li><p>公平锁和非公平锁</p>
<ul>
<li><p>非公平锁: 抢占式, 效率高, 能更充分的利用CPU的时间片，尽量减少CP0空闲状态时间。</p>
</li>
<li><p>公平锁: 非抢占式, 效率低</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);<span class="comment">//默认false  读写锁:new ReentrantReadWriteLock</span></span><br><span class="line"><span class="keyword">try</span> &#123;		<span class="comment">//lock需要手动启动和结束</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    ....<span class="comment">//同步代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>可重入锁(递归锁)</p>
<p>指在<strong>同一个线程</strong>在外层方法获取锁的时候，再进入该线程的内层方法会<strong>自动获取锁</strong>(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。避免死锁</p>
<p>加锁和解锁次数要一致, 否则会导致第二个线程无法获取到锁, 一直在等待</p>
</li>
<li><p>死锁及排查</p>
<ol>
<li><code>jps -l </code>类似linux `ps -ef``</li>
<li><code>jstack [id]</code> jvm自带堆栈跟踪工具</li>
</ol>
</li>
<li><p>读锁(独占锁) / 写锁(共享锁)</p>
</li>
<li><p>自旋锁SpinLock</p>
</li>
</ul>
<h2 id="线程中断LockSupport"><a href="#线程中断LockSupport" class="headerlink" title="线程中断LockSupport"></a>线程中断LockSupport</h2><p><strong>中断机制</strong></p>
<ul>
<li>一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止，Thread.stop,Thread.suspend, Thread.resume都已经被废弃了。</li>
<li>在Java中没有办法立即停止一条线程，然而停止线程却尤为重要，如取消一个耗时操作因此，Java提供了一种用于停止线程的协商机制—中断，也即<strong>中断标识协商机制</strong>。</li>
<li>若要中断一个线程，你需要手动调用该线程的interrupt方法，该方法也仅仅是将线程对象的中断标识设成true;</li>
</ul>
<p><strong>中断三大方法</strong></p>
<ul>
<li>void interrupt() : 实例方法interrupt()仅仅是设置线程的中断状态为true，发起一个协商而不会立刻停止线程</li>
<li>static boolean interrupted() : 判断线程是否被中断并清除当前中断状态。</li>
<li>bloolean isInterrupted() : 判断当前线程是否被中断（通过检查中断标志位)</li>
</ul>
<p><strong>LockSupport</strong></p>
<ul>
<li>park(): permit许可证默认没有不能放行，所以一开始调park()方法当前线程就会阻塞，直到别的线程给当前线程的发放permit，park方法才会被唤醒。</li>
<li>unpark(): 调用unpark(thread)方法后，就会将thread线程的许可证permit发放，会自动唤醒park线程，即之前阻塞中的LockSupport park()方法会立即返回.</li>
</ul>
<h1 id="JMM与volatile"><a href="#JMM与volatile" class="headerlink" title="JMM与volatile"></a>JMM与volatile</h1><blockquote>
<p>JMM的关键技术点都是围绕多线程的<strong>原子性</strong>、<strong>可见性</strong>和<strong>有序性</strong>展开的</p>
<ol>
<li>通过JMM来实现线程和主内存之间的抽象关系。</li>
<li>屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。</li>
</ol>
</blockquote>
<ul>
<li>可见性</li>
<li>原子性</li>
<li>有序性 </li>
</ul>
<p><strong>happens-before</strong></p>
<ol>
<li>次序规则: 一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作;</li>
<li>锁定规则: 一个unLock操作先行发生于后面((这里的“后面”是指时间上的先后))对同一个锁的lock操作;</li>
<li>volatile变量规则: 对一个volatile变量的写操作先行发生于后面对这个变量的读操作，<strong>前面的写对后面的读是可见的</strong>，这里的“后面”同样是指时间上的先后。</li>
<li>传递规则: 如果操作A先行发生于操作B，而操作B又先行发生于操作c，则可以得出操作A先行发生于操作C;</li>
<li>线程启动规则(Thread Start Rule): Thread对象的start()方法先行发生于此线程的每一个动作</li>
<li>线程中断规则(Thread lnterruption Rule): 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生;</li>
<li>线程终止规则(Thread Termination Rule): 线程中的所有操作都先行发生于对此线程的终止检 测，我们可以通过isAlive()等手段检测线程是否已经终止执行。</li>
<li>对象终结规则(Finalizer Rule): 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始  </li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote>
<p>volatile关键字的作用主要有如下两个：</p>
<ol>
<li>线程的可见性：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</li>
<li> 顺序一致性：禁止指令重排序</li>
</ol>
</blockquote>
<ul>
<li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中。</li>
<li>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量</li>
</ul>
<h2 id="内存屏障–-保证可见性"><a href="#内存屏障–-保证可见性" class="headerlink" title="内存屏障–(保证可见性)"></a><strong>内存屏障–(保证可见性)</strong></h2><blockquote>
<p> 内存屏障（也称内存栅栏，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性(禁重排)，但volatile无法保证原子性。</p>
<ul>
<li>内存屏障之前的所有写操作都要回写到主内存</li>
<li>内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。</li>
<li>因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。</li>
<li>对一个volatile变量的写,先行发生于任意后续对这个volatile变量的读，也叫写后读。</li>
</ul>
</blockquote>
<p>粗分2种:</p>
<ul>
<li>读屏障(Load Barrier): 在读指令之前插入读屏障，让工作内存或CPU高速缓存当中的缓存数据失效，重新回到主内存中获取最新数据</li>
<li>写屏障(Store Barrier): 在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中</li>
</ul>
<p>细分4种(cpp方法)</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad</td>
<td>Load1; LoadLoad; Load2</td>
<td>保证load1的读取操作在load2及后续读取操作之前执行</td>
</tr>
<tr>
<td>StoreStore</td>
<td>Store1; StoreStore; Store2</td>
<td>在store2及其后的写操作执行前，保证store1的写操作已刷新到主内存</td>
</tr>
<tr>
<td>LoadStore</td>
<td>Load1; LoadStore; Store2</td>
<td>在stroe2及其后的写操作执行前，保证load1的读操作已读取结束</td>
</tr>
<tr>
<td>StoreLoad</td>
<td>Store1; StoreLoad; Load2</td>
<td>保证store1的写操作已刷新到主内存之后，load2及其后的读操作才能执行</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>在每个volatile 读操作的后面插入一个LoadLoad屏障</td>
<td>禁止处理器把上面的volatile读与下面的普通读重排序。</td>
</tr>
<tr>
<td>在每个volatile 读操作的后面插入一个LoadStore屏障</td>
<td>禁止处理器把上面的volatilei读与下面的普通写重排序。</td>
</tr>
</tbody></table>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221126115150351.png" alt="image-20221126115150351"></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>在每个volatile 写操作的前面插入一个 StoreStore屏障</td>
<td>可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中</td>
</tr>
<tr>
<td>在每个volatile 写操作的后面插入一个 StoreLoad 屏障</td>
<td>作用是避免volatile写与后面可能有的volatile读/写操作重排序</td>
</tr>
</tbody></table>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221126115451821.png" alt="image-20221126115451821"></p>
<h2 id="读写过程–-没有原子性"><a href="#读写过程–-没有原子性" class="headerlink" title="读写过程–(没有原子性)"></a>读写过程–(没有原子性)</h2><p>Java内存模型中定义的8种每个线程自己的工作内存与主物理内存之间的原子操作:</p>
<p>read(读取)→load(加载)→use(使用)→assign(购值)→store(存储)→write(写入)→lock(锁定)→unlock(解锁)</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221126154850903.png" alt="image-20221126154850903"></p>
<p>不具备原子性: 如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，</p>
<p>在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性: </p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
<p><strong>结论: volatile不适合参与到依赖到当前值计算的运算 如: i++</strong></p>
<h2 id="指令禁重排–-保证一致性"><a href="#指令禁重排–-保证一致性" class="headerlink" title="指令禁重排–(保证一致性)"></a>指令禁重排–(保证一致性)</h2><blockquote>
<p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序不存在数据依赖关系，可以重排序;</p>
<p>存在数据依赖关系，禁止重排序—–<strong>通过内存屏障实现</strong></p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221125153711494.png" alt="image-20221125153711494"></p>
</blockquote>
<h2 id="volatile使用场景"><a href="#volatile使用场景" class="headerlink" title="volatile使用场景"></a>volatile使用场景</h2><ul>
<li>单一赋值可以，but含复合运算赋值不可以(i++之类)</li>
<li>状态标志，判断业务是否结束</li>
<li>开销较低的读，写锁策略</li>
<li>DCL双端锁的发布</li>
</ul>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><blockquote>
<p>CAS的全称为Compare-And-Swap，它是一条CPU并发原语。</p>
<p>它包含三个操作数——内存位置、预期原值及更新值。</p>
<p>使用Atomicxxx(原子操作类)实现</p>
</blockquote>
<ul>
<li><p>执行CAS操作的时候，将内存位置的值与预期原值比较;</p>
<ul>
<li>如果相匹配，那么处理器会自动将该位置值更新为新值，</li>
<li>如果不匹配，处理器不做任何操作，多个线程同时执行CAS操作只有一个会成功。</li>
<li>当它重来重试的这种行为成为—-<strong>自旋</strong>! !</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221127093626568.png" alt="image-20221127093626568"></p>
</li>
<li><p>CAS是JDK提供的<strong>非阻塞原子性</strong>操作，它通过硬件保证了比较-更新的原子性。</p>
</li>
<li><p>CAS是一条CPU的原子指令(cmpxchg指令），不会造成所谓的数据不一致问题</p>
</li>
<li><p>执行cmpxchg指令的时候，会判断当前系统是否为多核系统，如果是就给<strong>总线加锁</strong>，只有一个线程会对总线加锁成功，加锁成功之后会执行cas操作</p>
</li>
<li><p>CAS的原子性实际上是CPU实现独占的，比起synchronized重量级锁，排他时间要短很多</p>
</li>
</ul>
<h2 id="UnSafe类"><a href="#UnSafe类" class="headerlink" title="UnSafe类"></a>UnSafe类</h2><ul>
<li>UnSage类是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问</li>
<li>Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。</li>
<li>Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存</li>
<li>Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务</li>
<li>变量value用volatile修饰，保证了多线程之间的内存可见性。</li>
</ul>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><blockquote>
<p>AtomicReference<Thread>实现</p>
</blockquote>
<ul>
<li>CAS是实现自旋锁的基础，自旋翻译就是循环，一般是用一个无限循环实现。</li>
<li>这样一来，一个无限循环中，执行一个CAS操作，<ul>
<li>当操作成功返回true 时，循环结束;</li>
<li>当返回false时，接着执行循环，继续尝试CAS操作，直到返回true。</li>
</ul>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>循环时间长，开销很大</li>
<li>ABA问题 —-AtomicStampedReference(V initialRef, int initialStamp)解决</li>
</ul>
<h2 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h2><ul>
<li><p>基本类型</p>
<ul>
<li>AtomicInteger</li>
<li>AtomicBoolean</li>
<li>AtomicLong</li>
</ul>
</li>
<li><p>数组类型</p>
<ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
</li>
<li><p>引用类型</p>
<ul>
<li>AtomicReference</li>
<li>AtomicStampedReference</li>
<li>AtomicMarkableReference</li>
</ul>
</li>
<li><p>对象的属性修改原子类</p>
<ul>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdater</li>
<li>AtomicReferenceFieldUpdater</li>
</ul>
</li>
<li><p>原子操作增强类—减少乐观锁重试次数</p>
<ul>
<li>DoubleAccumulator</li>
<li>DoubleAdder</li>
<li>LongAccumulator</li>
<li>LongAdder—-striped64实现</li>
</ul>
</li>
</ul>
<h2 id="Striped64"><a href="#Striped64" class="headerlink" title="Striped64"></a>Striped64</h2><blockquote>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221127175158949.png" alt="image-20221127175158949"></p>
</blockquote>
<ul>
<li>LongAdder的基本思路就是分散热点，将value值分散到一个Cell数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。</li>
<li>sum()会将所有Cell数组中的value和base累加作为返回值，核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去从而降级更新热点。</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221127175106184.png" alt="image-20221127175106184"></p>
<p><strong>具体实现</strong></p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221128095958945.png" alt="image-20221128095958945"></p>
<ol>
<li>如果Cells表为空，尝试用CAS更新base字段，成功则退出;</li>
<li>如果Cells表为空，CAS更新base字段失败，出现竞争，uncontended为true，调用longAccumulate;</li>
<li>如果Cells表非空，但当前线程映射的槽为空，uncontended为true，调用longAccumulate;</li>
<li>如果Cells表非空，且前线程映射的槽非空，CAS更新Cell的值，成功则返回，否则，说明槽位不够用, uncontended设为false，调用<strong>longAccumulate</strong>,</li>
</ol>
<p><strong>longAccumulate()</strong></p>
<blockquote>
<p>striped64中一些变量或者方法的定义:</p>
<ul>
<li>base: 类似于AtomicLong中全局的value值。在没有竞争情况下数据直接累加到base上，或者cells扩容时，也需要将数据写入到base上</li>
<li>collide: 表示扩容意向，false一定不会扩容，true可能会扩容。</li>
<li>cellsBusy: 初始化cells或者扩容cells需要获取锁，0:表示无锁状态 1:表示其他线程已经持有了锁<br>心</li>
<li>casCellsBusy(): 通过CAS操作修改cellsBusy的值，CAS成功代表获取锁，返回true</li>
<li>NCPU: 当前计算机CPU数量，Cell数组扩容时会使用到</li>
<li>getProbe(): 获取当前线程的hash值</li>
<li>advanceProbe(): 重置当前线程的hash值</li>
</ul>
</blockquote>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221128131235040.png" alt="image-20221128131235040"></p>
<ul>
<li><p>CASE1: Cell[ ] 数组已经初始化</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221128133205437.png" alt="image-20221128133205437"></p>
<p>​    <img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221128133709562.png" alt="image-20221128133709562">    </p>
</li>
<li><p>CASE2: Cell[ ] 数组未初始化(首次新建)</p>
</li>
<li><p>CASE3: Cell[ ] 数组正在初始化中</p>
</li>
</ul>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><blockquote>
<p>ThreadLocal提供线程局部变量。这些变量与正常的变量不同，因为每一个线程在访ThreadLocal实例的时候（通过其getaset方法）都有自己的、独立初始化的变量副本。</p>
<p>ThreadLocal实例通常是类中的私有静态字段，使用它的目的是希望将状态（例如，用户ID或事务ID）与线程关联起来。</p>
</blockquote>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221128174850836.png" alt="image-20221128174850836"></p>
<p>当为threadLocal变量赋值，实际上就是以当前threadLocal实例为key，值为value 的Entry往threadLocalMap中存放</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221128174757027.png" alt="image-20221128174757027"></p>
<p><span style="color:red">JVM内部维护了一个线程版的Map&lt;ThreadLocal,Value&gt;</span>(通过ThreadLocal对象的set方法，结果把ThreadLocal对象自己当做key,放进了ThreadLoalMap中),<span style="color:red">每个线程要用到这个T的时候，用当前的线程去Map里面获取</span>，通过这样让每个线程都拥有了自己独立的变量，人手一份，竞争条件被彻底消除，在并发模式下是绝对安全的变量。</p>
<p><strong>弱引用</strong></p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221129120358011.png" alt="image-20221129120358011"></p>
<p>ThreadLocal是一个壳子，真正的存储结构是ThreadLocal里有ThreadLocalMap这么个内部类，每个Thread对象维护着一个ThreadLocalMlap的引用，ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><ul>
<li>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的ralue，如果当前线程再迟迟不结束的话(比如正好用在线程池)，这些key为null的Entry的value就会一直存在一条强引用链</li>
<li>虽然弱引用，保证了key指向的ThreadLocal对象能被及时回收，但是v指向的value对象是需要ThreadLocalMap调用get、setlt发现ke y’s u时t才会去回收整个entry、value，因此弱引用不能100%保证内存不泄露。我们要在不使用某个ThreadLocal对象后，手动调用remove()方法来删除它</li>
<li>set、 get方法会去检查所有键为null的Entry对象设置、获取方法会去检查所有键为空的条目对象,并调用expungestaleEntry清除value</li>
</ul>
<h1 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h1><blockquote>
<p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分:对象头(Header)、实例数据（ Instance Data）和对齐填充（Padding) 。</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221129135628729.png" alt="image-20221129135628729"></p>
</blockquote>
<h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221129140750165.png" alt="image-20221129140750165"></p>
<p><strong>对象标记 Mark Word</strong></p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221129142524944.png" alt="image"></p>
<p><strong>类元信息 (类型指针)</strong></p>
<h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>保证8个字节的倍数</p>
<h1 id="Synchronized与锁升级"><a href="#Synchronized与锁升级" class="headerlink" title="Synchronized与锁升级"></a>Synchronized与锁升级</h1><blockquote>
<p><strong>Monitor与java对象以及线程关联</strong></p>
<ol>
<li>如果一个java对象被某个线程锁住，则该java对象的Mark Word字段中LockWord指向monitor的起始地址</li>
<li>Monitor的Owner字段会存放拥有相关联对象锁的线程id</li>
</ol>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221129150316241.png" alt="imagine"></p>
</blockquote>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/2575225-20220426174452302-1618302519.png" alt="img"></p>
<ul>
<li>偏向锁: MarkWord存储的是偏向的线程ID;</li>
<li>轻量锁: MarkWord存储的是指向线程栈中Lock Record的指针;</li>
<li>重量锁: MarkWord存储的是指向堆中的monitor对象的指针;</li>
</ul>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗、和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争,会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞,提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程,使用自旋会消耗CPU</td>
<td>追求响应时间<br/>同步块执行速度非常快追求吞吐量</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋,不会消耗CPU</td>
<td>线程阻塞,响应时间缓慢</td>
<td>同步块执行速度较长</td>
</tr>
</tbody></table>
<h2 id="偏向锁-单线程竞争"><a href="#偏向锁-单线程竞争" class="headerlink" title="偏向锁: 单线程竞争"></a>偏向锁: 单线程竞争</h2><blockquote>
<p>偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。</p>
<p>也即偏向锁在资源没有竞争情况下消除了同步语句，懒的连CAS操作都不做了，直接提高程序性能</p>
</blockquote>
<ul>
<li>当线程A第一次竞争到锁时，通过操作修改Mark Word中的偏向线程ID、偏向模式。如果不存在其他线程竞争，那么持有偏向锁的线程将永远不需要进行同步。</li>
<li>当一段同步代码一直被同一个线程多次访问，由于只有一个线程那么该线程在后续访问时便会自动获得锁</li>
</ul>
<p><strong>使用</strong></p>
<p>偏向锁1.6后默认开启, 4秒延迟, 关闭后直接进入轻量级锁</p>
<p><strong>偏向锁的撤销</strong></p>
<ul>
<li>偏向锁使用一种等到竞争出现才释放锁的机制，只有当其他线程竞争锁时，持有偏向锁的原来线程才会被撤销。</li>
<li>撤销需要等待全局安全点(该时间点上没有字节码正在执行)，同时检查持有偏向锁的线程是否还在执行</li>
</ul>
<p><strong>升级</strong></p>
<ul>
<li>第一个线程正在执行synchronized方法(处于同步块)，它还没有执行完，其它线程来抢夺，该偏向锁会被取消掉并出现锁升级。此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁.</li>
<li>第一个线程执行完成synchronized方法(退出同步块)，则将对象头设置成无锁状态并撤销偏向锁，重新偏向。</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221130145126162.png" alt="image-20221130145126162"></p>
<h2 id="轻量级锁-多线程竞争"><a href="#轻量级锁-多线程竞争" class="headerlink" title="轻量级锁: 多线程竞争"></a>轻量级锁: 多线程竞争</h2><blockquote>
<p>任意时刻最多只有一个线程竞争，即不存在锁竞争太过激烈的情况，也就没有线程阻塞。</p>
</blockquote>
<p><strong>轻量级锁的加锁</strong></p>
<ul>
<li>JVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，官方称为Displaced Mark Word。</li>
<li>若一个线程获得锁时发现是轻量级锁，会把锁的MarkWord复制到自己的Displaced Mark Word里面。然后线程尝试用CAS将锁的MarkWord替换为指向锁记录的指针。<ul>
<li>如果成功，当前线程获得锁，</li>
<li>如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。</li>
</ul>
</li>
<li>自旋CAS:不断尝试去获取锁，能不升级就不往上捅，尽量不要阻塞</li>
</ul>
<p><strong>轻量级锁的释放</strong></p>
<ul>
<li>在释放锁时，当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。<ul>
<li>如果没有发生竞争，那么这个复制的操作会成功。</li>
<li>如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻寒的线程。</li>
</ul>
</li>
</ul>
<p><strong>锁升级</strong></p>
<p>自旋达到一定次数和程度: </p>
<ul>
<li>java6之前默认自旋10次或者自旋线程数超过cpu核数一半  -XX: PreBlockSpin= 10修改</li>
<li>java6之后自适应</li>
</ul>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><blockquote>
<p>Java中synchronized的重量级锁，是基于进入和退出Monitor对象实现的。在编译时会将同步块的开始位置插入monitor enter指令，在结束位置插入monitor exit指令。</p>
<p>当线程执行到monitor enter指令时，会尝试获取对象所对应的Monitor所有权，如果获取到了，即获取到了锁，会在Monitor的owner中存放当前线程的id，这样它将处于锁定状态，除非退出同步块，否则其他线程无法获取到这个Monitor。</p>
</blockquote>
<p>锁升级为轻量级或重量级锁后，Mark Word中保存的分别是线程栈帧里的锁记录指针和重量级锁指针，已经没有位置再保存哈希码,GC年龄</p>
<p><strong>当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了, 而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时, 它的偏向状态会被立即撤销, 并且锁会膨胀为重量级锁。</strong></p>
<ul>
<li>在无锁状态下，Mark Word中可以存储对象的identity hash code值。当对象的hashCode()方法第一次被调用时，JVM会生成对应的identity hash code值并将该值存储到Mark Word中。</li>
<li>对于偏向锁，在线程获取偏向锁时，会用Thread lD和epoch值覆盖identity hash code所在的位置。**( 已经计算过hash code升级到轻量级, 过程中需要计算, 升级到重量级再计算)** </li>
<li>升级为轻量级锁时，JVM会在当前线程的栈帧中创建一个锁记录(Lock Record)空间，用于存储锁对象的Mark Word拷贝，该拷贝中可以包含identity hash code，所以轻量级锁可以和identity hash code共存，哈希码和GC年龄自然保存在此，释放锁后会将这些信息写回到对象头。</li>
<li>升级为重量级锁后，Mark Word保存的重量级锁指针，代表重量级锁的ObjectMonitor类里有字段记录非加锁状态下的Mark.Nord，锁释放后也会将信息写回到对象头。</li>
</ul>
<h2 id="JIT编译器对锁的优化"><a href="#JIT编译器对锁的优化" class="headerlink" title="JIT编译器对锁的优化"></a>JIT编译器对锁的优化</h2><blockquote>
<p>Just In Time Compiler，一般翻译为即时编译器</p>
</blockquote>
<p>锁消除</p>
<p>锁粗化</p>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><blockquote>
<p> AbstractQueuedSynchronizer( 抽象的队列同步器 )简称为AQS</p>
<p>是用来实现锁或者其它同步器组件的公共基础部分的抽象实现，是重量级基础框架及整个JUC体系的基石，主要用于解决锁分配给”谁”的问题</p>
<p>整体就是一个抽象的FIFO队列来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态</p>
</blockquote>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221201134323004.png" alt="image-20221201134323004"></p>
<ul>
<li><strong>AQS中的队列是CLH变体的虚拟双向队列(FIFO)</strong>         state变量+CLH      CLH: Craig、Landin and Hagersten队列，是个单向链表，</li>
</ul>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221201135403934.png" alt="image-20221201135403934"></p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221201155452019.png" alt="image-20221201155452019"></p>
<h2 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h2><ul>
<li><p>公平锁:公平锁讲究先来先到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入等待队列中;</p>
</li>
<li><p>非公平锁:不管是否有等待队列，如果可以获取锁，则立刻占有锁对象。也就是说队列的第一个排队线程苏醒后，不一定就是排头的这个线程获得锁，它还是需要参加竞争锁（存在线程竞争的情况下)，后来的线程可能不讲武德插队夺锁了。</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221201154347404.png" alt="image-20221201154347404"></p>
</li>
</ul>
<p>整个 ReentrantLock 的加锁过程,可以分为三个阶段:</p>
<ol>
<li>尝试加锁;</li>
<li>加锁失败,线程入队列;</li>
<li>线程入队列后,进入阻塞状态。</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWFyNHkxeDcyNz9wPTE1MyZhbXA7dmRfc291cmNlPTY0YjJhZmIzZGZhNzhiMDk0MzUwZmVkODQyZmIxMDI1">AQS流程图详解<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<h2 id="JUC辅助类"><a href="#JUC辅助类" class="headerlink" title="JUC辅助类"></a>JUC辅助类</h2><ul>
<li><p>CountDownLatch (减少计数) : 不减少到零不执行</p>
</li>
<li><p>CyclicBarrier (循环栅栏): 不增加到指定不停止</p>
</li>
<li><p>Semaphore (信号灯)  : 设置许可位, 获取许可位才能运行, 释放后可被其他线程抢占</p>
</li>
<li><p>BlockingQueue 阻塞队列：　</p>
<ul>
<li>当队列是空的，从队列中获取元素的操作将会被阻塞</li>
<li>当队列是满的，从队列中添加元素的操作将会被阻塞</li>
</ul>
</li>
</ul>
<h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><blockquote>
<p>ReentrantReadWriteLock</p>
<p>读写锁定义为:一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。</p>
</blockquote>
<h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><ol>
<li>如果同一个线程持有了写锁，在没有释放写锁的情况下，它还可以继续获得读锁。这就是写锁的降级，降级成为了读锁。</li>
<li>规则惯例，先获取写锁，然后获取读锁，再释放写锁的次序。</li>
<li>如果释放了写锁，那么就完全转换为读锁。</li>
</ol>
<p>锁降级遵循: 获取写锁→再获取读锁→再释放写锁的次序，写锁能够降级成为读锁。</p>
<p><img src="https://lzc-oss.oss-cn-chengdu.aliyuncs.com/notes/image-20221202170935506.png" alt="image-20221202170935506"></p>
<h2 id="锁饥饿"><a href="#锁饥饿" class="headerlink" title="锁饥饿"></a>锁饥饿</h2><blockquote>
<p>ReentrantReadWriteLock实现了读写分离，但是一旦读操作比较多的时候，想要获取写锁就变得比较困难了，因为当前有可能会一直存在读锁，而无法获得写锁</p>
</blockquote>
<p>解决:　</p>
<ul>
<li>使用“公平”策略可以一定程度上缓解这个问题, 但是“公平”策略是以牺牲系统吞吐量为代价的</li>
<li>StampedLock类的乐观读锁<ul>
<li>StampedLock采取乐观获取锁后，其他线程尝试获取写锁时不会被阻塞，在获取乐观读锁后，还需要对结果进行校验。</li>
</ul>
</li>
</ul>
<p><strong>StampedLock</strong></p>
<ul>
<li>所有获取锁的方法，都返回一个邮戳(Stamp), stamp为零表示获取失败，其余都表示成功;</li>
<li>所有释放锁的方法，都需要一个邮戳〈Stamp）,这个Stamp必须是和成功获取锁时得到的Stamp一致;</li>
<li>StampedLock是不可重入的，危险 (如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁)</li>
<li>StampedLock有三种访问模式<ul>
<li>Reading（读模式悲观）:功能和ReentrantReadWriteLock的读锁类似</li>
<li>Writing (写模式）:功能和ReentrantRedWriteLock的写锁类似</li>
<li>Optimistic readina （乐观读模式):无锁机制，类似于数据库中的乐观锁，支持读写并发，很乐观认乎读取时没人修改，假如被修改再实现升级为悲观读模式</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/31/%E6%8E%92%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="LazyC-99">
      <meta itemprop="description" content="Human sorrows and joys are not interlinked, I just think they are noisy.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LazyC-99">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/31/%E6%8E%92%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">排序查找算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-31 20:38:57" itemprop="dateCreated datePublished" datetime="2021-08-31T20:38:57+08:00">2021-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-22 16:15:02" itemprop="dateModified" datetime="2022-06-22T16:15:02+08:00">2022-06-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>时间频度：<br>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/08/31/%E6%8E%92%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/30/%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="LazyC-99">
      <meta itemprop="description" content="Human sorrows and joys are not interlinked, I just think they are noisy.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LazyC-99">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/30/%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">十大常用算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-30 20:47:57" itemprop="dateCreated datePublished" datetime="2021-08-30T20:47:57+08:00">2021-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-19 20:10:03" itemprop="dateModified" datetime="2022-05-19T20:10:03+08:00">2022-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="二分查找（非递归）"><a href="#二分查找（非递归）" class="headerlink" title="二分查找（非递归）"></a>二分查找（非递归）</h4>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/08/30/%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="LazyC-99">
      <meta itemprop="description" content="Human sorrows and joys are not interlinked, I just think they are noisy.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LazyC-99">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">数据结构与算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-17 21:47:57" itemprop="dateCreated datePublished" datetime="2021-08-17T21:47:57+08:00">2021-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 21:38:56" itemprop="dateModified" datetime="2022-06-23T21:38:56+08:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>数据结构包括：线性结构和非线性结构</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LazyC-99"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">LazyC-99</p>
  <div class="site-description" itemprop="description">Human sorrows and joys are not interlinked, I just think they are noisy.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xhenlDLTk5" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LazyC-99"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fab fa-blogger"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LazyC-99</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">110k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:40</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
